var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Core-Types-and-Functions","page":"API Reference","title":"Core Types and Functions","text":"","category":"section"},{"location":"api/#GraphCore.AdjGraph","page":"API Reference","title":"GraphCore.AdjGraph","text":"AdjGraph{D} <: GraphInterface\n\nDynamic graph using adjacency lists (Vector{Vector{Int32}}) for neighbor storage. Optimized for structural mutations with reasonable query performance.\n\nType Parameters\n\nD::Bool: Directedness flag (true = directed, false = undirected)\n\nFields (Internal - Access via interface methods)\n\nneighbors::Vector{Vector{Int32}}: Per-vertex neighbor lists\nneighbor_to_edge::Vector{Vector{Int32}}: Maps neighbor positions to edge indices (undirected only)\nnum_edges::Int32: Number of (undirected) edges\n\nConstruction\n\nUse build_adj_graph() or build_graph(AdjGraph, ...) for safe construction:\n\n# Basic construction\nedges = [(1,2), (2,3), (1,3)]\ng = build_adj_graph(edges; directed=false)\n\n# Direct type construction with mutation\ng = build_graph(AdjGraph, edges; directed=false)\nadd_edge!(g, 4, 1)  # Efficient dynamic modification\n\nMemory Layout Example\n\nFor graph with edges [(1,2), (2,3), (1,3)], undirected:\n\nneighbors = [[2,3], [1,3], [1,2]]           # Vertex 1: neighbors 2,3; Vertex 2: neighbors 1,3, etc.\nneighbor_to_edge = [[1,3], [1,2], [3,2]]    # Maps: v1's neighbor 2→edge 1, v1's neighbor 3→edge 3, etc.\n\nPerformance Notes\n\nBest for: Dynamic graphs with frequent add/remove operations\nMutations: O(1) additions, O(degree) removals\nMemory: ~16-24 bytes per directed edge (vector overhead + pointers)\nCache: Good for sparse graphs, less optimal for dense graphs\n\nMutation Support\n\n# Efficient dynamic operations\nnew_vertex = add_vertex!(g)           # O(1) - just adds empty vectors\nedge_idx = add_edge!(g, u, v)         # O(1) amortized - vector push\nsuccess = remove_edge!(g, u, v)       # O(degree) - find and remove\nsuccess = remove_vertex!(g, v)        # O(V + incident edges) - updates all references\n\n# ⚠️ Warning: Removals may invalidate edge indices\n# External arrays indexed by edges will become inconsistent\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.AdjGraph-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.AdjGraph","text":"AdjGraph(g::GraphInterface) -> AdjGraph\n\nConvert any GraphInterface implementation to an AdjGraph using constructor syntax. This is an idiomatic Julia alternative to to_adj_graph(g).\n\nExamples\n\n# Constructor style (idiomatic)\nadj_g = AdjGraph(core_graph)\n\n# Equivalent to conversion function\nadj_g = to_adj_graph(core_graph)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.AdjGraph-Union{Tuple{GraphInterface}, Tuple{D}} where D","page":"API Reference","title":"GraphCore.AdjGraph","text":"AdjGraph{D}(g::GraphInterface) -> AdjGraph{D}\n\nConvert any GraphInterface to an AdjGraph with explicit directedness type parameter. The source graph must have the same directedness as specified by the type parameter.\n\nExamples\n\n# Type-safe conversions (will succeed)\ndirected_adj = AdjGraph{true}(directed_core_graph)\nundirected_adj = AdjGraph{false}(undirected_core_graph)\n\n# Type mismatch (will throw AssertionError)\n# AdjGraph{true}(undirected_graph)  # ERROR!\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.CoreGraph","page":"API Reference","title":"GraphCore.CoreGraph","text":"CoreGraph{D} <: GraphInterface\n\nHigh-performance graph using Compressed Sparse Row (CSR) storage format.\n\nType Parameters\n\nD::Bool: Directedness flag (true = directed, false = undirected)\n\nFields (Internal - Access via interface methods)\n\nvertex_offsets::Vector{Int32}: CSR row pointers (length = nv + 1)\nneighbors::Vector{Int32}: Flattened neighbor lists\nneighbor_to_edge::Vector{Int32}: Maps neighbor positions to undirected edge indices (undirected only)\nnum_edges::Int32: Number of (undirected) edges\n\nConstruction\n\nUse build_core_graph() or build_graph(CoreGraph, ...) for safe construction:\n\n# Basic construction\nedges = [(1,2), (2,3), (1,3)]\ng = build_core_graph(edges; directed=false)\n\n# With validation disabled (faster, but unsafe)\ng = build_graph(CoreGraph, edges; directed=false, validate=false)\n\nMemory Layout Example\n\nFor graph with edges [(1,2), (2,3), (1,3)], undirected:\n\nvertex_offsets = [1, 3, 6, 8]       # Vertex 1: neighbors[1:2], Vertex 2: neighbors[3:5], etc.\nneighbors = [2, 3, 1, 3, 1, 2]      # Flattened: [neighbors(1), neighbors(2), neighbors(3)]\nneighbor_to_edge = [1, 3, 1, 2, 3, 2] # Maps each neighbor to its edge index\n\nPerformance Notes\n\nBest for: Static graphs with frequent neighbor access\nAvoid for: Graphs requiring frequent structural modifications\nMemory: ~12-16 bytes per directed edge (depending on architecture)\nCache: Excellent locality for neighbor iteration\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.CoreGraph-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.CoreGraph","text":"CoreGraph(g::GraphInterface) -> CoreGraph\n\nConvert any GraphInterface implementation to a CoreGraph using constructor syntax. This is an idiomatic Julia alternative to to_core_graph(g).\n\nExamples\n\n# Constructor style (idiomatic)\ncore_g = CoreGraph(adj_graph)\n\n# Equivalent to conversion function\ncore_g = to_core_graph(adj_graph)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.CoreGraph-Union{Tuple{GraphInterface}, Tuple{D}} where D","page":"API Reference","title":"GraphCore.CoreGraph","text":"CoreGraph{D}(g::GraphInterface) -> CoreGraph{D}\n\nConvert any GraphInterface to a CoreGraph with explicit directedness type parameter. The source graph must have the same directedness as specified by the type parameter.\n\nExamples\n\n# Type-safe conversions (will succeed)\ndirected_core = CoreGraph{true}(directed_adj_graph)\nundirected_core = CoreGraph{false}(undirected_adj_graph)\n\n# Type mismatch (will throw TypeError)\n# CoreGraph{true}(undirected_graph)  # ERROR!\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.GraphInterface","page":"API Reference","title":"GraphCore.GraphInterface","text":"GraphInterface <: AbstractGraph{Int32}\n\nBase abstract type for all graphs in the GraphCore ecosystem. All vertices are indexed by Int32 integers 1, 2, ..., num_vertices(g).\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.PropertyGraph","page":"API Reference","title":"GraphCore.PropertyGraph","text":"PropertyGraph{G,V,E} <: PropertyGraphInterface{V,E}\n\nUniversal property graph that wraps any base graph type with typed vertex and edge properties.\n\nType Parameters\n\nG<:GraphInterface: Base graph type (CoreGraph, WeightedGraph, AdjGraph, etc.)\nV: Vertex property type\nE: Edge property type\n\nDesign Benefits\n\nUniversal wrapper: Works with any GraphInterface implementation\nZero-cost delegation: All structural operations forwarded to base graph\nType safety: Compile-time property type guarantees\nAutomatic mutations: Inherits mutation capabilities from base graph\nMemory efficiency: No overhead when properties are unused\n\nUsage Patterns\n\n# Static analysis with CoreGraph base\ncore_g = build_core_graph(edges; directed=false)\nvertex_labels = [\"Alice\", \"Bob\", \"Charlie\"]\nedge_types = [\"friend\", \"colleague\", \"family\"]\npg = PropertyGraph(core_g, vertex_labels, edge_types)\n\n# Access patterns\nname = pg[1]                           # Vertex property via indexing\nedge_type = edge_property(pg, 2)       # Edge property by index\npg[1] = \"Alice Updated\"                # Property modification\n\n# Dynamic graphs with AdjGraph base\nadj_g = build_adj_graph(edges; directed=false)\npg_mut = PropertyGraph(adj_g, vertex_labels, edge_types)\n\n# Efficient mutations (when base graph supports them)\nnew_vertex = add_vertex!(pg_mut, \"David\")           # O(1) addition\nedge_idx = add_edge!(pg_mut, 1, new_vertex, \"buddy\")  # O(1) addition\n\n# Combined with weights\nweighted_g = build_weighted_graph(edges, weights; directed=false)\npg = PropertyGraph(weighted_g, vertex_labels, edge_types)\n# Now has both weights and properties available\n\nMutation Behavior\n\n# Mutations work when base graph supports them\nadj_pg = PropertyGraph(build_adj_graph(edges), v_props, e_props)\nadd_edge!(adj_pg, u, v, edge_prop)  # ✅ Works - AdjGraph supports mutations\n\n# Mutations fail gracefully when base graph doesn't support them\ncore_pg = PropertyGraph(build_core_graph(edges), v_props, e_props)\nadd_edge!(core_pg, u, v, edge_prop)  # ❌ MethodError - CoreGraph is immutable\n\n# Property arrays are automatically maintained during mutations\noriginal_count = length(adj_pg.edge_properties)\nedge_idx = add_edge!(adj_pg, u, v, edge_prop)\n@assert length(adj_pg.edge_properties) == original_count + 1\n\nPerformance Notes\n\nDelegation overhead: Typically optimized away by compiler\nMutation performance: Same as underlying graph type\nProperty management: Automatic with minimal overhead\nMemory: Base graph memory + property arrays + small wrapper overhead\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.PropertyGraphInterface","page":"API Reference","title":"GraphCore.PropertyGraphInterface","text":"PropertyGraphInterface{V,E,W} <: GraphInterface\nAbstract interface for property graphs, which support vertex and edge properties.\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.WeightedAdjGraph","page":"API Reference","title":"GraphCore.WeightedAdjGraph","text":"WeightedAdjGraph{W,D} <: WeightedGraphInterface{W}\n\nWeighted dynamic graph extending AdjGraph with parallel weight storage. Combines the mutation efficiency of adjacency lists with type-safe weights.\n\nType Parameters\n\nW<:Number: Weight type (Float64, Int32, etc.)\nD::Bool: Directedness flag\n\nKey Features\n\nSame mutation performance as AdjGraph for structural operations\nType-safe weights with compile-time guarantees\nDirectional weights even for undirected graphs\nParallel storage maintaining weight-neighbor correspondence\n\nWeight Semantics\n\nImportant: Weights are always directional, even for undirected graphs. This allows asymmetric edge properties while maintaining undirected connectivity.\n\n# For undirected edge with different directional costs:\ng = build_weighted_adj_graph([(1,2)], [1.5]; directed=false)\n# Internally stores: neighbors[1]=[2], weights[1]=[1.5]\n#                   neighbors[2]=[1], weights[2]=[1.5]\n# But weights can be modified independently if needed\n\n# Access via directional indexing:\nidx_12 = find_directed_edge_index(g, 1, 2)  # Different from (2,1)\nidx_21 = find_directed_edge_index(g, 2, 1)\nweight_12 = edge_weight(g, idx_12)  # Initial: 1.5\nweight_21 = edge_weight(g, idx_21)  # Initial: 1.5 (same value, different storage)\n\nMutation Examples\n\nedges = [(1,2), (2,3)]\nweights = [1.0, 2.0]\ng = build_weighted_adj_graph(edges, weights; directed=false)\n\n# Add weighted edge\nedge_idx = add_edge!(g, 3, 1, 1.5)  # O(1) amortized\n\n# Efficient weight access during iteration\nfor (neighbor, weight) in neighbor_weights(g, v)\n    process_weighted_neighbor(neighbor, weight)\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.WeightedAdjGraph-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W","page":"API Reference","title":"GraphCore.WeightedAdjGraph","text":"WeightedAdjGraph(g::WeightedGraphInterface{W}) -> WeightedAdjGraph{W}\nWeightedAdjGraph{W}(g::WeightedGraphInterface{W}) -> WeightedAdjGraph{W}\nWeightedAdjGraph{W,D}(g::WeightedGraphInterface{W}) -> WeightedAdjGraph{W,D}\n\nConvert any WeightedGraphInterface to a WeightedAdjGraph using constructor syntax. Supports multiple forms with different levels of type specification.\n\nConstructor Forms\n\nWeightedAdjGraph(g): Auto-infer weight type and directedness\nWeightedAdjGraph{W}(g): Explicit weight type parameter\nWeightedAdjGraph{W,D}(g): Explicit weight type and directedness parameters\n\nExamples\n\n# Basic constructor (auto-infer types)\nweighted_adj = WeightedAdjGraph(weighted_core_graph)\n\n# Explicit weight type\nweighted_adj = WeightedAdjGraph{Float64}(core_graph)\n\n# Full type specification\n# Full type specification with directedness assertion\ndirected_weighted_adj = WeightedAdjGraph{Float64,true}(directed_weighted_graph)   # ✅ OK\nundirected_weighted_adj = WeightedAdjGraph{Float64,false}(undirected_weighted_graph) # ✅ OK\n# WeightedAdjGraph{Float64,true}(undirected_graph)  # ❌ ERROR: directedness mismatch\n\n# Equivalent to conversion function\nweighted_adj = to_weighted_adj_graph(weighted_core_graph)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.WeightedGraph","page":"API Reference","title":"GraphCore.WeightedGraph","text":"WeightedGraph{W,D} <: WeightedGraphInterface{W}\n\nWeighted graph extending CoreGraph with parallel weight storage.\n\nType Parameters\n\nW<:Number: Weight type (Float64, Int32, etc.)\nD::Bool: Directedness flag\n\nKey Features\n\nSame performance as CoreGraph for structural operations\nType-safe weights with compile-time guarantees\nDirectional weights even for undirected graphs\nParallel storage for cache-efficient weight access\n\nWeight Semantics\n\nImportant: Weights are always directional, even for undirected graphs. This allows asymmetric edge properties (e.g., different costs per direction).\n\n# For undirected edge (1,2) with weight 1.5:\nedge_weight(g, find_directed_edge_index(g, 1, 2)) # → 1.5\nedge_weight(g, find_directed_edge_index(g, 2, 1)) # → 1.5 (same value, different index)\n\n# But can be set differently if needed:\nweights = [1.5, 2.0]  # Different costs for each direction\ng = build_weighted_graph([(1,2), (2,1)], weights; directed=true)\n\nConstruction Examples\n\n# Undirected weighted graph\nedges = [(1,2), (2,3)]\nweights = [1.5, 2.0]\ng = build_weighted_graph(edges, weights; directed=false)\n\n# Type-specific construction\ng = build_graph(WeightedGraph{Float32}, edges; weights=weights, directed=false)\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.WeightedGraph-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W","page":"API Reference","title":"GraphCore.WeightedGraph","text":"WeightedGraph(g::WeightedGraphInterface{W}) -> WeightedGraph{W}\nWeightedGraph{W}(g::WeightedGraphInterface{W}) -> WeightedGraph{W}\nWeightedGraph{W,D}(g::WeightedGraphInterface{W}) -> WeightedGraph{W,D}\n\nConvert any WeightedGraphInterface to a WeightedGraph using constructor syntax. Supports multiple forms with different levels of type specification.\n\nConstructor Forms\n\nWeightedGraph(g): Auto-infer weight type and directedness\nWeightedGraph{W}(g): Explicit weight type parameter\nWeightedGraph{W,D}(g): Explicit weight type and directedness parameters (with type assertion)\n\nExamples\n\n# Basic constructor (auto-infer types)\nweighted_g = WeightedGraph(weighted_adj_graph)\n\n# Explicit weight type\nweighted_g = WeightedGraph{Float64}(adj_graph)\n\n# Full type specification with directedness assertion\ndirected_weighted = WeightedGraph{Float64,true}(directed_weighted_graph)   # ✅ OK\nundirected_weighted = WeightedGraph{Float64,false}(undirected_weighted_graph) # ✅ OK\n# WeightedGraph{Float64,true}(undirected_graph)  # ❌ ERROR: directedness mismatch\n\n# Equivalent to conversion function\nweighted_g = to_weighted_graph(weighted_adj_graph)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.WeightedGraphInterface","page":"API Reference","title":"GraphCore.WeightedGraphInterface","text":"WeightedGraphInterface <: GraphInterface\n\nInterface for weighted graphs, extending the core graph interface. W is the type of edge weights, typically a numeric type.\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.add_edge!","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(g::GraphInterface, u::Integer, v::Integer, ...) -> Int32\n\nAdd an edge from u to v with the optinal properties. Returns the edge index of the newly added edge, or 0 if edge already exists. For undirected graphs, this adds the edge in both directions internally. Only available for mutable graph types.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.add_edge!-Tuple{AdjGraph, Integer, Integer}","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(g::AdjGraph, u::Integer, v::Integer) -> Int32\n\nAdd an edge from u to v and return the edge index (or 0 if already exists).\n\nPerformance\n\nTime Complexity: O(1) amortized (vector push operations)\nSpace Complexity: O(1) per direction\nIndex Stability: All existing indices remain valid, new edge gets max+1\n\nBehavior Details\n\nDirected graphs: Adds only u→v edge\nUndirected graphs: Adds both u→v and v→u internally with same edge index\nDuplicate detection: Returns 0 if edge already exists (no modification)\nIndex assignment: New edges get next available index\n\nExamples\n\ng = build_adj_graph([(1,2)]; directed=false)\n@assert num_edges(g) == 1\n\n# Add new edge\nedge_idx = add_edge!(g, 2, 3)\n@assert edge_idx == 2  # Next available index\n@assert num_edges(g) == 2\n@assert has_edge(g, 2, 3) && has_edge(g, 3, 2)  # Both directions for undirected\n\n# Try duplicate\nduplicate_idx = add_edge!(g, 1, 2)\n@assert duplicate_idx == 0  # Already exists\n@assert num_edges(g) == 2    # No change\n\nError Conditions\n\nThrows BoundsError if vertices u or v don't exist in the graph. Use add_vertex! first if needed.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_edge!-Union{Tuple{D}, Tuple{CoreGraph{D}, Integer, Integer}} where D","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(g::CoreGraph, u::Integer, v::Integer) -> Int32\n\nAdd an edge from u to v and return the edge index (or 0 if edge already exists).\n\nEfficient Implementation: O(degree) operation that extends the CSR arrays and updates offsets.\n\nFor undirected graphs, this adds the edge in both directions internally.\n\nExample\n\ng = build_core_graph([(1,2)]; directed=false)\nedge_idx = add_edge!(g, 1, 3)  # Returns edge index\n@assert has_edge(g, 1, 3) && has_edge(g, 3, 1)  # Both directions for undirected\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_edge!-Union{Tuple{D}, Tuple{W}, Tuple{WeightedGraph{W, D}, Integer, Integer, W}} where {W, D}","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(g::WeightedGraph{W}, u::Integer, v::Integer, weight::W) -> Int32\n\nAdd a weighted edge from u to v and return the edge index (or 0 if edge already exists).\n\nEfficient Implementation: O(degree) operation that extends the CSR arrays and updates offsets.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_edge!-Union{Tuple{E}, Tuple{V}, Tuple{G}, Tuple{PropertyGraph{G, V, E}, Integer, Integer, E}} where {G, V, E}","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(g::PropertyGraph{G,V,E}, u::Integer, v::Integer, edge_prop::E) -> Int32\n\nAdd an edge from u to v with the specified edge property. Returns the edge index of the newly added edge, or 0 if edge already exists.\n\nOnly available when the base graph type supports add_edge!. Property arrays are automatically maintained.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_edge!-Union{Tuple{E}, Tuple{V}, Tuple{W}, Tuple{PropertyGraph{<:WeightedGraphInterface{W}, V, E}, Integer, Integer, W, E}} where {W, V, E}","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(g::PropertyGraph{<:WeightedGraphInterface,V,E}, u::Integer, v::Integer,\n          weight::W, edge_prop::E) -> Int32\n\nAdd a weighted edge from u to v with the specified weight and edge property. Returns the edge index of the newly added edge, or 0 if edge already exists.\n\nOnly available when the base graph type supports weighted add_edge!.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_edge!-Union{Tuple{W}, Tuple{WeightedAdjGraph{W}, Integer, Integer, W}} where W","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(g::WeightedAdjGraph{W}, u::Integer, v::Integer, weight::W) -> Int32\n\nAdd a weighted edge from u to v in the graph. Returns the edge index of the newly added edge, or 0 if edge already exists. For undirected graphs, both directions get the same weight.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_vertex!","page":"API Reference","title":"GraphCore.add_vertex!","text":"add_vertex!(g::GraphInterface, ...) -> Int32\n\nAdd a new vertex with optional properties. Returns the index of the newly added vertex. Only available for mutable graph types.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.add_vertex!-Tuple{AdjGraph}","page":"API Reference","title":"GraphCore.add_vertex!","text":"add_vertex!(g::AdjGraph) -> Int32\n\nAdd a new isolated vertex to the graph and return its index.\n\nPerformance\n\nTime Complexity: O(1)\nSpace Complexity: O(1) - just adds empty vectors\nIndex Stability: All existing vertex/edge indices remain valid\n\nImplementation Details\n\nCreates empty neighbor list and empty neighbortoedge mapping. New vertex has no neighbors initially and can be connected via add_edge!.\n\nExamples\n\ng = build_adj_graph([(1,2), (2,3)]; directed=false)\n@assert num_vertices(g) == 3\n\nnew_v = add_vertex!(g)\n@assert new_v == 4\n@assert num_vertices(g) == 4\n@assert degree(g, new_v) == 0  # Isolated vertex\n\n# Connect new vertex\nadd_edge!(g, 1, new_v)\n@assert degree(g, new_v) == 1\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_vertex!-Union{Tuple{CoreGraph{D}}, Tuple{D}} where D","page":"API Reference","title":"GraphCore.add_vertex!","text":"add_vertex!(g::CoreGraph) -> Int32\n\nAdd a new isolated vertex to the graph and return its index.\n\nEfficient Implementation: O(1) operation that simply extends the vertex_offsets array.\n\nExample\n\ng = build_core_graph([(1,2), (2,3)]; directed=false)\nnew_vertex = add_vertex!(g)  # Returns 4\n@assert num_vertices(g) == 4\n@assert length(neighbor_indices(g, new_vertex)) == 0  # Isolated vertex\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_vertex!-Union{Tuple{E}, Tuple{V}, Tuple{G}, Tuple{PropertyGraph{G, V, E}, V}} where {G, V, E}","page":"API Reference","title":"GraphCore.add_vertex!","text":"add_vertex!(g::PropertyGraph{G,V,E}, vertex_prop::V) -> Int32\n\nAdd a new vertex to the property graph with the specified property. Returns the index of the new vertex.\n\nOnly available when the base graph type supports add_vertex!.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_vertex!-Union{Tuple{WeightedAdjGraph{W}}, Tuple{W}} where W","page":"API Reference","title":"GraphCore.add_vertex!","text":"add_vertex!(g::WeightedAdjGraph{W}) -> Int32 where W\n\nAdd a new vertex to the weighted graph and return its index. The new vertex has no neighbors initially.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_vertex!-Union{Tuple{WeightedGraph{W, D}}, Tuple{D}, Tuple{W}} where {W, D}","page":"API Reference","title":"GraphCore.add_vertex!","text":"add_vertex!(g::WeightedGraph) -> Int32\n\nAdd a new isolated vertex to the weighted graph and return its index.\n\nEfficient Implementation: O(1) operation that simply extends the vertex_offsets array.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.all_directed_edges-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.all_directed_edges","text":"all_directed_edges(g::GraphInterface) -> Iterator\n\nReturn an iterator over all directed edges in the graph.\n\nFor directed graphs: yields (source, target) pairs for each directed edge\nFor undirected graphs: yields (u, v) and (v, u) pairs for each undirected edge\n\nExamples\n\nfor (u, v) in all_directed_edges(g)\n    println(\"Directed edge from \", u, \" to \", v)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.all_edges-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.all_edges","text":"all_edges(g::GraphInterface) -> Iterator\n\nAlias for edges(g). Provided for disambiguation when using multiple graph libraries.\n\nSee also: edges\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_adj_graph-Tuple{Any}","page":"API Reference","title":"GraphCore.build_adj_graph","text":"Build adjacency list graph with same interface as CoreGraph.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_core_graph-Tuple{Any}","page":"API Reference","title":"GraphCore.build_core_graph","text":"Build unweighted core graph (most common case)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_graph-Union{Tuple{W}, Tuple{E}, Tuple{V}, Tuple{G}, Tuple{Type{PropertyGraph{G, V, E}}, Any}} where {G<:GraphInterface, V, E, W<:Number}","page":"API Reference","title":"GraphCore.build_graph","text":"build_graph(::Type{PropertyGraph{G,V,E}}, edges; kwargs...) where {G,V,E}\n\nBuild a property graph with vertex and edge properties. The underlying graph type G determines performance characteristics (CoreGraph for CSR, AdjGraph for adjacency list).\n\nArguments\n\nedges: Vector of (u,v) tuples/pairs representing graph edges\ndirected=true: Whether the graph is directed\nvertex_properties=[]: Properties for each vertex (type V)\nedge_properties=[]: Properties for each edge (type E)\nweights=[]: Edge weights (optional)\nvalidate=true: Whether to validate inputs\n\nExamples\n\n# Property graph with CoreGraph backend\ng = build_graph(PropertyGraph{CoreGraph,String,String}, [(1,2), (2,3)];\n                vertex_properties=[\"A\", \"B\", \"C\"], edge_properties=[\"e1\", \"e2\"])\n\n# Property graph with AdjGraph backend for dynamic use\ng = build_graph(PropertyGraph{AdjGraph,Int,Symbol}, [(1,2), (2,3)];\n                vertex_properties=[1, 2, 3], edge_properties=[:a, :b])\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_graph-Union{Tuple{W}, Tuple{G}, Tuple{Type{G}, Any}} where {G<:Union{AdjGraph, WeightedAdjGraph}, W<:Number}","page":"API Reference","title":"GraphCore.build_graph","text":"build_graph(::Type{G}, edges; kwargs...) where {G<:AdjGraphTypes}\n\nBuild adjacency list graph optimized for dynamic modifications and mutations.\n\nArguments\n\nedges: Vector of (u,v) tuples/pairs representing graph edges\ndirected=true: Whether to build a directed graph\nweights=[]: Edge weights (for WeightedAdjGraph types)\nvalidate=true: Enable input validation\n\nPerformance Characteristics\n\nDynamic-friendly: Efficient vertex/edge additions and removals\nMemory flexible: Grows naturally, higher overhead than CSR\nMutation-optimized: O(1) edge additions, efficient vertex operations\n\nUse AdjGraph types when frequent graph modifications are expected. For static graphs with performance-critical traversals, prefer CoreGraph types.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_graph-Union{Tuple{W}, Tuple{G}, Tuple{Type{G}, Any}} where {G<:Union{CoreGraph, WeightedGraph}, W<:Number}","page":"API Reference","title":"GraphCore.build_graph","text":"build_graph(::Type{G}, edges; kwargs...) -> G\n\nBuild a graph from an edge list with comprehensive validation and flexible options.\n\nArguments\n\nedges: Vector of (u,v) tuples/pairs representing graph edges\ndirected=true: Whether to build a directed graph\nn=0: Number of vertices (0 = auto-detect from edges)\nweights=[]: Edge weights (for WeightedGraph types)\nvalidate=true: Enable input validation (recommended for safety)\n\nExamples\n\n# Basic graphs\ng = build_graph(CoreGraph, [(1,2), (2,3)]; directed=false)\nwg = build_graph(WeightedGraph{Float64}, [(1,2), (2,3)]; weights=[1.5, 2.0], directed=false)\n\n# Graph with isolated vertices\ng = build_graph(CoreGraph, [(1,2)]; n=5, directed=false)  # Creates isolated vertices 3,4,5\n\n# High-performance mode (skip validation)\ng = build_graph(CoreGraph, trusted_edges; directed=false, validate=false)\n\nOptimized for CSR representation with efficient construction and memory usage. For dynamic graphs requiring frequent mutations, consider AdjGraph types.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_property_adj_graph-Union{Tuple{E}, Tuple{V}, Tuple{Any, AbstractVector{V}, AbstractVector{E}}} where {V, E}","page":"API Reference","title":"GraphCore.build_property_adj_graph","text":"build_property_adj_graph(edges, vertex_properties, edge_properties; directed=true, kwargs...)\n\nBuild a PropertyGraph with AdjGraph backend (supports efficient mutations).\n\nArguments\n\nedges: Vector of (u,v) tuples representing graph edges\nvertex_properties: Vector of vertex properties\nedge_properties: Vector of edge properties\ndirected=true: Whether to build a directed graph\nkwargs...: Additional arguments passed to underlying graph construction\n\nExample\n\nedges = [(1,2), (2,3)]\nvertex_props = [1, 2, 3]\nedge_props = [:a, :b]\npg = build_property_adj_graph(edges, vertex_props, edge_props; directed=false)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_property_graph-Union{Tuple{E}, Tuple{V}, Tuple{Any, AbstractVector{V}, AbstractVector{E}}} where {V, E}","page":"API Reference","title":"GraphCore.build_property_graph","text":"build_property_graph(edges, vertex_properties, edge_properties; directed=true, kwargs...)\n\nBuild a PropertyGraph with CoreGraph backend.\n\nArguments\n\nedges: Vector of (u,v) tuples representing graph edges\nvertex_properties: Vector of vertex properties\nedge_properties: Vector of edge properties\ndirected=true: Whether to build a directed graph\nkwargs...: Additional arguments passed to underlying graph construction\n\nExample\n\nedges = [(1,2), (2,3), (1,3)]\nvertex_props = [\"Alice\", \"Bob\", \"Charlie\"]\nedge_props = [\"friend\", \"colleague\", \"family\"]\npg = build_property_graph(edges, vertex_props, edge_props; directed=false)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_weighted_graph-Union{Tuple{W}, Tuple{Any, AbstractVector{W}}} where W","page":"API Reference","title":"GraphCore.build_weighted_graph","text":"Build weighted graph\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.canonicalize_edges-Tuple{Any}","page":"API Reference","title":"GraphCore.canonicalize_edges","text":"canonicalize_edges(edges) -> Vector{Tuple{Int,Int}}\n\nConvert symmetric edge format to canonical format for undirected graphs.\n\nArguments\n\nedges: Vector of (u,v) tuples representing edges\n\nReturns\n\nVector of canonical edges where u ≤ v for each edge\n\nFormat Conversion\n\nInput: [(1,2), (2,1), (2,3), (3,2)] (both directions)\nOutput: [(1,2), (2,3)] (canonical: u ≤ v)\n\nUse when your input has both directions listed for undirected edges. This removes duplicates and ensures a consistent canonical representation.\n\nExample\n\nedges = [(1,2), (2,1), (2,3), (3,2), (1,3), (3,1)]\ncanonical = GraphCore.canonicalize_edges(edges)\n# Result: [(1,2), (1,3), (2,3)]\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.canonicalize_edges-Union{Tuple{W}, Tuple{Any, AbstractVector{W}}} where W","page":"API Reference","title":"GraphCore.canonicalize_edges","text":"canonicalize_edges(edges, weights::AbstractVector{W}) -> (canonical_edges, canonical_weights)\n\nConvert symmetric format to canonical, keeping weights for canonical edges only.\n\nArguments\n\nedges: Vector of (u,v) tuples representing edges\nweights: Vector of weights corresponding to edges\n\nReturns\n\nTuple of (canonicaledges, canonicalweights)\n\nBehavior\n\nWhen multiple weights exist for the same undirected edge, keeps the first encountered weight. This is useful when processing datasets that list both directions with potentially different weights.\n\nExample\n\nedges = [(1,2), (2,1), (2,3), (3,2)]\nweights = [1.5, 1.5, 2.0, 2.1]  # Note: slight difference in last weight\ncanonical_edges, canonical_weights = GraphCore.canonicalize_edges(edges, weights)\n# Result: edges = [(1,2), (2,3)], weights = [1.5, 2.0]\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.degree-Tuple{GraphInterface, Integer}","page":"API Reference","title":"GraphCore.degree","text":"degree(g::GraphInterface, v::Integer) -> Int32\n\nReturn the degree of vertex v (number of neighbors).\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.directed_edge_index","page":"API Reference","title":"GraphCore.directed_edge_index","text":"directed_edge_index(g::GraphInterface, v::Integer, i::Integer) -> Int32\n\nGet the directed edge index for the i-th neighbor of vertex v.\n\nSimilar to edge_index but for directional properties. Always provides directional indexing even for undirected graphs.\n\nKey difference: For undirected graphs:\n\nedge_index(g, u, i) == edge_index(g, v, j) if neighbors are the same edge\ndirected_edge_index(g, u, i) ≠ directed_edge_index(g, v, j) (always directional)\n\nThis enables asymmetric properties on undirected graphs (e.g., different costs for traversing an edge in each direction).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.directed_edge_indices","page":"API Reference","title":"GraphCore.directed_edge_indices","text":"directed_edge_indices(g::GraphInterface, v::Integer) -> view or iterator\n\nReturn an iterator over the directed edge indices for edges from vertex v. The i-th edge index corresponds to the i-th neighbor in neighbor_indices(g, v). For directed graphs this is the same asdirectededgeindices(g, v)`.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.directed_edge_indices-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.directed_edge_indices","text":"directed_edge_indices(g::GraphInterface) -> UnitRange{Int}\n\nReturn a range over all directed edge indices. Suitable for sizing and indexing external directed edge property arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.edge_index","page":"API Reference","title":"GraphCore.edge_index","text":"edge_index(g::GraphInterface, v::Integer, i::Integer) -> Int32\n\nGet the undirected edge index for the i-th neighbor of vertex v.\n\nThis provides O(1) conversion from neighbor position to edge index, enabling efficient indexing into external edge property arrays.\n\nRelationship: edge_index(g, v, i) == find_edge_index(g, v, neighbor_indices(g, v)[i])\n\nUse case: Processing neighbors with associated edge data\n\nedge_weights = Vector{Float64}(undef, num_edges(g))\nfor (i, neighbor) in enumerate(neighbor_indices(g, v))\n    edge_idx = edge_index(g, v, i)           # O(1) - no search needed!\n    weight = edge_weights[edge_idx]          # Direct array access\n    process_neighbor_with_weight(neighbor, weight)\nend\n\nIndex stability: Edge indices remain stable during graph analysis, but may be invalidated by structural modifications (add/remove operations).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.edge_indices","page":"API Reference","title":"GraphCore.edge_indices","text":"edge_indices(g::GraphInterface, v::Integer) -> view or iterator\n\nReturn an iterator over the undirected edge indices for edges from vertex v. The i-th edge index corresponds to the i-th neighbor in neighbor_indices(g, v).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.edge_indices-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.edge_indices","text":"edge_indices(g::GraphInterface) -> UnitRange{Int}\n\nReturn a range over all undirected edge indices. Suitable for sizing and indexing external edge property arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.edge_properties","page":"API Reference","title":"GraphCore.edge_properties","text":"edge_properties(g::PropertyGraphInterface) -> iterator\n\nReturn an iterator over all edge properties in edge index order.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.edge_property","page":"API Reference","title":"GraphCore.edge_property","text":"edge_property(g::PropertyGraphInterface, edge_idx::Integer) -> E\n\nGet the property associated with edge at the given edge index. Uses undirected edge indexing (1:num_edges).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.edge_property-Tuple{GraphInterface, Integer, Integer}","page":"API Reference","title":"GraphCore.edge_property","text":"edge_property(g::GraphInterface, u::Integer, v::Integer) -> E\n\nGet the property of the edge between u and v. Uses undirected edge indexing - for undirected graphs, this returns the same property regardless of direction.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.edge_weight","page":"API Reference","title":"GraphCore.edge_weight","text":"edge_weight(g::WeightedGraphInterface, directed_edge_idx::Integer) -> W\nedge_weight(g::WeightedGraphInterface, edge::Pair{<:Integer,<:Integer}) -> W\n\nGet the weight of the directed edge at the given directed edge index. Uses the directional indexing system for O(1) weight lookups. The second form allows querying by vertex pair, equivalent to edge_weight(g, find_edge_index(g, u, v)).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.edge_weights","page":"API Reference","title":"GraphCore.edge_weights","text":"edge_weights(g::WeightedGraphInterface, v::Integer) -> view or iterator\nedge_weights(g::WeightedGraphInterface) -> view or iterator\n\nReturn weights for edges from vertex v, or all edge weights.\n\nImportant: Weights are always directional, even for undirected graphs. This design allows asymmetric weights (e.g., different traversal costs in each direction).\n\nOrdering: The i-th weight corresponds to the i-th neighbor in neighbor_indices(g, v).\n\nExamples\n\n# Process neighbors with weights\nfor (neighbor, weight) in zip(neighbor_indices(g, v), edge_weights(g, v))\n    process_weighted_edge(v, neighbor, weight)\nend\n\n# More convenient combined iteration\nfor (neighbor, weight) in neighbor_weights(g, v)\n    process_weighted_edge(v, neighbor, weight)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.edges-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.edges","text":"edges(g::GraphInterface) -> Iterator\n\nReturn an iterator over all edges in the graph.\n\nFor directed graphs: yields (source, target) pairs for each directed edge\nFor undirected graphs: yields (u, v) pairs where u ≤ v (each edge once)\n\nExamples\n\nfor (u, v) in edges(g)\n    println(\"Edge from \", u, \" to \", v)\nend\n\n# Collect all edges\nedge_list = collect(edges(g))\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.find_directed_edge_index","page":"API Reference","title":"GraphCore.find_directed_edge_index","text":"find_directed_edge_index(g::GraphInterface, u::Integer, v::Integer) -> Int32\n\nFind the directed edge index for the directed edge from vertices u to v of the graph g. Returns 0 if no such edge exists.\n\nAlways directional: find_directed_edge_index(g, u, v) ≠ find_directed_edge_index(g, v, u)\n\nThis index is used for directed edge weight access and other directional properties, and for indexing external arrays of size num_directed_edges(g).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.find_edge_index","page":"API Reference","title":"GraphCore.find_edge_index","text":"find_edge_index(g::GraphInterface, u::Integer, v::Integer) -> Int32\n\nFind the undirected edge index for the edge between vertices u and v of the graph g. Returns 0 if no such edge exists.\n\nFor undirected graphs: find_edge_index(g, u, v) == find_edge_index(g, v, u) For directed graphs: only finds the edge in the specified direction (u -> v)\n\nThis index is used for edge property access (shared properties) and for indexing external arrays of size numedges(g). For directed graphs this is the same as `finddirectededgeindex(g, u, v)`\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.has_edge","page":"API Reference","title":"GraphCore.has_edge","text":"has_edge(g::GraphInterface, u::Integer, v::Integer) -> Bool\n\nTest whether there is a directed edge from vertex u to vertex v. For undirected graphs, has_edge(g, u, v) == has_edge(g, v, u).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.has_vertex","page":"API Reference","title":"GraphCore.has_vertex","text":"has_vertex(g::GraphInterface, v::Integer) -> Bool\n\nTest whether vertex v exists in the graph. Vertices are always integers in range 1:num_vertices(g).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.is_directed_graph","page":"API Reference","title":"GraphCore.is_directed_graph","text":"is_directed_graph(g::GraphInterface) -> Bool\n\nReturn true if the graph is directed, false if undirected. This affects the interpretation of edges and neighbor relationships.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.neighbor","page":"API Reference","title":"GraphCore.neighbor","text":"neighbor(g::GraphInterface, v::Integer, i::Integer) -> Int32\n\nReturn the i-th neighbor of vertex v in the graph g.\n\nDefault implementation provided - concrete types may override for efficiency.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.neighbor_indices","page":"API Reference","title":"GraphCore.neighbor_indices","text":"neighbor_indices(g::GraphInterface, v::Integer) -> view or iterator\n\nReturn an iterator over the neighbor indices of vertex v.\n\nFor directed graphs: Returns out-neighbors only For undirected graphs: Returns all neighbors\n\nPerformance guarantee: The returned iterator must support:\n\nFast iteration: for neighbor in neighbor_indices(g, v)\nLength query: length(neighbor_indices(g, v))\nIndex access: neighbor_indices(g, v)[i] (implementation dependent)\n\nMemory efficiency: Implementations should return views when possible to avoid allocation during neighbor traversal.\n\nExamples\n\n# Basic iteration\nfor neighbor in neighbor_indices(g, v)\n    process_neighbor(neighbor)\nend\n\n# Combined with indexing for edge properties\nfor (i, neighbor) in enumerate(neighbor_indices(g, v))\n    edge_idx = edge_index(g, v, i)        # O(1) edge index lookup\n    process_edge(neighbor, edge_idx)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.neighbor_weights","page":"API Reference","title":"GraphCore.neighbor_weights","text":"neighbor_weights(g::WeightedGraphInterface, v::Integer) -> iterator\n\nReturn an iterator over (neighbor_index, weight) pairs for vertex v. More efficient than separate iteration over neighbor_indices(g, v) and edge_weights(g, v).\n\nUsage:\n\n    for (neighbor, weight) in neighbor_weights(g, v)\n        # process neighbor and weight together\n    end\n\nSee also: neighbor_indices, edge_weights\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.num_directed_edges","page":"API Reference","title":"GraphCore.num_directed_edges","text":"num_directed_edges(g::GraphInterface) -> Int32\n\nReturn the total number of directed edges in the graph.\n\nFor undirected graphs: 2 * num_edges(g)\nFor directed graphs: actual count of directed edges\n\nThis count determines the size needed for directed edge property arrays.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.num_edges","page":"API Reference","title":"GraphCore.num_edges","text":"num_edges(g::GraphInterface) -> Int32\n\nReturn the number of edges in the graph. For undirected graphs, this counts each edge once. For directed graphs, this counts directed edges.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.num_vertices","page":"API Reference","title":"GraphCore.num_vertices","text":"num_vertices(g::GraphInterface) -> Int32\n\nReturn the number of vertices in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.remove_edge!","page":"API Reference","title":"GraphCore.remove_edge!","text":"remove_edge!(g::GraphInterface, u::Integer, v::Integer) -> Bool\n\nRemove the edge from u to v. Returns true if successful, false if edge doesn't exist. Only available for mutable graph types.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.remove_edge!-Tuple{AdjGraph, Integer, Integer}","page":"API Reference","title":"GraphCore.remove_edge!","text":"remove_edge!(g::AdjGraph, u::Integer, v::Integer) -> Bool\n\nRemove the edge from u to v from the graph. Returns true if successful, false if edge doesn't exist.\n\nPerformance\n\nTime Complexity: O(degree(u)) + O(degree(v)) for undirected\nSpace Complexity: O(1) - only removes data\nIndex Stability: ⚠️ MAY BREAK STABILITY - edge indices may be invalidated\n\nImplementation Details\n\nDirected graphs: Removes only u→v edge\nUndirected graphs: Removes both u→v and v→u internal representations\nSearch cost: Linear search in neighbor vectors to find edge\nArray operations: Uses deleteat! which may shift subsequent elements\n\nEdge Index Invalidation\n\ng = build_adj_graph([(1,2), (2,3), (1,3)]; directed=false)\n# Edge indices: (1,2)→1, (2,3)→2, (1,3)→3\n\n# External edge data\nedge_weights = [1.0, 2.0, 1.5]  # Indexed by edge indices\n\nremove_edge!(g, 2, 3)  # Remove edge with index 2\n# Now: remaining edges (1,2)→1, (1,3)→?\n# ⚠️ Edge index for (1,3) may have changed!\n# edge_weights[2] might now refer to wrong edge\n\nSafe Usage Patterns\n\n# ✅ SAFE: Use PropertyGraph for automatic edge property management\npg = PropertyGraph(g, vertex_props, edge_props)\nremove_edge!(pg, u, v)  # Edge properties automatically maintained\n\n# ✅ SAFE: Use edge-based operations instead of index-based\nfor (u, v) in edges(g)\n    weight = compute_weight_from_vertices(u, v)  # No index dependency\nend\n\n# ❌ UNSAFE: Assume edge indices remain stable across removals\nedge_data = Vector{Float64}(undef, num_edges(g))\nremove_edge!(g, u, v)\n# edge_data indices now potentially inconsistent!\n\nPerformance Considerations\n\nFor graphs with frequent edge removals, consider:\n\nBatch operations: Remove many edges at once, then rebuild external arrays\nAlternative storage: Use Dict{Tuple{Int,Int}, T} for edge properties\nConversion workflow: AdjGraph for building → CoreGraph for analysis\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.remove_edge!-Tuple{PropertyGraph, Integer, Integer}","page":"API Reference","title":"GraphCore.remove_edge!","text":"remove_edge!(g::PropertyGraph, u::Integer, v::Integer) -> Bool\n\nRemove the edge from u to v from the property graph. Returns true if successful, false if edge doesn't exist.\n\nOnly available when the base graph type supports remove_edge!. Property arrays are automatically maintained.\n\n⚠️  Index Invalidation Warning: Removing edges may invalidate edge indices and external arrays indexed by edge numbers.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.remove_edge!-Tuple{WeightedAdjGraph, Integer, Integer}","page":"API Reference","title":"GraphCore.remove_edge!","text":"remove_edge!(g::WeightedAdjGraph, u::Integer, v::Integer) -> Bool\n\nRemove the weighted edge from u to v from the graph. Returns true if successful, false if edge doesn't exist.\n\nPerformance\n\nTime Complexity: O(degree(u)) + O(degree(v)) for undirected\nSpace Complexity: O(1) - only removes data\nIndex Stability: ⚠️ MAY BREAK STABILITY - edge indices may be invalidated\n\nImplementation Details\n\nDirected graphs: Removes only u→v edge\nUndirected graphs: Removes both u→v and v→u internal representations\nSearch cost: Linear search in neighbor vectors to find edge\nArray operations: Uses deleteat! which may shift subsequent elements\n\nEdge Index Invalidation\n\ng = build_weighted_adj_graph([(1,2), (2,3), (1,3)]; directed=false)\n# Edge indices: (1,2)→1, (2,3)→2, (1,3)→3\n\n# External edge data\nedge_weights = [1.0, 2.0, 1.5]  # Indexed by edge indices\n\nremove_edge!(g, 2, 3)  # Remove edge with index 2\n# Now: remaining edges (1,2)→1, (1,3)→?\n# ⚠️ Edge index for (1,3) may have changed!\n# edge_weights[2] might now refer to wrong edge\n\nSafe Usage Patterns\n\n# ✅ SAFE: Use PropertyGraph for automatic edge property management\npg = PropertyGraph(g, vertex_props, edge_props)\nremove_edge!(pg, u, v)  # Edge properties automatically maintained\n\n# ✅ SAFE: Use edge-based operations instead of index-based\nfor (u, v) in edges(g)\n    weight = compute_weight_from_vertices(u, v)  # No index dependency\nend\n\n# ❌ UNSAFE: Assume edge indices remain stable across removals\nedge_data = Vector{Float64}(undef, num_edges(g))\nremove_edge!(g, u, v)\n# edge_data indices now potentially inconsistent!\n\nPerformance Considerations\n\nFor graphs with frequent edge removals, consider:\n\nBatch operations: Remove many edges at once, then rebuild external arrays\nAlternative storage: Use Dict{Tuple{Int,Int}, T} for edge properties\nConversion workflow: AdjGraph for building → CoreGraph for analysis\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.remove_edge!-Union{Tuple{D}, Tuple{CoreGraph{D}, Integer, Integer}} where D","page":"API Reference","title":"GraphCore.remove_edge!","text":"remove_edge!(g::CoreGraph, u::Integer, v::Integer) -> Bool\n\nRemove the edge from u to v from the graph. Returns true if successful, false if edge doesn't exist.\n\nEfficient Implementation: O(degree) operation that removes entries from CSR arrays and updates offsets.\n\nFor frequent mutations, consider using AdjGraph instead.\n\nExample\n\ng = build_core_graph([(1,2), (2,3), (1,3)]; directed=false)\nsuccess = remove_edge!(g, 1, 2)  # Returns true\n@assert !has_edge(g, 1, 2) && !has_edge(g, 2, 1)  # Both directions removed for undirected\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.remove_edge!-Union{Tuple{D}, Tuple{W}, Tuple{WeightedGraph{W, D}, Integer, Integer}} where {W, D}","page":"API Reference","title":"GraphCore.remove_edge!","text":"remove_edge!(g::WeightedGraph, u::Integer, v::Integer) -> Bool\n\nRemove the edge from u to v from the weighted graph. Returns true if successful, false if edge doesn't exist.\n\nEfficient Implementation: O(degree) operation that removes entries from CSR arrays and updates offsets.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.remove_vertex!","page":"API Reference","title":"GraphCore.remove_vertex!","text":"remove_vertex!(g::GraphInterface, v::Integer) -> Bool\n\nRemove vertex v and all its incident edges. Returns true if successful, false if vertex doesn't exist. Only available for mutable graph types.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.remove_vertex!-Tuple{AdjGraph, Integer}","page":"API Reference","title":"GraphCore.remove_vertex!","text":"remove_vertex!(g::AdjGraph, v::Integer) -> Bool\n\nRemove vertex v and all its incident edges from the graph. Returns true if successful, false if vertex doesn't exist.\n\nPerformance\n\nTime Complexity: O(V + incident_edges) - must update all vertex references\nSpace Complexity: O(1) - only removes data\nIndex Stability: ⚠️ BREAKS STABILITY - vertex indices > v are decremented\n\nImplementation Details\n\nEdge Removal: All incident edges are removed first (affects edge count)\nVertex Deletion: Vertex v is removed from adjacency structures\nIndex Update: All references to vertices > v are decremented by 1\nProperty Cleanup: For PropertyGraph, properties are also removed\n\nIndex Invalidation Warning\n\ng = build_adj_graph([(1,2), (2,3), (3,4)]; directed=false)\n# Before: vertices [1,2,3,4], vertex 3 has neighbors [2,4]\n\nsuccess = remove_vertex!(g, 2)  # Remove vertex 2\n# After: vertices [1,2,3], old vertex 3→new vertex 2, old vertex 4→new vertex 3\n# ⚠️ External arrays indexed by old vertex numbers are now INVALID!\n\n# External vertex properties become inconsistent:\nvertex_labels = [\"A\", \"B\", \"C\", \"D\"]  # Indexed by old vertex numbers\n# After removal: vertex_labels[3] no longer corresponds to current vertex 3!\n\nSafe Usage Patterns\n\n# ✅ SAFE: Use PropertyGraph for automatic property management\npg = PropertyGraph(g, vertex_labels, edge_labels)\nremove_vertex!(pg, 2)  # Properties automatically updated\n\n# ✅ SAFE: Rebuild external arrays after removal\nexternal_data = rebuild_after_removal(external_data, removed_vertex)\n\n# ❌ UNSAFE: Assume external arrays remain valid after removal\nremove_vertex!(g, v)\nold_label = vertex_labels[some_vertex]  # May be wrong!\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.remove_vertex!-Tuple{PropertyGraph, Integer}","page":"API Reference","title":"GraphCore.remove_vertex!","text":"remove_vertex!(g::PropertyGraph, v::Integer) -> Bool\n\nRemove vertex v and all its incident edges from the property graph. Returns true if successful, false if vertex doesn't exist.\n\nOnly available when the base graph type supports remove_vertex!. Property arrays are automatically maintained and indices updated.\n\n⚠️  Index Invalidation Warning: Removing vertices renumbers remaining vertices and invalidates external arrays indexed by vertex numbers.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.remove_vertex!-Tuple{WeightedAdjGraph, Integer}","page":"API Reference","title":"GraphCore.remove_vertex!","text":"remove_vertex!(g::WeightedAdjGraph, v::Integer) -> Bool\n\nRemove vertex v and all its incident edges from the weighted graph. Returns true if successful, false if vertex doesn't exist.\n\nPerformance\n\nTime Complexity: O(V + incident_edges) - must update all vertex references\nSpace Complexity: O(1) - only removes data\nIndex Stability: ⚠️ BREAKS STABILITY - vertex indices > v are decremented\n\nImplementation Details\n\nEdge Removal: All incident edges are removed first (affects edge count)\nVertex Deletion: Vertex v is removed from adjacency structures\nIndex Update: All references to vertices > v are decremented by 1\nProperty Cleanup: For PropertyGraph, properties are also removed\n\nIndex Invalidation Warning\n\ng = build_weighted_adj_graph([(1,2), (2,3), (3,4)]; directed=false)\n# Before: vertices [1,2,3,4], vertex 3 has neighbors [2,4]\n\nsuccess = remove_vertex!(g, 2)  # Remove vertex 2\n# After: vertices [1,2,3], old vertex 3→new vertex 2, old vertex 4→new vertex 3\n# ⚠️ External arrays indexed by old vertex numbers are now INVALID!\n\n# External vertex properties become inconsistent:\nvertex_labels = [\"A\", \"B\", \"C\", \"D\"]  # Indexed by old vertex numbers\n# After removal: vertex_labels[3] no longer corresponds to current vertex 3!\n\nSafe Usage Patterns\n\n# ✅ SAFE: Use PropertyGraph for automatic property management\npg = PropertyGraph(g, vertex_labels, edge_labels)\nremove_vertex!(pg, 2)  # Properties automatically updated\n\n# ✅ SAFE: Rebuild external arrays after removal\nexternal_data = rebuild_after_removal(external_data, removed_vertex)\n\n# ❌ UNSAFE: Assume external arrays remain valid after removal\nremove_vertex!(g, v)\nold_label = vertex_labels[some_vertex]  # May be wrong!\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.remove_vertex!-Union{Tuple{D}, Tuple{CoreGraph{D}, Integer}} where D","page":"API Reference","title":"GraphCore.remove_vertex!","text":"remove_vertex!(g::CoreGraph, v::Integer) -> Bool\n\nRemove vertex v and all its incident edges from the graph. Returns true if successful, false if vertex doesn't exist.\n\n⚠️  Performance Note: O(V + E) operation due to vertex renumbering requirement. ⚠️  Index Invalidation: Removes vertex v and renumbers vertices v+1, v+2, ... to v, v+1, ... This invalidates any external arrays indexed by vertex numbers.\n\nImplementation: More efficient than full reconstruction but still requires renumbering.\n\nExample\n\ng = build_core_graph([(1,2), (2,3), (1,3)]; directed=false)\nsuccess = remove_vertex!(g, 2)  # Returns true\n@assert num_vertices(g) == 2\n@assert has_edge(g, 1, 2)  # What was vertex 3 is now vertex 2\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.remove_vertex!-Union{Tuple{D}, Tuple{W}, Tuple{WeightedGraph{W, D}, Integer}} where {W, D}","page":"API Reference","title":"GraphCore.remove_vertex!","text":"remove_vertex!(g::WeightedGraph, v::Integer) -> Bool\n\nRemove vertex v and all its incident edges from the weighted graph. Returns true if successful, false if vertex doesn't exist.\n\n⚠️  Performance Note: O(V + E) operation due to vertex renumbering requirement. ⚠️  Index Invalidation: Removes vertex v and renumbers vertices v+1, v+2, ... to v, v+1, ... This invalidates any external arrays indexed by vertex numbers.\n\nImplementation: More efficient than full reconstruction but still requires renumbering.\n\nExample\n\ng = build_weighted_graph([(1,2,1.0), (2,3,2.0), (1,3,3.0)]; directed=false)\nsuccess = remove_vertex!(g, 2)  # Returns true\n@assert num_vertices(g) == 2\n@assert has_edge(g, 1, 2)  # What was vertex 3 is now vertex 2\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.set_edge_property!","page":"API Reference","title":"GraphCore.set_edge_property!","text":"set_edge_property!(g::PropertyGraphInterface{V,E,W}, edge_idx::Integer, prop::E) -> prop\n\nSet the property of edge at edge_idx to prop. Only available for mutable graph types.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.set_vertex_property!","page":"API Reference","title":"GraphCore.set_vertex_property!","text":"set_vertex_property!(g::PropertyGraphInterface{V,E,W}, v::Integer, prop::V) -> prop\n\nSet the property of vertex v to prop. Only available for mutable graph types.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.symmetrize_edges-Tuple{Any}","page":"API Reference","title":"GraphCore.symmetrize_edges","text":"symmetrize_edges(edges) -> Vector{Tuple{Int,Int}}\n\nConvert canonical format to symmetric format (both directions).\n\nArguments\n\nedges: Vector of (u,v) tuples in canonical format\n\nReturns\n\nVector of edges with both directions included\n\nFormat Conversion\n\nInput: [(1,2), (2,3)] (canonical)\nOutput: [(1,2), (2,1), (2,3), (3,2)] (both directions)\n\nUse when you need to create a directed graph from undirected edges, or when working with algorithms that expect symmetric adjacency representations.\n\nExample\n\ncanonical = [(1,2), (2,3), (1,3)]\nsymmetric = GraphCore.symmetrize_edges(canonical)\n# Result: [(1,2), (2,1), (2,3), (3,2), (1,3), (3,1)]\n\nNote\n\nSelf-loops (u,u) are not duplicated to avoid redundancy.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.symmetrize_edges-Union{Tuple{W}, Tuple{Any, AbstractVector{W}}} where W","page":"API Reference","title":"GraphCore.symmetrize_edges","text":"symmetrize_edges(edges, weights::AbstractVector{W}) -> (symmetric_edges, symmetric_weights)\n\nConvert canonical format to symmetric, duplicating weights for both directions.\n\nArguments\n\nedges: Vector of (u,v) tuples in canonical format\nweights: Vector of weights corresponding to edges\n\nReturns\n\nTuple of (symmetricedges, symmetricweights)\n\nBehavior\n\nEach weight is duplicated for both directions of the edge. This creates a symmetric weight matrix suitable for undirected graph algorithms.\n\nExample\n\nedges = [(1,2), (2,3)]\nweights = [1.5, 2.0]\nsymmetric_edges, symmetric_weights = GraphCore.symmetrize_edges(edges, weights)\n# Result:\n# edges = [(1,2), (2,1), (2,3), (3,2)]\n# weights = [1.5, 1.5, 2.0, 2.0]\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.to_adj_graph-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.to_adj_graph","text":"to_adj_graph(g::GraphInterface) -> AdjGraph\n\nConvert any GraphInterface graph to an AdjGraph. Preserves the directedness of the original graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.to_core_graph-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.to_core_graph","text":"to_core_graph(g::GraphInterface) -> CoreGraph\n\nConvert any GraphInterface implementation to a CoreGraph. Preserves the directedness of the original graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.to_weighted_graph-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W","page":"API Reference","title":"GraphCore.to_weighted_graph","text":"to_weighted_graph(g::WeightedGraphInterface{W}) -> WeightedGraph{W}\n\nConvert any WeightedGraphInterface to a WeightedGraph. Preserves the directedness and all weights of the original graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.vertex_properties","page":"API Reference","title":"GraphCore.vertex_properties","text":"vertex_properties(g::PropertyGraphInterface) -> iterator\n\nReturn an iterator over all vertex properties in order.\n\nExample\n\ng = build_property_graph(edges, [\"A\", \"B\", \"C\"], edge_props, 3)\nfor (i, prop) in enumerate(vertex_properties(g))\n    println(\"Vertex \", i, \" has property: \", prop)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.vertex_property","page":"API Reference","title":"GraphCore.vertex_property","text":"vertex_property(g::GraphInterface, v::Integer) -> V\n\nGet the property associated with vertex v.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.vertices-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.vertices","text":"vertices(g::GraphInterface) -> UnitRange{Int}\n\nReturn a range over all vertex indices.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graph-Construction","page":"API Reference","title":"Graph Construction","text":"","category":"section"},{"location":"api/#GraphCore.GraphConstruction.GraphBuilder","page":"API Reference","title":"GraphCore.GraphConstruction.GraphBuilder","text":"GraphBuilder{V,E,W}\n\nBuilder for constructing graphs incrementally. Optimized for fast additions during construction phase.\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.GraphConstruction.build_from_function-Tuple{Function, Function, Int64}","page":"API Reference","title":"GraphCore.GraphConstruction.build_from_function","text":"build_from_function(vertex_fn::Function, edge_fn::Function, nv::Int; directed=true)\n\nBuild a graph by calling vertexfn(i) for each vertex and edgefn(u,v) for potential edges.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_edge!-Tuple{GraphBuilder{Nothing, Nothing, Nothing}, Integer, Integer}","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(builder::GraphBuilder{Nothing,Nothing,Nothing}, u::Integer, v::Integer) -> Int32\n\nConvenience method for basic (unweighted, no properties) graph builders.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_edge!-Union{Tuple{W}, Tuple{E}, Tuple{V}, Tuple{GraphBuilder{V, E, W}, Integer, Integer}} where {V, E, W}","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(builder::GraphBuilder, u::Integer, v::Integer;\n          edge_property=nothing, weight=nothing) -> Int32\n\nAdd an edge with optional properties and weights using keyword arguments. Returns the edge index (1-based).\n\nExamples\n\n# Basic edge\nadd_edge!(builder, 1, 2)\n\n# Weighted edge\nadd_edge!(builder, 1, 2; weight=1.5)\n\n# Edge with property\nadd_edge!(builder, 1, 2; edge_property=\"connection\")\n\n# Both weight and property\nadd_edge!(builder, 1, 2; edge_property=\"highway\", weight=2.5)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_vertex!-Union{Tuple{GraphBuilder{V, E, W}}, Tuple{W}, Tuple{E}, Tuple{V}} where {V, E, W}","page":"API Reference","title":"GraphCore.add_vertex!","text":"add_vertex!(builder::GraphBuilder [, prop]) -> Int32\n\nAdd a vertex with optional property. Returns the vertex index. For non-property builders, prop should be omitted.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_graph-Union{Tuple{GraphBuilder{V, E, W}}, Tuple{W}, Tuple{E}, Tuple{V}} where {V, E, W}","page":"API Reference","title":"GraphCore.build_graph","text":"build_graph(builder::GraphBuilder{V,E,W}) -> GraphInterface\n\nConvert the builder to an optimized graph representation. Automatically chooses the most appropriate graph type among: CoreGraph, WeightedGraph{W}, PropertyGraph{G,V,E}.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_graph-Union{Tuple{G}, Tuple{GraphBuilder, Type{G}}} where G<:GraphInterface","page":"API Reference","title":"GraphCore.build_graph","text":"build_graph(builder::GraphBuilder, ::Type{G}) -> G\n\nConvert builder to a specific graph type G, where G can be one of: CoreGraph, WeightedGraph{W}, PropertyGraph, AdjGraph, WeightedAdjGraph{W}, PropertyAdjGraph. Note that the builder must be compatible with the target graph type. Also note that the order of the arguments, builder, graph type, is opposite to the usual order.\n\n\n\n\n\n","category":"method"},{"location":"api/#Conversions","page":"API Reference","title":"Conversions","text":"","category":"section"},{"location":"api/#GraphCore.Conversions.from_adjacency_matrix-Union{Tuple{W}, Tuple{G}, Tuple{Type{G}, AbstractMatrix{W}}} where {G<:GraphInterface, W<:Number}","page":"API Reference","title":"GraphCore.Conversions.from_adjacency_matrix","text":"from_adjacency_matrix(::Type{G}, adj_matrix::AbstractMatrix{W}) where {G<:GraphInterface,W} -> G\n\nConstruct a graph of appropriate type from an adjacency matrix.\n\nNon-zero entries in adj_matrix become edges with those weights\nIf directed is not specified, it is inferred from the symmetry of adj_matrix\n\nFor undirected graphs, adj_matrix should be symmetric.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Conversions.from_graphs_jl-Tuple{Graphs.AbstractGraph}","page":"API Reference","title":"GraphCore.Conversions.from_graphs_jl","text":"from_graphs_jl(g::Graphs.AbstractGraph; directed::Bool = Graphs.is_directed(g)) -> CoreGraph\n\nConvert a graph from the Graphs.jl ecosystem to a CoreGraph.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Conversions.from_weighted_graphs_jl-Union{Tuple{W}, Tuple{Graphs.AbstractGraph, AbstractVector{W}}} where W","page":"API Reference","title":"GraphCore.Conversions.from_weighted_graphs_jl","text":"from_weighted_graphs_jl(g::Graphs.AbstractGraph, weights::AbstractVector{W};\n                       directed::Bool = Graphs.is_directed(g)) -> WeightedGraph{W}\n\nConvert a weighted graph from the Graphs.jl ecosystem to a WeightedGraph.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Conversions.to_adjacency_matrix-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.Conversions.to_adjacency_matrix","text":"to_adjacency_matrix(g::GraphInterface) -> SparseMatrixCSC{W} where {W}\n\nConvert a graph to its adjacency matrix representation.\n\nFor directed graphs, the matrix is not required to be symmetric.\nFor undirected graphs, the matrix will be symmetric if the weights are.\nFor unweighted graphs, entries are 1 where edges exist.\nFor weighted graphs, entries are the edge weights (which are not necessarily symmetric even for undirected graphs).\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Conversions.to_graphs_jl-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.Conversions.to_graphs_jl","text":"to_graphs_jl(g::GraphInterface) -> Graphs.SimpleGraph or Graphs.SimpleDiGraph\n\nConvert a property graph to a Graphs.jl graph (losing properties and weights). Returns SimpleGraph for undirected graphs, SimpleDiGraph for directed graphs.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Conversions.to_weighted_graphs_jl-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W<:Number","page":"API Reference","title":"GraphCore.Conversions.to_weighted_graphs_jl","text":"to_weighted_graphs_jl(g::GraphInterface{V,E,W}) where {V,E,W} ->\n    SimpleWeightedGraphs.SimpleWeightedGraph or SimpleWeightedGraphs.SimpleWeightedDiGraph\n\nConvert a WeightedGraphInterface graph to a weighted SimpleWeightedGraphs.jl graph (preserving weights, losing other properties). Requires SimpleWeightedGraphs.jl package.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lattices","page":"API Reference","title":"Lattices","text":"","category":"section"},{"location":"api/#GraphCore.Lattices.HypercubicLattice","page":"API Reference","title":"GraphCore.Lattices.HypercubicLattice","text":"HypercubicLattice{D,T} <: GraphInterface\n\nA D-dimensional hypercubic lattice graph with side length of type T.\n\nType Parameters\n\nD::Int: Dimension of the lattice (1D=line, 2D=grid, 3D=cube, etc.)\nT<:Integer: Type for lattice size/coordinates\n\nStorage\n\nUses mathematical coordinate mapping instead of explicit edge storage. Memory usage: O(1) regardless of lattice size!\n\nCoordinate System\n\nVertices are numbered 1 to prod(sizes)\nCoordinates are 0-indexed: (0,0,...,0) to (size₁-1, size₂-1, ..., sizeD-1)\nPeriodic boundary conditions optional\n\nExamples\n\n# 2D grid: 10×10\nlattice_2d = HypercubicLattice{2,Int}((10, 10))\n\n# 3D cube: 5×5×5\nlattice_3d = HypercubicLattice{3,Int}((5, 5, 5))\n\n# 1D chain: 100 vertices\nlattice_1d = HypercubicLattice{1,Int}((100,))\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.Lattices.coord_to_vertex-Union{Tuple{T}, Tuple{D}, Tuple{HypercubicLattice{D, T}, NTuple{D, T}}} where {D, T}","page":"API Reference","title":"GraphCore.Lattices.coord_to_vertex","text":"coord_to_vertex(g::HypercubicLattice{D,T}, coord::NTuple{D,T}) -> Int32\n\nConvert coordinates to vertex index using optimized arithmetic. Specialized for common dimensions with loop unrolling.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.lattice_dimension-Union{Tuple{HypercubicLattice{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"API Reference","title":"GraphCore.Lattices.lattice_dimension","text":"Get the dimensions of the lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.lattice_distance-Union{Tuple{T}, Tuple{D}, Tuple{HypercubicLattice{D, T}, Integer, Integer}} where {D, T}","page":"API Reference","title":"GraphCore.Lattices.lattice_distance","text":"lattice_distance(g::HypercubicLattice, u::Integer, v::Integer) -> Float64\n\nCompute the Manhattan distance between two vertices on the lattice. Accounts for periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.lattice_neighbors-Tuple{HypercubicLattice, Integer}","page":"API Reference","title":"GraphCore.Lattices.lattice_neighbors","text":"lattice_neighbors(g::HypercubicLattice, v::Integer) -> Vector{Int32}\n\nAlias for neighbor_indices with better name for lattice context.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.lattice_size-Tuple{HypercubicLattice}","page":"API Reference","title":"GraphCore.Lattices.lattice_size","text":"Get the size tuple of the lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.vertex_to_coord-Union{Tuple{T}, Tuple{D}, Tuple{HypercubicLattice{D, T}, Integer}} where {D, T}","page":"API Reference","title":"GraphCore.Lattices.vertex_to_coord","text":"vertex_to_coord(g::HypercubicLattice{D,T}, v::Integer) -> NTuple{D,T}\n\nConvert vertex index to coordinates using optimized integer arithmetic. Fully inlined and branch-free for maximum performance.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.PowerOfTwoLattice","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.PowerOfTwoLattice","text":"PowerOfTwoLattice{D} <: GraphInterface\n\nUltra-fast D-dimensional hypercubic lattice where all sizes are powers of 2. Uses bit operations for coordinate conversion and neighbor lookup.\n\nRestrictions\n\nD ≤ 5 (keeps neighbor tuples reasonable)\nAll sizes must be powers of 2: 2, 4, 8, 16, 32, 64, 128, ...\nPeriodic boundary conditions (makes bit operations clean)\n\nType Parameters\n\nD::Int: Dimension (1 ≤ D ≤ 5)\n\nExamples\n\n# 2D: 16×32 grid (2^4 × 2^5)\ng2d = P2Grid2D(4, 5)  # log₂ sizes\n\n# 3D: 8×8×16 cube (2^3 × 2^3 × 2^4)\ng3d = P2Grid3D(3, 3, 4)\n\n# 1D: 64-element chain (2^6)\ng1d = P2Chain1D(6)\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.PowerOfTwoLattices.P2Chain1D-Tuple{Integer}","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.P2Chain1D","text":"1D chain: size = 2^log_size\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.P2Grid2D-Tuple{Integer, Integer}","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.P2Grid2D","text":"2D grid: sizes = 2^logwidth × 2^logheight\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.P2Grid3D-Tuple{Integer, Integer, Integer}","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.P2Grid3D","text":"3D cube: sizes = 2^logwidth × 2^logheight × 2^log_depth\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.lattice_dimension-Union{Tuple{PowerOfTwoLattice{D}}, Tuple{D}} where D","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.lattice_dimension","text":"Get lattice dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.lattice_size-Tuple{PowerOfTwoLattice}","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.lattice_size","text":"Get actual sizes.\n\n\n\n\n\n","category":"method"},{"location":"design/#Design-Philosophy-and-Architecture","page":"Design Philosophy","title":"Design Philosophy & Architecture","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"This page covers the design principles, architecture, and performance characteristics of GraphCore.jl.","category":"page"},{"location":"design/#Design-Philosophy","page":"Design Philosophy","title":"Design Philosophy","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"GraphCore.jl is designed around three key principles:","category":"page"},{"location":"design/#**Performance-Oriented-Design**","page":"Design Philosophy","title":"Performance-Oriented Design","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"CSR Storage: Compressed Sparse Row format for cache-efficient traversal\nType Specialization: Parametric types enable compiler optimizations and zero-cost abstractions\nEfficient Indexing: Direct O(1) access patterns with Int32 indexing for memory efficiency\nMinimal Overhead: Compact memory layouts optimized for common graph operations","category":"page"},{"location":"design/#**Flexible-Storage-Options**","page":"Design Philosophy","title":"Flexible Storage Options","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Multiple Representations: CSR format (CoreGraph) for static analysis, adjacency lists (AdjGraph) for dynamic operations\nUnified Interface: All graph types implement the same GraphInterface for consistent usage\nProperty Integration: Built-in support for type-safe vertex and edge properties\nExternal Array Support: Stable indexing schemes for user-managed data arrays","category":"page"},{"location":"design/#**Type-Safety-and-Reliability**","page":"Design Philosophy","title":"Type Safety and Reliability","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Compile-Time Checking: Parametric types catch common errors during compilation\nClear Data Ownership: Explicit separation between graph structure, weights, and properties  \nStable Indexing: Consistent edge/vertex indices for reliable external array management\nComprehensive Validation: Input checking and well-defined method contracts","category":"page"},{"location":"design/#Architecture-Overview","page":"Design Philosophy","title":"Architecture Overview","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"GraphCore.jl\n├── GraphInterface      # Abstract interface definition\n├── CoreGraph           # CSR-based graphs (static, high-performance)\n├── AdjGraph            # Adjacency list graphs (dynamic, mutable)\n└── GraphConstruction   # Builder patterns for graph construction","category":"page"},{"location":"design/#Performance-Characteristics","page":"Design Philosophy","title":"Performance Characteristics","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Operation CoreGraph WeightedGraph AdjGraph PropertyGraph PropertyAdjGraph\nNeighbor Access O(1), ~2ns O(1), ~2ns O(1), ~2ns O(1), ~2ns O(1), ~2ns\nEdge Lookup O(degree), ~3ns O(degree), ~3ns O(degree), ~3ns O(degree), ~3ns O(degree), ~3ns\nBounds Checking ✅ @boundscheck ✅ @boundscheck ✅ @boundscheck ✅ @boundscheck ✅ @boundscheck\n@inbounds Safe ✅ Performance ✅ Performance ✅ Performance ✅ Performance ✅ Performance\nAdd Edge ✅ Efficient ✅ Efficient O(1) ✅ Efficient* O(1)\nRemove Edge ✅ Efficient ✅ Efficient O(degree) ✅ Efficient* O(degree)\nAdd Vertex ✅ O(1) ✅ O(1) O(1) ✅ O(1)* O(1)\nRemove Vertex ✅ Efficient ✅ Efficient O(V+E) ✅ Efficient* O(V+E)\nInput Validation ✅ Comprehensive ✅ Comprehensive ✅ Basic ✅ Comprehensive ✅ Basic\nMemory Overhead Minimal +weights +pointers +properties +properties+pointers\nCache Efficiency Excellent Excellent Good Excellent** Good**","category":"page"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"*PropertyGraph inherits mutation performance from its underlying graph type. **PropertyGraph inherits the performance characteristics of its underlying graph type.","category":"page"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Performance notes:","category":"page"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Timings are median benchmarks on typical graphs (Petersen graph: 10 vertices, 15 edges)\nAll operations benefit from @inbounds optimizations in performance-critical loops\nBounds checking can be disabled globally with --check-bounds=no for maximum speed\nEdge lookup time depends on vertex degree but benefits from cache-efficient CSR layout","category":"page"},{"location":"design/#Design-Decisions-and-Trade-offs","page":"Design Philosophy","title":"Design Decisions & Trade-offs","text":"","category":"section"},{"location":"design/#Why-Julia-Idiomatic-Bounds-Checking?","page":"Design Philosophy","title":"Why Julia-Idiomatic Bounds Checking?","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Safety First: All vertex/edge access is safe by default with clear error messages\nPerformance When Needed: @inbounds provides zero-cost optimization for validated access\nFamiliar Pattern: Follows Julia's array indexing conventions that users already know\nTrade-off: Small overhead in tight loops, but eliminates silent corruption bugs","category":"page"},{"location":"design/#Why-CSR-for-CoreGraph?","page":"Design Philosophy","title":"Why CSR for CoreGraph?","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Cache Efficiency: Neighbors stored contiguously in memory\nSpace Efficiency: No pointer overhead compared to adjacency lists  \nIndex Stability: External arrays remain valid during graph analysis\nEfficient Mutations: Direct array manipulation preserves CSR benefits\nTrade-off: More complex mutation algorithms, but maintains performance characteristics","category":"page"},{"location":"design/#Why-Dual-Indexing?","page":"Design Philosophy","title":"Why Dual Indexing?","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Flexibility: Support both shared and directional edge properties\nPerformance: O(1) access during iteration via edge_index(g, v, i)\nCorrectness: Clear separation between undirected and directed semantics\nTrade-off: Slightly more complex API, but with clear documentation","category":"page"},{"location":"design/#Why-Multiple-Graph-Types?","page":"Design Philosophy","title":"Why Multiple Graph Types?","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Specialization: Each type optimized for its use case\nComposability: PropertyGraph wraps any base type\nMigration Path: Easy conversion between representations\nTrade-off: More types to learn, but unified interface","category":"page"},{"location":"design/#When-to-Use-Which-Graph-Type","page":"Design Philosophy","title":"When to Use Which Graph Type","text":"","category":"section"},{"location":"design/#**CoreGraph{D}**-Choose-When:","page":"Design Philosophy","title":"CoreGraph{D} - Choose When:","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"✅ You need maximum performance for queries and analysis\n✅ Graph structure is mostly static after initial construction  \n✅ Memory efficiency is important\n✅ You'll be doing many neighbor traversals","category":"page"},{"location":"design/#**WeightedGraph{W,D}**-Choose-When:","page":"Design Philosophy","title":"WeightedGraph{W,D} - Choose When:","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"✅ You need type-safe edge weights\n✅ Performance is critical (same as CoreGraph)\n✅ You want built-in weight management\n✅ You need directional weights in undirected graphs","category":"page"},{"location":"design/#**AdjGraph{D}**-Choose-When:","page":"Design Philosophy","title":"AdjGraph{D} - Choose When:","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"✅ You'll be frequently adding/removing edges\n✅ Graph construction is dynamic and unpredictable\n✅ Flexibility is more important than memory efficiency","category":"page"},{"location":"design/#**PropertyGraph{G,V,E}**-Choose-When:","page":"Design Philosophy","title":"PropertyGraph{G,V,E} - Choose When:","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"✅ You need to attach custom data to vertices/edges\n✅ Type safety for properties is important\n✅ You want to compose with any underlying graph type\n✅ Zero-overhead property access is required","category":"page"},{"location":"design/#Performance-Best-Practices","page":"Design Philosophy","title":"Performance Best Practices","text":"","category":"section"},{"location":"design/#**When-to-Use-@inbounds**","page":"Design Philosophy","title":"When to Use @inbounds","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Use @inbounds in performance-critical inner loops where you can guarantee safety:","category":"page"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"# ✅ SAFE: After explicit validation\nfunction safe_fast_algorithm(g, valid_vertices)\n    # Pre-validate all vertices are in bounds\n    @assert all(has_vertex(g, v) for v in valid_vertices)\n    \n    for v in valid_vertices\n        # Safe to use @inbounds - we validated vertices above\n        neighbors = @inbounds neighbor_indices(g, v)\n        for (i, neighbor) in enumerate(neighbors)\n            edge_idx = @inbounds directed_edge_index(g, v, i)\n            # Fast operations...\n        end\n    end\nend\n\n# ❌ UNSAFE: Don't use @inbounds on user input\nfunction unsafe_example(g, user_vertex)\n    # DON'T DO THIS - user_vertex might be out of bounds!\n    neighbors = @inbounds neighbor_indices(g, user_vertex)  # Potential crash\nend","category":"page"},{"location":"design/#**Bounds-Checking-Control**","page":"Design Philosophy","title":"Bounds Checking Control","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"# For maximum performance in production (after thorough testing):\n# julia --check-bounds=no script.jl\n\n# For development and debugging (default):\n# julia --check-bounds=yes script.jl","category":"page"},{"location":"design/#**Memory-and-Cache-Optimization**","page":"Design Philosophy","title":"Memory and Cache Optimization","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"# ✅ GOOD: Use CoreGraph for analysis workloads\nanalysis_graph = build_core_graph(edges; directed=false)\n\n# ✅ GOOD: Batch operations for cache efficiency\nfunction efficient_traversal(g)\n    for v in vertices(g)\n        neighbors = neighbor_indices(g, v)  # O(1) view, cache-friendly\n        for neighbor in neighbors\n            # Process all neighbors together\n        end\n    end\nend","category":"page"},{"location":"docindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"docindex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"#GraphCore.jl-User-Guide","page":"Home","title":"GraphCore.jl User Guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A high-performance, type-safe graph library for Julia with a focus on efficiency, flexibility, and ease of use.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GraphCore.jl provides multiple specialized graph data structures optimized for different use cases - from static analysis with CoreGraph's compressed storage to dynamic construction with AdjGraph's adjacency lists. All graph types support efficient mutations, type-safe properties, and seamless integration with the Graphs.jl ecosystem, allowing you to use existing algorithms while benefiting from GraphCore's performance optimizations.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using GraphCore\n\n# Create your first graph\nedges = [(1,2), (2,3), (1,3)]\ng = build_core_graph(edges; directed=false)\n\n# Query the graph\nprintln(\"Graph has $(num_vertices(g)) vertices and $(num_edges(g)) edges\")\nprintln(\"Neighbors of vertex 1: $(collect(neighbor_indices(g, 1)))\")","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"GraphCore\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For optional features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# For benchmarking examples\nPkg.add(\"BenchmarkTools\")\n\n# For plotting examples  \nPkg.add([\"Plots\", \"GraphRecipes\"])","category":"page"},{"location":"#Graph-Types-Overview","page":"Home","title":"Graph Types Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphCore provides four main graph types, each optimized for different use cases:","category":"page"},{"location":"#**CoreGraph**-High-Performance-Static-Analysis","page":"Home","title":"CoreGraph - High-Performance Static Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Best for: Fast queries, analysis algorithms, memory efficiency\ng = build_core_graph([(1,2), (2,3), (1,3)]; directed=false)\n\n# Lightning-fast neighbor access\nfor neighbor in neighbor_indices(g, 1)\n    println(\"Neighbor: $neighbor\")\nend\n\n# Efficient mutations\nadd_edge!(g, 1, 4)\nadd_vertex!(g)","category":"page"},{"location":"#**WeightedGraph**-Graphs-with-Edge-Weights","page":"Home","title":"WeightedGraph - Graphs with Edge Weights","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Best for: Algorithms needing edge weights (shortest paths, MST, etc.)\nedges = [(1,2), (2,3), (1,3)]\nweights = [1.0, 2.5, 1.2]\nwg = build_weighted_graph(edges, weights; directed=false)\n\n# Access weights efficiently\nfor (neighbor, weight) in neighbor_weights(wg, 1)\n    println(\"Edge to $neighbor has weight $weight\")\nend\n\n# Add weighted edges\nadd_edge!(wg, 1, 4, 3.7)","category":"page"},{"location":"#**PropertyGraph**-Graphs-with-Custom-Data","page":"Home","title":"PropertyGraph - Graphs with Custom Data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Best for: Attaching custom data to vertices and edges\nvertices = [\"Alice\", \"Bob\", \"Charlie\"]\nedges = [(1,2), (2,3), (1,3)]\nedge_types = [\"friend\", \"colleague\", \"family\"]\n\npg = build_property_graph(edges, vertices, edge_types; directed=false)\n\n# Access properties\nprintln(\"Vertex 1 is: $(vertex_property(pg, 1))\")\nprintln(\"Edge (1,2) type: $(edge_property(pg, 1, 2))\")","category":"page"},{"location":"#**AdjGraph**-Dynamic-Modification","page":"Home","title":"AdjGraph - Dynamic Modification","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Best for: Frequent edge additions/removals during construction\ng = build_adj_graph([(1,2)]; directed=false)\n\n# Very fast mutations\nadd_edge!(g, 2, 3)  # O(1)\nadd_edge!(g, 3, 4)  # O(1)\nremove_edge!(g, 1, 2)  # O(degree)","category":"page"},{"location":"#Common-Workflows","page":"Home","title":"Common Workflows","text":"","category":"section"},{"location":"#Building-Graphs","page":"Home","title":"Building Graphs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"From edge lists:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Simple unweighted graph\nedges = [(1,2), (2,3), (3,4), (4,1)]\ng = build_core_graph(edges; directed=true)\n\n# With weights\nweights = [1.0, 2.0, 1.5, 0.8]\nwg = build_weighted_graph(edges, weights; directed=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Incrementally with GraphBuilder:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GraphCore.GraphConstruction\n\nbuilder = WeightedGraphBuilder(Float64; directed=false)\nadd_edge!(builder, 1, 2; weight=1.5)\nadd_edge!(builder, 2, 3; weight=2.0)\nadd_edge!(builder, 1, 3; weight=1.0)\n\n# Convert to your preferred graph type\ncore_g = build_graph(builder, CoreGraph)      # For analysis\nadj_g = build_graph(builder, AdjGraph)        # For further modifications","category":"page"},{"location":"","page":"Home","title":"Home","text":"From other graph libraries:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GraphCore.Conversions\nusing Graphs\n\n# From Graphs.jl\nsimple_g = SimpleGraph(5)\nadd_edge!(simple_g, 1, 2)\nour_g = from_graphs_jl(simple_g)\n\n# To Graphs.jl  \ngraphs_g = to_graphs_jl(our_g)","category":"page"},{"location":"#Graph-Analysis","page":"Home","title":"Graph Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Basic queries:","category":"page"},{"location":"","page":"Home","title":"Home","text":"g = build_core_graph([(1,2), (2,3), (1,3)]; directed=false)\n\n# Graph properties\nprintln(\"Vertices: $(num_vertices(g))\")\nprintln(\"Edges: $(num_edges(g))\")\nprintln(\"Directed: $(is_directed(g))\")\n\n# Vertex queries\nprintln(\"Degree of vertex 1: $(degree(g, 1))\")\nprintln(\"Neighbors: $(collect(neighbor_indices(g, 1)))\")\n\n# Edge queries  \nprintln(\"Has edge (1,2): $(has_edge(g, 1, 2))\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Iteration patterns:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Iterate over all vertices\nfor v in vertices(g)\n    println(\"Processing vertex $v\")\nend\n\n# Iterate over all edges\nfor (u, v) in edges(g)\n    println(\"Edge: $u → $v\")\nend\n\n# Iterate over neighbors efficiently\nfor v in vertices(g)\n    for neighbor in neighbor_indices(g, v)\n        println(\"$v is connected to $neighbor\")\n    end\nend","category":"page"},{"location":"#Graph-Modification","page":"Home","title":"Graph Modification","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Adding elements:","category":"page"},{"location":"","page":"Home","title":"Home","text":"g = build_core_graph([(1,2)]; directed=false)\n\n# Add vertices and edges\nnew_vertex = add_vertex!(g)  # Returns vertex index\nadd_edge!(g, 1, new_vertex)\nadd_edge!(g, 2, new_vertex)\n\n# For weighted graphs\nwg = build_weighted_graph([(1,2)], [1.0]; directed=false)\nadd_edge!(wg, 1, 3, 2.5)  # vertex 3, weight 2.5","category":"page"},{"location":"","page":"Home","title":"Home","text":"Removing elements:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Remove edges\nremove_edge!(g, 1, 2)\n\n# Remove vertices (removes all connected edges)\nremove_vertex!(g, 3)","category":"page"},{"location":"#Converting-Between-Types","page":"Home","title":"Converting Between Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Easy conversions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Start with one type\nadj_g = build_adj_graph([(1,2), (2,3)]; directed=false)\n\n# Convert as needed\ncore_g = CoreGraph(adj_g)           # For fast analysis\nweighted_g = WeightedGraph(core_g)  # Add weight support\nproperty_g = PropertyGraph(core_g, [\"A\", \"B\", \"C\"], [\"edge1\", \"edge2\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Type-safe conversions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"directed_g = build_core_graph([(1,2)]; directed=true)\n\n# This prevents mistakes:\n# undirected_g = CoreGraph{false}(directed_g)  # Would throw error!\n\n# Explicit conversion when you know what you're doing:\nundirected_g = CoreGraph{false}(edges(directed_g))  # OK","category":"page"},{"location":"#Working-with-Properties","page":"Home","title":"Working with Properties","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Vertex properties:","category":"page"},{"location":"","page":"Home","title":"Home","text":"names = [\"Alice\", \"Bob\", \"Charlie\"]\ng = build_property_graph([(1,2), (2,3)], names, String[]; directed=false)\n\n# Access properties\nprintln(vertex_property(g, 1))  # \"Alice\"\n\n# Modify properties\nset_vertex_property!(g, 1, \"Alice Smith\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Edge properties:","category":"page"},{"location":"","page":"Home","title":"Home","text":"edges = [(1,2), (2,3)]\nedge_labels = [\"friend\", \"colleague\"]\ng = build_property_graph(edges, String[], edge_labels; directed=false)\n\n# Access edge properties\nprintln(edge_property(g, 1, 2))  # \"friend\"","category":"page"},{"location":"#Integration-with-Graphs.jl","page":"Home","title":"Integration with Graphs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphCore graphs work seamlessly with the Graphs.jl ecosystem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Graphs, GraphCore\n\ng = build_core_graph([(1,2), (2,3), (1,3)]; directed=false)\n\n# Standard Graphs.jl functions work\nprintln(\"Vertices: $(nv(g))\")\nprintln(\"Edges: $(ne(g))\")\nprintln(\"Neighbors of 1: $(outneighbors(g, 1))\")\n\n# Algorithms work too\nusing SimpleWeightedGraphs\nwg = build_weighted_graph([(1,2), (2,3)], [1.0, 2.0]; directed=false)\npaths = dijkstra_shortest_paths(wg, 1)","category":"page"},{"location":"#Safety-and-Performance","page":"Home","title":"Safety and Performance","text":"","category":"section"},{"location":"#Bounds-Checking","page":"Home","title":"Bounds Checking","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphCore provides safe access by default with optimizations available:","category":"page"},{"location":"","page":"Home","title":"Home","text":"g = build_core_graph([(1,2), (2,3)]; directed=false)\n\n# Safe by default\ntry\n    neighbor_indices(g, 10)  # BoundsError: vertex 10 out of bounds\ncatch e\n    println(\"Caught: $e\")\nend\n\n# Optimize when you know access is safe\nfunction fast_algorithm(g, valid_vertices)\n    for v in valid_vertices\n        # @inbounds skips bounds checking for speed\n        neighbors = @inbounds neighbor_indices(g, v)\n        # ... fast inner loop\n    end\nend","category":"page"},{"location":"#Edge-Iterator-Information","page":"Home","title":"Edge Iterator Information","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphCore provides helpful edge iterator displays:","category":"page"},{"location":"","page":"Home","title":"Home","text":"g = build_core_graph([(1,2), (2,3), (1,3)]; directed=false)\n\nprintln(edges(g))\n# Output: \"EdgeIterator over 3 edges from CoreGraph (undirected): (1, 2), (1, 3), (2, 3)\"\n\n# Shows: edge count, graph type, directedness, and preview","category":"page"},{"location":"#Next-Steps","page":"Home","title":"Next Steps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Design Philosophy - Architecture and performance details  \nAPI Reference - Complete function documentation\nExamples - Check the examples/ directory for:\nPerformance benchmarks\nAlgorithm implementations\nPlotting examples\nGraphs.jl integration","category":"page"},{"location":"#Need-Help?","page":"Home","title":"Need Help?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check the examples in the examples/ directory\nLook at the comprehensive test suite in test/\nSee the API reference for detailed function documentation","category":"page"}]
}
