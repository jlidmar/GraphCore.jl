var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Core-Types-and-Functions","page":"API Reference","title":"Core Types and Functions","text":"","category":"section"},{"location":"api/#GraphCore.AdjGraph","page":"API Reference","title":"GraphCore.AdjGraph","text":"AdjGraph{D} <: GraphInterface\n\nDynamic graph using adjacency lists (Vector{Vector{Int32}}) for neighbor storage. Optimized for structural mutations with reasonable query performance.\n\nType Parameters\n\nD::Bool: Directedness flag (true = directed, false = undirected)\n\nFields (Internal - Access via interface methods)\n\nneighbors::Vector{Vector{Int32}}: Per-vertex neighbor lists\nneighbor_to_edge::Vector{Vector{Int32}}: Maps neighbor positions to edge indices (undirected only)\nnum_edges::Int32: Number of (undirected) edges\n\nConstruction\n\nUse build_adj_graph() or build_graph(AdjGraph, ...) for safe construction:\n\n# Basic construction\nedges = [(1,2), (2,3), (1,3)]\ng = build_adj_graph(edges; directed=false)\n\n# Direct type construction with mutation\ng = build_graph(AdjGraph, edges; directed=false)\nadd_edge!(g, 4, 1)  # Efficient dynamic modification\n\nMemory Layout Example\n\nFor graph with edges [(1,2), (2,3), (1,3)], undirected:\n\nneighbors = [[2,3], [1,3], [1,2]]           # Vertex 1: neighbors 2,3; Vertex 2: neighbors 1,3, etc.\nneighbor_to_edge = [[1,3], [1,2], [3,2]]    # Maps: v1's neighbor 2→edge 1, v1's neighbor 3→edge 3, etc.\n\nPerformance Notes\n\nBest for: Dynamic graphs with frequent add/remove operations\nMutations: O(1) additions, O(degree) removals\nMemory: ~16-24 bytes per directed edge (vector overhead + pointers)\nCache: Good for sparse graphs, less optimal for dense graphs\n\nMutation Support\n\n# Efficient dynamic operations\nnew_vertex = add_vertex!(g)           # O(1) - just adds empty vectors\nedge_idx = add_edge!(g, u, v)         # O(1) amortized - vector push\nsuccess = remove_edge!(g, u, v)       # O(degree) - find and remove\nsuccess = remove_vertex!(g, v)        # O(V + incident edges) - updates all references\n\n# ⚠️ Warning: Removals may invalidate edge indices\n# External arrays indexed by edges will become inconsistent\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.AdjGraph-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.AdjGraph","text":"AdjGraph(g::GraphInterface) -> AdjGraph\n\nConvert any GraphInterface implementation to an AdjGraph using constructor syntax. This is an idiomatic Julia alternative to to_adj_graph(g).\n\nExamples\n\n# Constructor style (idiomatic)\nadj_g = AdjGraph(core_graph)\n\n# Equivalent to conversion function\nadj_g = to_adj_graph(core_graph)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.AdjGraph-Union{Tuple{GraphInterface}, Tuple{D}} where D","page":"API Reference","title":"GraphCore.AdjGraph","text":"AdjGraph{D}(g::GraphInterface) -> AdjGraph{D}\n\nConvert any GraphInterface to an AdjGraph with explicit directedness type parameter. The source graph must have the same directedness as specified by the type parameter.\n\nExamples\n\n# Type-safe conversions (will succeed)\ndirected_adj = AdjGraph{true}(directed_core_graph)\nundirected_adj = AdjGraph{false}(undirected_core_graph)\n\n# Type mismatch (will throw AssertionError)\n# AdjGraph{true}(undirected_graph)  # ERROR!\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.CoreGraph","page":"API Reference","title":"GraphCore.CoreGraph","text":"CoreGraph{D} <: GraphInterface\n\nHigh-performance graph using Compressed Sparse Row (CSR) storage format.\n\nType Parameters\n\nD::Bool: Directedness flag (true = directed, false = undirected)\n\nFields (Internal - Access via interface methods)\n\nvertex_offsets::Vector{Int32}: CSR row pointers (length = nv + 1)\nneighbors::Vector{Int32}: Flattened neighbor lists\nneighbor_to_edge::Vector{Int32}: Maps neighbor positions to undirected edge indices (undirected only)\nnum_edges::Int32: Number of (undirected) edges\n\nConstruction\n\nUse build_core_graph() or build_graph(CoreGraph, ...) for safe construction:\n\n# Basic construction\nedges = [(1,2), (2,3), (1,3)]\ng = build_core_graph(edges; directed=false)\n\n# With validation disabled (faster, but unsafe)\ng = build_graph(CoreGraph, edges; directed=false, validate=false)\n\nMemory Layout Example\n\nFor graph with edges [(1,2), (2,3), (1,3)], undirected:\n\nvertex_offsets = [1, 3, 6, 8]       # Vertex 1: neighbors[1:2], Vertex 2: neighbors[3:5], etc.\nneighbors = [2, 3, 1, 3, 1, 2]      # Flattened: [neighbors(1), neighbors(2), neighbors(3)]\nneighbor_to_edge = [1, 3, 1, 2, 3, 2] # Maps each neighbor to its edge index\n\nPerformance Notes\n\nBest for: Static graphs with frequent neighbor access\nAvoid for: Graphs requiring frequent structural modifications\nMemory: ~12-16 bytes per directed edge (depending on architecture)\nCache: Excellent locality for neighbor iteration\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.CoreGraph-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.CoreGraph","text":"CoreGraph(g::GraphInterface) -> CoreGraph\n\nConvert any GraphInterface implementation to a CoreGraph using constructor syntax. This is an idiomatic Julia alternative to to_core_graph(g).\n\nExamples\n\n# Constructor style (idiomatic)\ncore_g = CoreGraph(adj_graph)\n\n# Equivalent to conversion function\ncore_g = to_core_graph(adj_graph)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.CoreGraph-Union{Tuple{GraphInterface}, Tuple{D}} where D","page":"API Reference","title":"GraphCore.CoreGraph","text":"CoreGraph{D}(g::GraphInterface) -> CoreGraph{D}\n\nConvert any GraphInterface to a CoreGraph with explicit directedness type parameter. The source graph must have the same directedness as specified by the type parameter.\n\nExamples\n\n# Type-safe conversions (will succeed)\ndirected_core = CoreGraph{true}(directed_adj_graph)\nundirected_core = CoreGraph{false}(undirected_adj_graph)\n\n# Type mismatch (will throw TypeError)\n# CoreGraph{true}(undirected_graph)  # ERROR!\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.EdgeIterator","page":"API Reference","title":"GraphCore.EdgeIterator","text":"EdgeIterator{G<:GraphInterface,D}\nEdgeIterator(graph::G, D::Bool) -> EdgeIterator{G,D}\n\nUnified iterator over edges in a graph, yielding (source, target) tuples.\n\nType Parameters\n\nG<:GraphInterface: The graph type\nD::Bool: Direction mode\nD=false (undirected mode): For directed graphs yields each edge once as (u,v).                             For undirected graphs yields each edge once in canonical form (u,v) where u ≤ v.\nD=true (directed mode): For directed graphs yields each edge once as (u,v).                           For undirected graphs yields each edge twice as (u,v) and (v,u).\n\nSee also: edges, all_directed_edges\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.GraphInterface","page":"API Reference","title":"GraphCore.GraphInterface","text":"GraphInterface <: AbstractGraph{Int32}\n\nBase abstract type for all graphs in the GraphCore ecosystem. All vertices are indexed by Int32 integers 1, 2, ..., num_vertices(g).\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.PropertyGraph","page":"API Reference","title":"GraphCore.PropertyGraph","text":"PropertyGraph{G,V,E} <: PropertyGraphInterface{V,E}\n\nUniversal property graph that wraps any base graph type with typed vertex and edge properties.\n\nType Parameters\n\nG<:GraphInterface: Base graph type (CoreGraph, WeightedGraph, AdjGraph, etc.)\nV: Vertex property type\nE: Edge property type\n\nDesign Benefits\n\nUniversal wrapper: Works with any GraphInterface implementation\nZero-cost delegation: All structural operations forwarded to base graph\nType safety: Compile-time property type guarantees\nAutomatic mutations: Inherits mutation capabilities from base graph\nMemory efficiency: No overhead when properties are unused\n\nUsage Patterns\n\n# Static analysis with CoreGraph base\ncore_g = build_core_graph(edges; directed=false)\nvertex_labels = [\"Alice\", \"Bob\", \"Charlie\"]\nedge_types = [\"friend\", \"colleague\", \"family\"]\npg = PropertyGraph(core_g, vertex_labels, edge_types)\n\n# Access patterns\nname = pg[1]                           # Vertex property via indexing\nedge_type = edge_property(pg, 2)       # Edge property by index\npg[1] = \"Alice Updated\"                # Property modification\n\n# Dynamic graphs with AdjGraph base\nadj_g = build_adj_graph(edges; directed=false)\npg_mut = PropertyGraph(adj_g, vertex_labels, edge_types)\n\n# Efficient mutations (when base graph supports them)\nnew_vertex = add_vertex!(pg_mut, \"David\")           # O(1) addition\nedge_idx = add_edge!(pg_mut, 1, new_vertex, \"buddy\")  # O(1) addition\n\n# Combined with weights\nweighted_g = build_weighted_graph(edges, weights; directed=false)\npg = PropertyGraph(weighted_g, vertex_labels, edge_types)\n# Now has both weights and properties available\n\nMutation Behavior\n\n# Mutations work when base graph supports them\nadj_pg = PropertyGraph(build_adj_graph(edges), v_props, e_props)\nadd_edge!(adj_pg, u, v, edge_prop)  # ✅ Works - AdjGraph supports mutations\n\n# Mutations fail gracefully when base graph doesn't support them\ncore_pg = PropertyGraph(build_core_graph(edges), v_props, e_props)\nadd_edge!(core_pg, u, v, edge_prop)  # ❌ MethodError - CoreGraph is immutable\n\n# Property arrays are automatically maintained during mutations\noriginal_count = length(adj_pg.edge_properties)\nedge_idx = add_edge!(adj_pg, u, v, edge_prop)\n@assert length(adj_pg.edge_properties) == original_count + 1\n\nPerformance Notes\n\nDelegation overhead: Typically optimized away by compiler\nMutation performance: Same as underlying graph type\nProperty management: Automatic with minimal overhead\nMemory: Base graph memory + property arrays + small wrapper overhead\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.PropertyGraphInterface","page":"API Reference","title":"GraphCore.PropertyGraphInterface","text":"PropertyGraphInterface{V,E,W} <: GraphInterface\nAbstract interface for property graphs, which support vertex and edge properties.\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.WeightedAdjGraph","page":"API Reference","title":"GraphCore.WeightedAdjGraph","text":"WeightedAdjGraph{W,D} <: WeightedGraphInterface{W}\n\nWeighted dynamic graph extending AdjGraph with parallel weight storage. Combines the mutation efficiency of adjacency lists with type-safe weights.\n\nType Parameters\n\nW<:Number: Weight type (Float64, Int32, etc.)\nD::Bool: Directedness flag\n\nKey Features\n\nSame mutation performance as AdjGraph for structural operations\nType-safe weights with compile-time guarantees\nDirectional weights even for undirected graphs\nParallel storage maintaining weight-neighbor correspondence\n\nWeight Semantics\n\nImportant: Weights are always directional, even for undirected graphs. This allows asymmetric edge properties while maintaining undirected connectivity.\n\n# For undirected edge with different directional costs:\ng = build_weighted_adj_graph([(1,2)], [1.5]; directed=false)\n# Internally stores: neighbors[1]=[2], weights[1]=[1.5]\n#                   neighbors[2]=[1], weights[2]=[1.5]\n# But weights can be modified independently if needed\n\n# Access via directional indexing:\nidx_12 = find_directed_edge_index(g, 1, 2)  # Different from (2,1)\nidx_21 = find_directed_edge_index(g, 2, 1)\nweight_12 = edge_weight(g, idx_12)  # Initial: 1.5\nweight_21 = edge_weight(g, idx_21)  # Initial: 1.5 (same value, different storage)\n\nMutation Examples\n\nedges = [(1,2), (2,3)]\nweights = [1.0, 2.0]\ng = build_weighted_adj_graph(edges, weights; directed=false)\n\n# Add weighted edge\nedge_idx = add_edge!(g, 3, 1, 1.5)  # O(1) amortized\n\n# Efficient weight access during iteration\nfor (neighbor, weight) in neighbor_weights(g, v)\n    process_weighted_neighbor(neighbor, weight)\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.WeightedAdjGraph-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W","page":"API Reference","title":"GraphCore.WeightedAdjGraph","text":"WeightedAdjGraph(g::WeightedGraphInterface{W}) -> WeightedAdjGraph{W}\nWeightedAdjGraph{W}(g::WeightedGraphInterface{W}) -> WeightedAdjGraph{W}\nWeightedAdjGraph{W,D}(g::WeightedGraphInterface{W}) -> WeightedAdjGraph{W,D}\n\nConvert any WeightedGraphInterface to a WeightedAdjGraph using constructor syntax. Supports multiple forms with different levels of type specification.\n\nConstructor Forms\n\nWeightedAdjGraph(g): Auto-infer weight type and directedness\nWeightedAdjGraph{W}(g): Explicit weight type parameter\nWeightedAdjGraph{W,D}(g): Explicit weight type and directedness parameters\n\nExamples\n\n# Basic constructor (auto-infer types)\nweighted_adj = WeightedAdjGraph(weighted_core_graph)\n\n# Explicit weight type\nweighted_adj = WeightedAdjGraph{Float64}(core_graph)\n\n# Full type specification\n# Full type specification with directedness assertion\ndirected_weighted_adj = WeightedAdjGraph{Float64,true}(directed_weighted_graph)   # ✅ OK\nundirected_weighted_adj = WeightedAdjGraph{Float64,false}(undirected_weighted_graph) # ✅ OK\n# WeightedAdjGraph{Float64,true}(undirected_graph)  # ❌ ERROR: directedness mismatch\n\n# Equivalent to conversion function\nweighted_adj = to_weighted_adj_graph(weighted_core_graph)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.WeightedGraph","page":"API Reference","title":"GraphCore.WeightedGraph","text":"WeightedGraph{W,D} <: WeightedGraphInterface{W}\n\nWeighted graph extending CoreGraph with parallel weight storage.\n\nType Parameters\n\nW<:Number: Weight type (Float64, Int32, etc.)\nD::Bool: Directedness flag\n\nKey Features\n\nSame performance as CoreGraph for structural operations\nType-safe weights with compile-time guarantees\nDirectional weights even for undirected graphs\nParallel storage for cache-efficient weight access\n\nWeight Semantics\n\nImportant: Weights are always directional, even for undirected graphs. This allows asymmetric edge properties (e.g., different costs per direction).\n\n# For undirected edge (1,2) with weight 1.5:\nedge_weight(g, find_directed_edge_index(g, 1, 2)) # → 1.5\nedge_weight(g, find_directed_edge_index(g, 2, 1)) # → 1.5 (same value, different index)\n\n# But can be set differently if needed:\nweights = [1.5, 2.0]  # Different costs for each direction\ng = build_weighted_graph([(1,2), (2,1)], weights; directed=true)\n\nConstruction Examples\n\n# Undirected weighted graph\nedges = [(1,2), (2,3)]\nweights = [1.5, 2.0]\ng = build_weighted_graph(edges, weights; directed=false)\n\n# Type-specific construction\ng = build_graph(WeightedGraph{Float32}, edges; weights=weights, directed=false)\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.WeightedGraph-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W","page":"API Reference","title":"GraphCore.WeightedGraph","text":"WeightedGraph(g::WeightedGraphInterface{W}) -> WeightedGraph{W}\nWeightedGraph{W}(g::WeightedGraphInterface{W}) -> WeightedGraph{W}\nWeightedGraph{W,D}(g::WeightedGraphInterface{W}) -> WeightedGraph{W,D}\n\nConvert any WeightedGraphInterface to a WeightedGraph using constructor syntax. Supports multiple forms with different levels of type specification.\n\nConstructor Forms\n\nWeightedGraph(g): Auto-infer weight type and directedness\nWeightedGraph{W}(g): Explicit weight type parameter\nWeightedGraph{W,D}(g): Explicit weight type and directedness parameters (with type assertion)\n\nExamples\n\n# Basic constructor (auto-infer types)\nweighted_g = WeightedGraph(weighted_adj_graph)\n\n# Explicit weight type\nweighted_g = WeightedGraph{Float64}(adj_graph)\n\n# Full type specification with directedness assertion\ndirected_weighted = WeightedGraph{Float64,true}(directed_weighted_graph)   # ✅ OK\nundirected_weighted = WeightedGraph{Float64,false}(undirected_weighted_graph) # ✅ OK\n# WeightedGraph{Float64,true}(undirected_graph)  # ❌ ERROR: directedness mismatch\n\n# Equivalent to conversion function\nweighted_g = to_weighted_graph(weighted_adj_graph)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.WeightedGraphInterface","page":"API Reference","title":"GraphCore.WeightedGraphInterface","text":"WeightedGraphInterface <: GraphInterface\n\nInterface for weighted graphs, extending the core graph interface. W is the type of edge weights, typically a numeric type.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.getindex-Tuple{PropertyGraphInterface, Integer}","page":"API Reference","title":"Base.getindex","text":"Base.getindex(g::PropertyGraphInterface, v::Integer) -> property\n\nGet the vertex property for vertex v of graph g. Equivalent to vertex_property(g, v).\n\nExample\n\ng = build_property_graph(edges, [\"Alice\", \"Bob\", \"Charlie\"], edge_props)\nname = g[1]  # Returns \"Alice\"\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{PropertyGraphInterface, Pair{<:Integer, <:Integer}}","page":"API Reference","title":"Base.getindex","text":"Base.getindex(g::PropertyGraphInterface, edge::Pair{<:Integer,<:Integer}) -> property\n\nGet the edge property for the edge defined by the given vertex pair. Use as g[u => v] to get the property of the edge from u to v. Equivalent to edge_property(g, find_edge_index(g, u, v))\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{PropertyGraphInterface, Any, Integer}","page":"API Reference","title":"Base.setindex!","text":"Base.setindex!(g::PropertyGraphInterface, prop, v::Integer)\n\nSet the vertex property for vertex v of graph g. Equivalent to set_vertex_property!(g, prop, v).\n\nExample\n\ng[1] = \"Alice_Updated\"  # Sets vertex 1's property\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{PropertyGraphInterface, Any, Pair{<:Integer, <:Integer}}","page":"API Reference","title":"Base.setindex!","text":"Base.setindex!(g::PropertyGraphInterface, prop, edge::Pair{<:Integer,<:Integer})\n\nSet the edge property for the edge defined by the given vertex pair. Use as g[u => v] = prop to set the property of the edge from u to v. Equivalent to set_edge_property!(g, find_edge_index(g, u, v), prop)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore._add_directed_edge!-Union{Tuple{D}, Tuple{CoreGraph{D}, Integer, Integer}, Tuple{CoreGraph{D}, Integer, Integer, Any}} where D","page":"API Reference","title":"GraphCore._add_directed_edge!","text":"_add_directed_edge!(g::CoreGraph, u::Integer, v::Integer, edge_idx=nothing)\n\nInternal helper to add a single directed edge u -> v to the CSR structure. For undirected graphs, edge_idx specifies the undirected edge index to store.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore._add_directed_weighted_edge!-Union{Tuple{D}, Tuple{W}, Tuple{WeightedGraph{W, D}, Integer, Integer, W}, Tuple{WeightedGraph{W, D}, Integer, Integer, W, Any}} where {W, D}","page":"API Reference","title":"GraphCore._add_directed_weighted_edge!","text":"_add_directed_weighted_edge!(g::WeightedGraph, u::Integer, v::Integer, weight, edge_idx=nothing)\n\nInternal helper to add a single directed weighted edge u -> v to the CSR structure.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore._remove_directed_edge!-Union{Tuple{D}, Tuple{CoreGraph{D}, Integer, Integer}} where D","page":"API Reference","title":"GraphCore._remove_directed_edge!","text":"_remove_directed_edge!(g::CoreGraph, u::Integer, v::Integer)\n\nInternal helper to remove a single directed edge u -> v from the CSR structure.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore._remove_directed_weighted_edge!-Union{Tuple{D}, Tuple{W}, Tuple{WeightedGraph{W, D}, Integer, Integer}} where {W, D}","page":"API Reference","title":"GraphCore._remove_directed_weighted_edge!","text":"_remove_directed_weighted_edge!(g::WeightedGraph, u::Integer, v::Integer)\n\nInternal helper to remove a single directed weighted edge u -> v from the CSR structure.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_edge!","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(g::GraphInterface, u::Integer, v::Integer, ...) -> Int32\n\nAdd an edge from u to v with the optinal properties. Returns the edge index of the newly added edge, or 0 if edge already exists. For undirected graphs, this adds the edge in both directions internally. Only available for mutable graph types.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.add_edge!-Tuple{AdjGraph, Integer, Integer}","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(g::AdjGraph, u::Integer, v::Integer) -> Int32\n\nAdd an edge from u to v and return the edge index (or 0 if already exists).\n\nPerformance\n\nTime Complexity: O(1) amortized (vector push operations)\nSpace Complexity: O(1) per direction\nIndex Stability: All existing indices remain valid, new edge gets max+1\n\nBehavior Details\n\nDirected graphs: Adds only u→v edge\nUndirected graphs: Adds both u→v and v→u internally with same edge index\nDuplicate detection: Returns 0 if edge already exists (no modification)\nIndex assignment: New edges get next available index\n\nExamples\n\ng = build_adj_graph([(1,2)]; directed=false)\n@assert num_edges(g) == 1\n\n# Add new edge\nedge_idx = add_edge!(g, 2, 3)\n@assert edge_idx == 2  # Next available index\n@assert num_edges(g) == 2\n@assert has_edge(g, 2, 3) && has_edge(g, 3, 2)  # Both directions for undirected\n\n# Try duplicate\nduplicate_idx = add_edge!(g, 1, 2)\n@assert duplicate_idx == 0  # Already exists\n@assert num_edges(g) == 2    # No change\n\nError Conditions\n\nThrows BoundsError if vertices u or v don't exist in the graph. Use add_vertex! first if needed.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_edge!-Union{Tuple{D}, Tuple{CoreGraph{D}, Integer, Integer}} where D","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(g::CoreGraph, u::Integer, v::Integer) -> Int32\n\nAdd an edge from u to v and return the edge index (or 0 if edge already exists).\n\nEfficient Implementation: O(degree) operation that extends the CSR arrays and updates offsets.\n\nFor undirected graphs, this adds the edge in both directions internally.\n\nExample\n\ng = build_core_graph([(1,2)]; directed=false)\nedge_idx = add_edge!(g, 1, 3)  # Returns edge index\n@assert has_edge(g, 1, 3) && has_edge(g, 3, 1)  # Both directions for undirected\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_edge!-Union{Tuple{D}, Tuple{W}, Tuple{WeightedGraph{W, D}, Integer, Integer, W}} where {W, D}","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(g::WeightedGraph{W}, u::Integer, v::Integer, weight::W) -> Int32\n\nAdd a weighted edge from u to v and return the edge index (or 0 if edge already exists).\n\nEfficient Implementation: O(degree) operation that extends the CSR arrays and updates offsets.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_edge!-Union{Tuple{E}, Tuple{V}, Tuple{G}, Tuple{PropertyGraph{G, V, E}, Integer, Integer, E}} where {G, V, E}","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(g::PropertyGraph{G,V,E}, u::Integer, v::Integer, edge_prop::E) -> Int32\n\nAdd an edge from u to v with the specified edge property. Returns the edge index of the newly added edge, or 0 if edge already exists.\n\nOnly available when the base graph type supports add_edge!. Property arrays are automatically maintained.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_edge!-Union{Tuple{E}, Tuple{V}, Tuple{W}, Tuple{PropertyGraph{<:WeightedGraphInterface{W}, V, E}, Integer, Integer, W, E}} where {W, V, E}","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(g::PropertyGraph{<:WeightedGraphInterface,V,E}, u::Integer, v::Integer,\n          weight::W, edge_prop::E) -> Int32\n\nAdd a weighted edge from u to v with the specified weight and edge property. Returns the edge index of the newly added edge, or 0 if edge already exists.\n\nOnly available when the base graph type supports weighted add_edge!.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_edge!-Union{Tuple{W}, Tuple{WeightedAdjGraph{W}, Integer, Integer, W}} where W","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(g::WeightedAdjGraph{W}, u::Integer, v::Integer, weight::W) -> Int32\n\nAdd a weighted edge from u to v in the graph. Returns the edge index of the newly added edge, or 0 if edge already exists. For undirected graphs, both directions get the same weight.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_vertex!","page":"API Reference","title":"GraphCore.add_vertex!","text":"add_vertex!(g::GraphInterface, ...) -> Int32\n\nAdd a new vertex with optional properties. Returns the index of the newly added vertex. Only available for mutable graph types.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.add_vertex!-Tuple{AdjGraph}","page":"API Reference","title":"GraphCore.add_vertex!","text":"add_vertex!(g::AdjGraph) -> Int32\n\nAdd a new isolated vertex to the graph and return its index.\n\nPerformance\n\nTime Complexity: O(1)\nSpace Complexity: O(1) - just adds empty vectors\nIndex Stability: All existing vertex/edge indices remain valid\n\nImplementation Details\n\nCreates empty neighbor list and empty neighbortoedge mapping. New vertex has no neighbors initially and can be connected via add_edge!.\n\nExamples\n\ng = build_adj_graph([(1,2), (2,3)]; directed=false)\n@assert num_vertices(g) == 3\n\nnew_v = add_vertex!(g)\n@assert new_v == 4\n@assert num_vertices(g) == 4\n@assert degree(g, new_v) == 0  # Isolated vertex\n\n# Connect new vertex\nadd_edge!(g, 1, new_v)\n@assert degree(g, new_v) == 1\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_vertex!-Union{Tuple{CoreGraph{D}}, Tuple{D}} where D","page":"API Reference","title":"GraphCore.add_vertex!","text":"add_vertex!(g::CoreGraph) -> Int32\n\nAdd a new isolated vertex to the graph and return its index.\n\nEfficient Implementation: O(1) operation that simply extends the vertex_offsets array.\n\nExample\n\ng = build_core_graph([(1,2), (2,3)]; directed=false)\nnew_vertex = add_vertex!(g)  # Returns 4\n@assert num_vertices(g) == 4\n@assert length(neighbor_indices(g, new_vertex)) == 0  # Isolated vertex\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_vertex!-Union{Tuple{E}, Tuple{V}, Tuple{G}, Tuple{PropertyGraph{G, V, E}, V}} where {G, V, E}","page":"API Reference","title":"GraphCore.add_vertex!","text":"add_vertex!(g::PropertyGraph{G,V,E}, vertex_prop::V) -> Int32\n\nAdd a new vertex to the property graph with the specified property. Returns the index of the new vertex.\n\nOnly available when the base graph type supports add_vertex!.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_vertex!-Union{Tuple{WeightedAdjGraph{W}}, Tuple{W}} where W","page":"API Reference","title":"GraphCore.add_vertex!","text":"add_vertex!(g::WeightedAdjGraph{W}) -> Int32 where W\n\nAdd a new vertex to the weighted graph and return its index. The new vertex has no neighbors initially.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_vertex!-Union{Tuple{WeightedGraph{W, D}}, Tuple{D}, Tuple{W}} where {W, D}","page":"API Reference","title":"GraphCore.add_vertex!","text":"add_vertex!(g::WeightedGraph) -> Int32\n\nAdd a new isolated vertex to the weighted graph and return its index.\n\nEfficient Implementation: O(1) operation that simply extends the vertex_offsets array.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.all_directed_edges-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.all_directed_edges","text":"all_directed_edges(g::GraphInterface) -> Iterator\n\nReturn an iterator over all directed edges in the graph.\n\nFor directed graphs: yields (source, target) pairs for each directed edge\nFor undirected graphs: yields (u, v) and (v, u) pairs for each undirected edge\n\nExamples\n\nfor (u, v) in all_directed_edges(g)\n    println(\"Directed edge from \", u, \" to \", v)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.all_edges-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.all_edges","text":"all_edges(g::GraphInterface) -> Iterator\n\nAlias for edges(g). Provided for disambiguation when using multiple graph libraries.\n\nSee also: edges\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_adj_graph-Tuple{Any}","page":"API Reference","title":"GraphCore.build_adj_graph","text":"Build adjacency list graph with same interface as CoreGraph.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_core_graph-Tuple{Any}","page":"API Reference","title":"GraphCore.build_core_graph","text":"Build unweighted core graph (most common case)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_graph-Union{Tuple{W}, Tuple{E}, Tuple{V}, Tuple{G}, Tuple{Type{PropertyGraph{G, V, E}}, Any}} where {G<:GraphInterface, V, E, W<:Number}","page":"API Reference","title":"GraphCore.build_graph","text":"build_graph(::Type{PropertyGraph{G,V,E}}, edges; kwargs...) where {G,V,E}\n\nBuild a property graph with vertex and edge properties. The underlying graph type G determines performance characteristics (CoreGraph for CSR, AdjGraph for adjacency list).\n\nArguments\n\nedges: Vector of (u,v) tuples/pairs representing graph edges\ndirected=true: Whether the graph is directed\nvertex_properties=[]: Properties for each vertex (type V)\nedge_properties=[]: Properties for each edge (type E)\nweights=[]: Edge weights (optional)\nvalidate=true: Whether to validate inputs\n\nExamples\n\n# Property graph with CoreGraph backend\ng = build_graph(PropertyGraph{CoreGraph,String,String}, [(1,2), (2,3)];\n                vertex_properties=[\"A\", \"B\", \"C\"], edge_properties=[\"e1\", \"e2\"])\n\n# Property graph with AdjGraph backend for dynamic use\ng = build_graph(PropertyGraph{AdjGraph,Int,Symbol}, [(1,2), (2,3)];\n                vertex_properties=[1, 2, 3], edge_properties=[:a, :b])\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_graph-Union{Tuple{W}, Tuple{G}, Tuple{Type{G}, Any}} where {G<:Union{AdjGraph, WeightedAdjGraph}, W<:Number}","page":"API Reference","title":"GraphCore.build_graph","text":"build_graph(::Type{G}, edges; kwargs...) where {G<:AdjGraphTypes}\n\nBuild adjacency list graph optimized for dynamic modifications and mutations.\n\nArguments\n\nedges: Vector of (u,v) tuples/pairs representing graph edges\ndirected=true: Whether to build a directed graph\nweights=[]: Edge weights (for WeightedAdjGraph types)\nvalidate=true: Enable input validation\n\nPerformance Characteristics\n\nDynamic-friendly: Efficient vertex/edge additions and removals\nMemory flexible: Grows naturally, higher overhead than CSR\nMutation-optimized: O(1) edge additions, efficient vertex operations\n\nUse AdjGraph types when frequent graph modifications are expected. For static graphs with performance-critical traversals, prefer CoreGraph types.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_graph-Union{Tuple{W}, Tuple{G}, Tuple{Type{G}, Any}} where {G<:Union{CoreGraph, WeightedGraph}, W<:Number}","page":"API Reference","title":"GraphCore.build_graph","text":"build_graph(::Type{G}, edges; kwargs...) -> G\n\nBuild a graph from an edge list with comprehensive validation and flexible options.\n\nArguments\n\nedges: Vector of (u,v) tuples/pairs representing graph edges\ndirected=true: Whether to build a directed graph\nn=0: Number of vertices (0 = auto-detect from edges)\nweights=[]: Edge weights (for WeightedGraph types)\nvalidate=true: Enable input validation (recommended for safety)\n\nExamples\n\n# Basic graphs\ng = build_graph(CoreGraph, [(1,2), (2,3)]; directed=false)\nwg = build_graph(WeightedGraph{Float64}, [(1,2), (2,3)]; weights=[1.5, 2.0], directed=false)\n\n# Graph with isolated vertices\ng = build_graph(CoreGraph, [(1,2)]; n=5, directed=false)  # Creates isolated vertices 3,4,5\n\n# High-performance mode (skip validation)\ng = build_graph(CoreGraph, trusted_edges; directed=false, validate=false)\n\nOptimized for CSR representation with efficient construction and memory usage. For dynamic graphs requiring frequent mutations, consider AdjGraph types.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_property_adj_graph-Union{Tuple{E}, Tuple{V}, Tuple{Any, AbstractVector{V}, AbstractVector{E}}} where {V, E}","page":"API Reference","title":"GraphCore.build_property_adj_graph","text":"build_property_adj_graph(edges, vertex_properties, edge_properties; directed=true, kwargs...)\n\nBuild a PropertyGraph with AdjGraph backend (supports efficient mutations).\n\nArguments\n\nedges: Vector of (u,v) tuples representing graph edges\nvertex_properties: Vector of vertex properties\nedge_properties: Vector of edge properties\ndirected=true: Whether to build a directed graph\nkwargs...: Additional arguments passed to underlying graph construction\n\nExample\n\nedges = [(1,2), (2,3)]\nvertex_props = [1, 2, 3]\nedge_props = [:a, :b]\npg = build_property_adj_graph(edges, vertex_props, edge_props; directed=false)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_property_graph-Union{Tuple{E}, Tuple{V}, Tuple{Any, AbstractVector{V}, AbstractVector{E}}} where {V, E}","page":"API Reference","title":"GraphCore.build_property_graph","text":"build_property_graph(edges, vertex_properties, edge_properties; directed=true, kwargs...)\n\nBuild a PropertyGraph with CoreGraph backend.\n\nArguments\n\nedges: Vector of (u,v) tuples representing graph edges\nvertex_properties: Vector of vertex properties\nedge_properties: Vector of edge properties\ndirected=true: Whether to build a directed graph\nkwargs...: Additional arguments passed to underlying graph construction\n\nExample\n\nedges = [(1,2), (2,3), (1,3)]\nvertex_props = [\"Alice\", \"Bob\", \"Charlie\"]\nedge_props = [\"friend\", \"colleague\", \"family\"]\npg = build_property_graph(edges, vertex_props, edge_props; directed=false)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_weighted_graph-Union{Tuple{W}, Tuple{Any, AbstractVector{W}}} where W","page":"API Reference","title":"GraphCore.build_weighted_graph","text":"Build weighted graph\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.canonicalize_edges-Tuple{Any}","page":"API Reference","title":"GraphCore.canonicalize_edges","text":"canonicalize_edges(edges) -> Vector{Tuple{Int,Int}}\n\nConvert symmetric edge format to canonical format for undirected graphs.\n\nArguments\n\nedges: Vector of (u,v) tuples representing edges\n\nReturns\n\nVector of canonical edges where u ≤ v for each edge\n\nFormat Conversion\n\nInput: [(1,2), (2,1), (2,3), (3,2)] (both directions)\nOutput: [(1,2), (2,3)] (canonical: u ≤ v)\n\nUse when your input has both directions listed for undirected edges. This removes duplicates and ensures a consistent canonical representation.\n\nExample\n\nedges = [(1,2), (2,1), (2,3), (3,2), (1,3), (3,1)]\ncanonical = GraphCore.canonicalize_edges(edges)\n# Result: [(1,2), (1,3), (2,3)]\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.canonicalize_edges-Union{Tuple{W}, Tuple{Any, AbstractVector{W}}} where W","page":"API Reference","title":"GraphCore.canonicalize_edges","text":"canonicalize_edges(edges, weights::AbstractVector{W}) -> (canonical_edges, canonical_weights)\n\nConvert symmetric format to canonical, keeping weights for canonical edges only.\n\nArguments\n\nedges: Vector of (u,v) tuples representing edges\nweights: Vector of weights corresponding to edges\n\nReturns\n\nTuple of (canonicaledges, canonicalweights)\n\nBehavior\n\nWhen multiple weights exist for the same undirected edge, keeps the first encountered weight. This is useful when processing datasets that list both directions with potentially different weights.\n\nExample\n\nedges = [(1,2), (2,1), (2,3), (3,2)]\nweights = [1.5, 1.5, 2.0, 2.1]  # Note: slight difference in last weight\ncanonical_edges, canonical_weights = GraphCore.canonicalize_edges(edges, weights)\n# Result: edges = [(1,2), (2,3)], weights = [1.5, 2.0]\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.degree-Tuple{GraphInterface, Integer}","page":"API Reference","title":"GraphCore.degree","text":"degree(g::GraphInterface, v::Integer) -> Int32\n\nReturn the degree of vertex v (number of neighbors).\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.directed_edge_index","page":"API Reference","title":"GraphCore.directed_edge_index","text":"directed_edge_index(g::GraphInterface, v::Integer, i::Integer) -> Int32\n\nGet the directed edge index for the i-th neighbor of vertex v.\n\nSimilar to edge_index but for directional properties. Always provides directional indexing even for undirected graphs.\n\nKey difference: For undirected graphs:\n\nedge_index(g, u, i) == edge_index(g, v, j) if neighbors are the same edge\ndirected_edge_index(g, u, i) ≠ directed_edge_index(g, v, j) (always directional)\n\nThis enables asymmetric properties on undirected graphs (e.g., different costs for traversing an edge in each direction).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.directed_edge_indices","page":"API Reference","title":"GraphCore.directed_edge_indices","text":"directed_edge_indices(g::GraphInterface, v::Integer) -> view or iterator\n\nReturn an iterator over the directed edge indices for edges from vertex v. The i-th edge index corresponds to the i-th neighbor in neighbor_indices(g, v). For directed graphs this is the same asdirectededgeindices(g, v)`.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.directed_edge_indices-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.directed_edge_indices","text":"directed_edge_indices(g::GraphInterface) -> UnitRange{Int}\n\nReturn a range over all directed edge indices. Suitable for sizing and indexing external directed edge property arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.edge_index","page":"API Reference","title":"GraphCore.edge_index","text":"edge_index(g::GraphInterface, v::Integer, i::Integer) -> Int32\n\nGet the undirected edge index for the i-th neighbor of vertex v.\n\nThis provides O(1) conversion from neighbor position to edge index, enabling efficient indexing into external edge property arrays.\n\nRelationship: edge_index(g, v, i) == find_edge_index(g, v, neighbor_indices(g, v)[i])\n\nUse case: Processing neighbors with associated edge data\n\nedge_weights = Vector{Float64}(undef, num_edges(g))\nfor (i, neighbor) in enumerate(neighbor_indices(g, v))\n    edge_idx = edge_index(g, v, i)           # O(1) - no search needed!\n    weight = edge_weights[edge_idx]          # Direct array access\n    process_neighbor_with_weight(neighbor, weight)\nend\n\nIndex stability: Edge indices remain stable during graph analysis, but may be invalidated by structural modifications (add/remove operations).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.edge_indices","page":"API Reference","title":"GraphCore.edge_indices","text":"edge_indices(g::GraphInterface, v::Integer) -> view or iterator\n\nReturn an iterator over the undirected edge indices for edges from vertex v. The i-th edge index corresponds to the i-th neighbor in neighbor_indices(g, v).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.edge_indices-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.edge_indices","text":"edge_indices(g::GraphInterface) -> UnitRange{Int}\n\nReturn a range over all undirected edge indices. Suitable for sizing and indexing external edge property arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.edge_properties","page":"API Reference","title":"GraphCore.edge_properties","text":"edge_properties(g::PropertyGraphInterface) -> iterator\n\nReturn an iterator over all edge properties in edge index order.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.edge_property","page":"API Reference","title":"GraphCore.edge_property","text":"edge_property(g::PropertyGraphInterface, edge_idx::Integer) -> E\n\nGet the property associated with edge at the given edge index. Uses undirected edge indexing (1:num_edges).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.edge_property-Tuple{GraphInterface, Integer, Integer}","page":"API Reference","title":"GraphCore.edge_property","text":"edge_property(g::GraphInterface, u::Integer, v::Integer) -> E\n\nGet the property of the edge between u and v. Uses undirected edge indexing - for undirected graphs, this returns the same property regardless of direction.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.edge_weight","page":"API Reference","title":"GraphCore.edge_weight","text":"edge_weight(g::WeightedGraphInterface, directed_edge_idx::Integer) -> W\nedge_weight(g::WeightedGraphInterface, edge::Pair{<:Integer,<:Integer}) -> W\n\nGet the weight of the directed edge at the given directed edge index. Uses the directional indexing system for O(1) weight lookups. The second form allows querying by vertex pair, equivalent to edge_weight(g, find_edge_index(g, u, v)).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.edge_weights","page":"API Reference","title":"GraphCore.edge_weights","text":"edge_weights(g::WeightedGraphInterface, v::Integer) -> view or iterator\nedge_weights(g::WeightedGraphInterface) -> view or iterator\n\nReturn weights for edges from vertex v, or all edge weights.\n\nImportant: Weights are always directional, even for undirected graphs. This design allows asymmetric weights (e.g., different traversal costs in each direction).\n\nOrdering: The i-th weight corresponds to the i-th neighbor in neighbor_indices(g, v).\n\nExamples\n\n# Process neighbors with weights\nfor (neighbor, weight) in zip(neighbor_indices(g, v), edge_weights(g, v))\n    process_weighted_edge(v, neighbor, weight)\nend\n\n# More convenient combined iteration\nfor (neighbor, weight) in neighbor_weights(g, v)\n    process_weighted_edge(v, neighbor, weight)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.edges-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.edges","text":"edges(g::GraphInterface) -> Iterator\n\nReturn an iterator over all edges in the graph.\n\nFor directed graphs: yields (source, target) pairs for each directed edge\nFor undirected graphs: yields (u, v) pairs where u ≤ v (each edge once)\n\nExamples\n\nfor (u, v) in edges(g)\n    println(\"Edge from \", u, \" to \", v)\nend\n\n# Collect all edges\nedge_list = collect(edges(g))\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.find_directed_edge_index","page":"API Reference","title":"GraphCore.find_directed_edge_index","text":"find_directed_edge_index(g::GraphInterface, u::Integer, v::Integer) -> Int32\n\nFind the directed edge index for the directed edge from vertices u to v of the graph g. Returns 0 if no such edge exists.\n\nAlways directional: find_directed_edge_index(g, u, v) ≠ find_directed_edge_index(g, v, u)\n\nThis index is used for directed edge weight access and other directional properties, and for indexing external arrays of size num_directed_edges(g).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.find_edge_index","page":"API Reference","title":"GraphCore.find_edge_index","text":"find_edge_index(g::GraphInterface, u::Integer, v::Integer) -> Int32\n\nFind the undirected edge index for the edge between vertices u and v of the graph g. Returns 0 if no such edge exists.\n\nFor undirected graphs: find_edge_index(g, u, v) == find_edge_index(g, v, u) For directed graphs: only finds the edge in the specified direction (u -> v)\n\nThis index is used for edge property access (shared properties) and for indexing external arrays of size numedges(g). For directed graphs this is the same as `finddirectededgeindex(g, u, v)`\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.has_edge","page":"API Reference","title":"GraphCore.has_edge","text":"has_edge(g::GraphInterface, u::Integer, v::Integer) -> Bool\n\nTest whether there is a directed edge from vertex u to vertex v. For undirected graphs, has_edge(g, u, v) == has_edge(g, v, u).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.has_vertex","page":"API Reference","title":"GraphCore.has_vertex","text":"has_vertex(g::GraphInterface, v::Integer) -> Bool\n\nTest whether vertex v exists in the graph. Vertices are always integers in range 1:num_vertices(g).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.interface_summary-Tuple{}","page":"API Reference","title":"GraphCore.interface_summary","text":"interface_summary()\n\nPrint a summary of the interface requirements.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.is_directed_graph","page":"API Reference","title":"GraphCore.is_directed_graph","text":"is_directed_graph(g::GraphInterface) -> Bool\n\nReturn true if the graph is directed, false if undirected. This affects the interpretation of edges and neighbor relationships.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.neighbor","page":"API Reference","title":"GraphCore.neighbor","text":"neighbor(g::GraphInterface, v::Integer, i::Integer) -> Int32\n\nReturn the i-th neighbor of vertex v in the graph g.\n\nDefault implementation provided - concrete types may override for efficiency.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.neighbor_indices","page":"API Reference","title":"GraphCore.neighbor_indices","text":"neighbor_indices(g::GraphInterface, v::Integer) -> view or iterator\n\nReturn an iterator over the neighbor indices of vertex v.\n\nFor directed graphs: Returns out-neighbors only For undirected graphs: Returns all neighbors\n\nPerformance guarantee: The returned iterator must support:\n\nFast iteration: for neighbor in neighbor_indices(g, v)\nLength query: length(neighbor_indices(g, v))\nIndex access: neighbor_indices(g, v)[i] (implementation dependent)\n\nMemory efficiency: Implementations should return views when possible to avoid allocation during neighbor traversal.\n\nExamples\n\n# Basic iteration\nfor neighbor in neighbor_indices(g, v)\n    process_neighbor(neighbor)\nend\n\n# Combined with indexing for edge properties\nfor (i, neighbor) in enumerate(neighbor_indices(g, v))\n    edge_idx = edge_index(g, v, i)        # O(1) edge index lookup\n    process_edge(neighbor, edge_idx)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.neighbor_weights","page":"API Reference","title":"GraphCore.neighbor_weights","text":"neighbor_weights(g::WeightedGraphInterface, v::Integer) -> iterator\n\nReturn an iterator over (neighbor_index, weight) pairs for vertex v. More efficient than separate iteration over neighbor_indices(g, v) and edge_weights(g, v).\n\nUsage:\n\n    for (neighbor, weight) in neighbor_weights(g, v)\n        # process neighbor and weight together\n    end\n\nSee also: neighbor_indices, edge_weights\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.num_directed_edges","page":"API Reference","title":"GraphCore.num_directed_edges","text":"num_directed_edges(g::GraphInterface) -> Int32\n\nReturn the total number of directed edges in the graph.\n\nFor undirected graphs: 2 * num_edges(g)\nFor directed graphs: actual count of directed edges\n\nThis count determines the size needed for directed edge property arrays.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.num_edges","page":"API Reference","title":"GraphCore.num_edges","text":"num_edges(g::GraphInterface) -> Int32\n\nReturn the number of edges in the graph. For undirected graphs, this counts each edge once. For directed graphs, this counts directed edges.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.num_vertices","page":"API Reference","title":"GraphCore.num_vertices","text":"num_vertices(g::GraphInterface) -> Int32\n\nReturn the number of vertices in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.remove_edge!","page":"API Reference","title":"GraphCore.remove_edge!","text":"remove_edge!(g::GraphInterface, u::Integer, v::Integer) -> Bool\n\nRemove the edge from u to v. Returns true if successful, false if edge doesn't exist. Only available for mutable graph types.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.remove_edge!-Tuple{AdjGraph, Integer, Integer}","page":"API Reference","title":"GraphCore.remove_edge!","text":"remove_edge!(g::AdjGraph, u::Integer, v::Integer) -> Bool\n\nRemove the edge from u to v from the graph. Returns true if successful, false if edge doesn't exist.\n\nPerformance\n\nTime Complexity: O(degree(u)) + O(degree(v)) for undirected\nSpace Complexity: O(1) - only removes data\nIndex Stability: ⚠️ MAY BREAK STABILITY - edge indices may be invalidated\n\nImplementation Details\n\nDirected graphs: Removes only u→v edge\nUndirected graphs: Removes both u→v and v→u internal representations\nSearch cost: Linear search in neighbor vectors to find edge\nArray operations: Uses deleteat! which may shift subsequent elements\n\nEdge Index Invalidation\n\ng = build_adj_graph([(1,2), (2,3), (1,3)]; directed=false)\n# Edge indices: (1,2)→1, (2,3)→2, (1,3)→3\n\n# External edge data\nedge_weights = [1.0, 2.0, 1.5]  # Indexed by edge indices\n\nremove_edge!(g, 2, 3)  # Remove edge with index 2\n# Now: remaining edges (1,2)→1, (1,3)→?\n# ⚠️ Edge index for (1,3) may have changed!\n# edge_weights[2] might now refer to wrong edge\n\nSafe Usage Patterns\n\n# ✅ SAFE: Use PropertyGraph for automatic edge property management\npg = PropertyGraph(g, vertex_props, edge_props)\nremove_edge!(pg, u, v)  # Edge properties automatically maintained\n\n# ✅ SAFE: Use edge-based operations instead of index-based\nfor (u, v) in edges(g)\n    weight = compute_weight_from_vertices(u, v)  # No index dependency\nend\n\n# ❌ UNSAFE: Assume edge indices remain stable across removals\nedge_data = Vector{Float64}(undef, num_edges(g))\nremove_edge!(g, u, v)\n# edge_data indices now potentially inconsistent!\n\nPerformance Considerations\n\nFor graphs with frequent edge removals, consider:\n\nBatch operations: Remove many edges at once, then rebuild external arrays\nAlternative storage: Use Dict{Tuple{Int,Int}, T} for edge properties\nConversion workflow: AdjGraph for building → CoreGraph for analysis\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.remove_edge!-Tuple{PropertyGraph, Integer, Integer}","page":"API Reference","title":"GraphCore.remove_edge!","text":"remove_edge!(g::PropertyGraph, u::Integer, v::Integer) -> Bool\n\nRemove the edge from u to v from the property graph. Returns true if successful, false if edge doesn't exist.\n\nOnly available when the base graph type supports remove_edge!. Property arrays are automatically maintained.\n\n⚠️  Index Invalidation Warning: Removing edges may invalidate edge indices and external arrays indexed by edge numbers.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.remove_edge!-Tuple{WeightedAdjGraph, Integer, Integer}","page":"API Reference","title":"GraphCore.remove_edge!","text":"remove_edge!(g::WeightedAdjGraph, u::Integer, v::Integer) -> Bool\n\nRemove the weighted edge from u to v from the graph. Returns true if successful, false if edge doesn't exist.\n\nPerformance\n\nTime Complexity: O(degree(u)) + O(degree(v)) for undirected\nSpace Complexity: O(1) - only removes data\nIndex Stability: ⚠️ MAY BREAK STABILITY - edge indices may be invalidated\n\nImplementation Details\n\nDirected graphs: Removes only u→v edge\nUndirected graphs: Removes both u→v and v→u internal representations\nSearch cost: Linear search in neighbor vectors to find edge\nArray operations: Uses deleteat! which may shift subsequent elements\n\nEdge Index Invalidation\n\ng = build_weighted_adj_graph([(1,2), (2,3), (1,3)]; directed=false)\n# Edge indices: (1,2)→1, (2,3)→2, (1,3)→3\n\n# External edge data\nedge_weights = [1.0, 2.0, 1.5]  # Indexed by edge indices\n\nremove_edge!(g, 2, 3)  # Remove edge with index 2\n# Now: remaining edges (1,2)→1, (1,3)→?\n# ⚠️ Edge index for (1,3) may have changed!\n# edge_weights[2] might now refer to wrong edge\n\nSafe Usage Patterns\n\n# ✅ SAFE: Use PropertyGraph for automatic edge property management\npg = PropertyGraph(g, vertex_props, edge_props)\nremove_edge!(pg, u, v)  # Edge properties automatically maintained\n\n# ✅ SAFE: Use edge-based operations instead of index-based\nfor (u, v) in edges(g)\n    weight = compute_weight_from_vertices(u, v)  # No index dependency\nend\n\n# ❌ UNSAFE: Assume edge indices remain stable across removals\nedge_data = Vector{Float64}(undef, num_edges(g))\nremove_edge!(g, u, v)\n# edge_data indices now potentially inconsistent!\n\nPerformance Considerations\n\nFor graphs with frequent edge removals, consider:\n\nBatch operations: Remove many edges at once, then rebuild external arrays\nAlternative storage: Use Dict{Tuple{Int,Int}, T} for edge properties\nConversion workflow: AdjGraph for building → CoreGraph for analysis\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.remove_edge!-Union{Tuple{D}, Tuple{CoreGraph{D}, Integer, Integer}} where D","page":"API Reference","title":"GraphCore.remove_edge!","text":"remove_edge!(g::CoreGraph, u::Integer, v::Integer) -> Bool\n\nRemove the edge from u to v from the graph. Returns true if successful, false if edge doesn't exist.\n\nEfficient Implementation: O(degree) operation that removes entries from CSR arrays and updates offsets.\n\nFor frequent mutations, consider using AdjGraph instead.\n\nExample\n\ng = build_core_graph([(1,2), (2,3), (1,3)]; directed=false)\nsuccess = remove_edge!(g, 1, 2)  # Returns true\n@assert !has_edge(g, 1, 2) && !has_edge(g, 2, 1)  # Both directions removed for undirected\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.remove_edge!-Union{Tuple{D}, Tuple{W}, Tuple{WeightedGraph{W, D}, Integer, Integer}} where {W, D}","page":"API Reference","title":"GraphCore.remove_edge!","text":"remove_edge!(g::WeightedGraph, u::Integer, v::Integer) -> Bool\n\nRemove the edge from u to v from the weighted graph. Returns true if successful, false if edge doesn't exist.\n\nEfficient Implementation: O(degree) operation that removes entries from CSR arrays and updates offsets.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.remove_vertex!","page":"API Reference","title":"GraphCore.remove_vertex!","text":"remove_vertex!(g::GraphInterface, v::Integer) -> Bool\n\nRemove vertex v and all its incident edges. Returns true if successful, false if vertex doesn't exist. Only available for mutable graph types.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.remove_vertex!-Tuple{AdjGraph, Integer}","page":"API Reference","title":"GraphCore.remove_vertex!","text":"remove_vertex!(g::AdjGraph, v::Integer) -> Bool\n\nRemove vertex v and all its incident edges from the graph. Returns true if successful, false if vertex doesn't exist.\n\nPerformance\n\nTime Complexity: O(V + incident_edges) - must update all vertex references\nSpace Complexity: O(1) - only removes data\nIndex Stability: ⚠️ BREAKS STABILITY - vertex indices > v are decremented\n\nImplementation Details\n\nEdge Removal: All incident edges are removed first (affects edge count)\nVertex Deletion: Vertex v is removed from adjacency structures\nIndex Update: All references to vertices > v are decremented by 1\nProperty Cleanup: For PropertyGraph, properties are also removed\n\nIndex Invalidation Warning\n\ng = build_adj_graph([(1,2), (2,3), (3,4)]; directed=false)\n# Before: vertices [1,2,3,4], vertex 3 has neighbors [2,4]\n\nsuccess = remove_vertex!(g, 2)  # Remove vertex 2\n# After: vertices [1,2,3], old vertex 3→new vertex 2, old vertex 4→new vertex 3\n# ⚠️ External arrays indexed by old vertex numbers are now INVALID!\n\n# External vertex properties become inconsistent:\nvertex_labels = [\"A\", \"B\", \"C\", \"D\"]  # Indexed by old vertex numbers\n# After removal: vertex_labels[3] no longer corresponds to current vertex 3!\n\nSafe Usage Patterns\n\n# ✅ SAFE: Use PropertyGraph for automatic property management\npg = PropertyGraph(g, vertex_labels, edge_labels)\nremove_vertex!(pg, 2)  # Properties automatically updated\n\n# ✅ SAFE: Rebuild external arrays after removal\nexternal_data = rebuild_after_removal(external_data, removed_vertex)\n\n# ❌ UNSAFE: Assume external arrays remain valid after removal\nremove_vertex!(g, v)\nold_label = vertex_labels[some_vertex]  # May be wrong!\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.remove_vertex!-Tuple{PropertyGraph, Integer}","page":"API Reference","title":"GraphCore.remove_vertex!","text":"remove_vertex!(g::PropertyGraph, v::Integer) -> Bool\n\nRemove vertex v and all its incident edges from the property graph. Returns true if successful, false if vertex doesn't exist.\n\nOnly available when the base graph type supports remove_vertex!. Property arrays are automatically maintained and indices updated.\n\n⚠️  Index Invalidation Warning: Removing vertices renumbers remaining vertices and invalidates external arrays indexed by vertex numbers.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.remove_vertex!-Tuple{WeightedAdjGraph, Integer}","page":"API Reference","title":"GraphCore.remove_vertex!","text":"remove_vertex!(g::WeightedAdjGraph, v::Integer) -> Bool\n\nRemove vertex v and all its incident edges from the weighted graph. Returns true if successful, false if vertex doesn't exist.\n\nPerformance\n\nTime Complexity: O(V + incident_edges) - must update all vertex references\nSpace Complexity: O(1) - only removes data\nIndex Stability: ⚠️ BREAKS STABILITY - vertex indices > v are decremented\n\nImplementation Details\n\nEdge Removal: All incident edges are removed first (affects edge count)\nVertex Deletion: Vertex v is removed from adjacency structures\nIndex Update: All references to vertices > v are decremented by 1\nProperty Cleanup: For PropertyGraph, properties are also removed\n\nIndex Invalidation Warning\n\ng = build_weighted_adj_graph([(1,2), (2,3), (3,4)]; directed=false)\n# Before: vertices [1,2,3,4], vertex 3 has neighbors [2,4]\n\nsuccess = remove_vertex!(g, 2)  # Remove vertex 2\n# After: vertices [1,2,3], old vertex 3→new vertex 2, old vertex 4→new vertex 3\n# ⚠️ External arrays indexed by old vertex numbers are now INVALID!\n\n# External vertex properties become inconsistent:\nvertex_labels = [\"A\", \"B\", \"C\", \"D\"]  # Indexed by old vertex numbers\n# After removal: vertex_labels[3] no longer corresponds to current vertex 3!\n\nSafe Usage Patterns\n\n# ✅ SAFE: Use PropertyGraph for automatic property management\npg = PropertyGraph(g, vertex_labels, edge_labels)\nremove_vertex!(pg, 2)  # Properties automatically updated\n\n# ✅ SAFE: Rebuild external arrays after removal\nexternal_data = rebuild_after_removal(external_data, removed_vertex)\n\n# ❌ UNSAFE: Assume external arrays remain valid after removal\nremove_vertex!(g, v)\nold_label = vertex_labels[some_vertex]  # May be wrong!\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.remove_vertex!-Union{Tuple{D}, Tuple{CoreGraph{D}, Integer}} where D","page":"API Reference","title":"GraphCore.remove_vertex!","text":"remove_vertex!(g::CoreGraph, v::Integer) -> Bool\n\nRemove vertex v and all its incident edges from the graph. Returns true if successful, false if vertex doesn't exist.\n\n⚠️  Performance Note: O(V + E) operation due to vertex renumbering requirement. ⚠️  Index Invalidation: Removes vertex v and renumbers vertices v+1, v+2, ... to v, v+1, ... This invalidates any external arrays indexed by vertex numbers.\n\nImplementation: More efficient than full reconstruction but still requires renumbering.\n\nExample\n\ng = build_core_graph([(1,2), (2,3), (1,3)]; directed=false)\nsuccess = remove_vertex!(g, 2)  # Returns true\n@assert num_vertices(g) == 2\n@assert has_edge(g, 1, 2)  # What was vertex 3 is now vertex 2\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.remove_vertex!-Union{Tuple{D}, Tuple{W}, Tuple{WeightedGraph{W, D}, Integer}} where {W, D}","page":"API Reference","title":"GraphCore.remove_vertex!","text":"remove_vertex!(g::WeightedGraph, v::Integer) -> Bool\n\nRemove vertex v and all its incident edges from the weighted graph. Returns true if successful, false if vertex doesn't exist.\n\n⚠️  Performance Note: O(V + E) operation due to vertex renumbering requirement. ⚠️  Index Invalidation: Removes vertex v and renumbers vertices v+1, v+2, ... to v, v+1, ... This invalidates any external arrays indexed by vertex numbers.\n\nImplementation: More efficient than full reconstruction but still requires renumbering.\n\nExample\n\ng = build_weighted_graph([(1,2,1.0), (2,3,2.0), (1,3,3.0)]; directed=false)\nsuccess = remove_vertex!(g, 2)  # Returns true\n@assert num_vertices(g) == 2\n@assert has_edge(g, 1, 2)  # What was vertex 3 is now vertex 2\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.set_edge_property!","page":"API Reference","title":"GraphCore.set_edge_property!","text":"set_edge_property!(g::PropertyGraphInterface{V,E,W}, edge_idx::Integer, prop::E) -> prop\n\nSet the property of edge at edge_idx to prop. Only available for mutable graph types.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.set_edge_weight!","page":"API Reference","title":"GraphCore.set_edge_weight!","text":"set_edge_weight!(g::PropertyGraphInterface{V,E,W}, directed_edge_idx::Integer, weight::W) -> Nothing\n\nSet the weight of the directed edge at directededgeidx to weight. Only available for mutable graph types.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.set_edge_weight!-Tuple{PropertyGraph{<:WeightedGraphInterface}, Vararg{Any}}","page":"API Reference","title":"GraphCore.set_edge_weight!","text":"set_edge_weight!(g::PropertyGraph{<:WeightedGraphInterface}, directed_edge_idx::Integer, weight) -> Nothing\n\nSet the weight of the directed edge at directededgeidx to weight. Only available when the base graph type supports weight mutation.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.set_vertex_property!","page":"API Reference","title":"GraphCore.set_vertex_property!","text":"set_vertex_property!(g::PropertyGraphInterface{V,E,W}, v::Integer, prop::V) -> prop\n\nSet the property of vertex v to prop. Only available for mutable graph types.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.symmetrize_edges-Tuple{Any}","page":"API Reference","title":"GraphCore.symmetrize_edges","text":"symmetrize_edges(edges) -> Vector{Tuple{Int,Int}}\n\nConvert canonical format to symmetric format (both directions).\n\nArguments\n\nedges: Vector of (u,v) tuples in canonical format\n\nReturns\n\nVector of edges with both directions included\n\nFormat Conversion\n\nInput: [(1,2), (2,3)] (canonical)\nOutput: [(1,2), (2,1), (2,3), (3,2)] (both directions)\n\nUse when you need to create a directed graph from undirected edges, or when working with algorithms that expect symmetric adjacency representations.\n\nExample\n\ncanonical = [(1,2), (2,3), (1,3)]\nsymmetric = GraphCore.symmetrize_edges(canonical)\n# Result: [(1,2), (2,1), (2,3), (3,2), (1,3), (3,1)]\n\nNote\n\nSelf-loops (u,u) are not duplicated to avoid redundancy.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.symmetrize_edges-Union{Tuple{W}, Tuple{Any, AbstractVector{W}}} where W","page":"API Reference","title":"GraphCore.symmetrize_edges","text":"symmetrize_edges(edges, weights::AbstractVector{W}) -> (symmetric_edges, symmetric_weights)\n\nConvert canonical format to symmetric, duplicating weights for both directions.\n\nArguments\n\nedges: Vector of (u,v) tuples in canonical format\nweights: Vector of weights corresponding to edges\n\nReturns\n\nTuple of (symmetricedges, symmetricweights)\n\nBehavior\n\nEach weight is duplicated for both directions of the edge. This creates a symmetric weight matrix suitable for undirected graph algorithms.\n\nExample\n\nedges = [(1,2), (2,3)]\nweights = [1.5, 2.0]\nsymmetric_edges, symmetric_weights = GraphCore.symmetrize_edges(edges, weights)\n# Result:\n# edges = [(1,2), (2,1), (2,3), (3,2)]\n# weights = [1.5, 1.5, 2.0, 2.0]\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.to_adj_graph-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.to_adj_graph","text":"to_adj_graph(g::GraphInterface) -> AdjGraph\n\nConvert any GraphInterface graph to an AdjGraph. Preserves the directedness of the original graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.to_core_graph-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.to_core_graph","text":"to_core_graph(g::GraphInterface) -> CoreGraph\n\nConvert any GraphInterface implementation to a CoreGraph. Preserves the directedness of the original graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.to_property_graph-Union{Tuple{E}, Tuple{V}, Tuple{GraphInterface, Vector{V}, Vector{E}}} where {V, E}","page":"API Reference","title":"GraphCore.to_property_graph","text":"to_property_graph(g::GraphInterface, vertex_props::Vector{V}, edge_props::Vector{E}) -> PropertyGraph{typeof(g),V,E}\n\nConvert any GraphInterface to a PropertyGraph with the given properties.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.to_property_graph-Union{Tuple{E}, Tuple{V}, Tuple{PropertyGraphInterface{V, E}, Type{AdjGraph}}} where {V, E}","page":"API Reference","title":"GraphCore.to_property_graph","text":"to_property_graph(g::PropertyGraphInterface{V,E}, ::Type{AdjGraph}) -> PropertyGraph{AdjGraph,V,E}\n\nConvert any PropertyGraphInterface to a PropertyGraph backed by AdjGraph. Preserves directedness and all properties.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.to_property_graph-Union{Tuple{PropertyGraphInterface{V, E}}, Tuple{E}, Tuple{V}} where {V, E}","page":"API Reference","title":"GraphCore.to_property_graph","text":"to_property_graph(g::PropertyGraphInterface{V,E}) -> PropertyGraph{CoreGraph,V,E}\n\nConvert any PropertyGraphInterface to a PropertyGraph wrapping a CoreGraph. Preserves directedness, vertex properties, and edge properties.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.to_weighted_adj_graph-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W","page":"API Reference","title":"GraphCore.to_weighted_adj_graph","text":"to_weighted_adj_graph(g::WeightedGraphInterface{W}) -> WeightedAdjGraph{W}\n\nConvert any WeightedGraphInterface to a WeightedAdjGraph. Preserves directedness and all weights.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.to_weighted_graph-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W","page":"API Reference","title":"GraphCore.to_weighted_graph","text":"to_weighted_graph(g::WeightedGraphInterface{W}) -> WeightedGraph{W}\n\nConvert any WeightedGraphInterface to a WeightedGraph. Preserves the directedness and all weights of the original graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.validate_interface-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.validate_interface","text":"validate_interface(g::GraphInterface)\n\nValidate that a graph type correctly implements the GraphInterface.\n\nPerforms comprehensive checks including:\n\nMethod availability for the graph type\nBasic functionality (if graph is non-empty)\nIndex range consistency\nDirected vs undirected edge count relationships\nIterator and view consistency\n\nUsage: Call during development to ensure interface compliance.\n\ng = build_core_graph(edges; directed=false)\nvalidate_interface(g)  # Throws descriptive errors if implementation is incorrect\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.vertex_properties","page":"API Reference","title":"GraphCore.vertex_properties","text":"vertex_properties(g::PropertyGraphInterface) -> iterator\n\nReturn an iterator over all vertex properties in order.\n\nExample\n\ng = build_property_graph(edges, [\"A\", \"B\", \"C\"], edge_props, 3)\nfor (i, prop) in enumerate(vertex_properties(g))\n    println(\"Vertex \", i, \" has property: \", prop)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.vertex_property","page":"API Reference","title":"GraphCore.vertex_property","text":"vertex_property(g::GraphInterface, v::Integer) -> V\n\nGet the property associated with vertex v.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.vertices-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.vertices","text":"vertices(g::GraphInterface) -> UnitRange{Int}\n\nReturn a range over all vertex indices.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graphs.inneighbors-Tuple{GraphInterface, Integer}","page":"API Reference","title":"Graphs.inneighbors","text":"Graphs.inneighbors(g::GraphInterface, v::Integer) -> Vector{Int}\n\nReturn vertices that have outgoing edges to vertex v.\n\n⚠️  Performance Warning: For directed graphs, this is O(V) operation.     Consider using a reverse adjacency structure for frequent in-neighbor queries.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graph-Construction","page":"API Reference","title":"Graph Construction","text":"","category":"section"},{"location":"api/#GraphCore.GraphConstruction.GraphBuilder","page":"API Reference","title":"GraphCore.GraphConstruction.GraphBuilder","text":"GraphBuilder{V,E,W}\n\nBuilder for constructing graphs incrementally. Optimized for fast additions during construction phase.\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.GraphConstruction.build_from_function-Tuple{Function, Function, Int64}","page":"API Reference","title":"GraphCore.GraphConstruction.build_from_function","text":"build_from_function(vertex_fn::Function, edge_fn::Function, nv::Int; directed=true)\n\nBuild a graph by calling vertexfn(i) for each vertex and edgefn(u,v) for potential edges.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_edge!-Tuple{GraphBuilder{Nothing, Nothing, Nothing}, Integer, Integer}","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(builder::GraphBuilder{Nothing,Nothing,Nothing}, u::Integer, v::Integer) -> Int32\n\nConvenience method for basic (unweighted, no properties) graph builders.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_edge!-Union{Tuple{W}, Tuple{E}, Tuple{V}, Tuple{GraphBuilder{V, E, W}, Integer, Integer}} where {V, E, W}","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(builder::GraphBuilder, u::Integer, v::Integer;\n          edge_property=nothing, weight=nothing) -> Int32\n\nAdd an edge with optional properties and weights using keyword arguments. Returns the edge index (1-based).\n\nExamples\n\n# Basic edge\nadd_edge!(builder, 1, 2)\n\n# Weighted edge\nadd_edge!(builder, 1, 2; weight=1.5)\n\n# Edge with property\nadd_edge!(builder, 1, 2; edge_property=\"connection\")\n\n# Both weight and property\nadd_edge!(builder, 1, 2; edge_property=\"highway\", weight=2.5)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.add_vertex!-Union{Tuple{GraphBuilder{V, E, W}}, Tuple{W}, Tuple{E}, Tuple{V}} where {V, E, W}","page":"API Reference","title":"GraphCore.add_vertex!","text":"add_vertex!(builder::GraphBuilder [, prop]) -> Int32\n\nAdd a vertex with optional property. Returns the vertex index. For non-property builders, prop should be omitted.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_graph-Union{Tuple{GraphBuilder{V, E, W}}, Tuple{W}, Tuple{E}, Tuple{V}} where {V, E, W}","page":"API Reference","title":"GraphCore.build_graph","text":"build_graph(builder::GraphBuilder{V,E,W}) -> GraphInterface\n\nConvert the builder to an optimized graph representation. Automatically chooses the most appropriate graph type among: CoreGraph, WeightedGraph{W}, PropertyGraph{G,V,E}.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_graph-Union{Tuple{G}, Tuple{GraphBuilder, Type{G}}} where G<:GraphInterface","page":"API Reference","title":"GraphCore.build_graph","text":"build_graph(builder::GraphBuilder, ::Type{G}) -> G\n\nConvert builder to a specific graph type G, where G can be one of: CoreGraph, WeightedGraph{W}, PropertyGraph, AdjGraph, WeightedAdjGraph{W}, PropertyAdjGraph. Note that the builder must be compatible with the target graph type. Also note that the order of the arguments, builder, graph type, is opposite to the usual order.\n\n\n\n\n\n","category":"method"},{"location":"api/#Conversions","page":"API Reference","title":"Conversions","text":"","category":"section"},{"location":"api/#GraphCore.Conversions.from_adjacency_matrix-Union{Tuple{W}, Tuple{G}, Tuple{Type{G}, AbstractMatrix{W}}} where {G<:GraphInterface, W<:Number}","page":"API Reference","title":"GraphCore.Conversions.from_adjacency_matrix","text":"from_adjacency_matrix(::Type{G}, adj_matrix::AbstractMatrix{W}) where {G<:GraphInterface,W} -> G\n\nConstruct a graph of appropriate type from an adjacency matrix.\n\nNon-zero entries in adj_matrix become edges with those weights\nIf directed is not specified, it is inferred from the symmetry of adj_matrix\n\nFor undirected graphs, adj_matrix should be symmetric.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Conversions.from_graphs_jl-Tuple{Graphs.AbstractGraph}","page":"API Reference","title":"GraphCore.Conversions.from_graphs_jl","text":"from_graphs_jl(g::Graphs.AbstractGraph; directed::Bool = Graphs.is_directed(g)) -> CoreGraph\n\nConvert a graph from the Graphs.jl ecosystem to a CoreGraph.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Conversions.from_weighted_graphs_jl-Union{Tuple{W}, Tuple{Graphs.AbstractGraph, AbstractVector{W}}} where W","page":"API Reference","title":"GraphCore.Conversions.from_weighted_graphs_jl","text":"from_weighted_graphs_jl(g::Graphs.AbstractGraph, weights::AbstractVector{W};\n                       directed::Bool = Graphs.is_directed(g)) -> WeightedGraph{W}\n\nConvert a weighted graph from the Graphs.jl ecosystem to a WeightedGraph.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Conversions.to_adjacency_matrix-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.Conversions.to_adjacency_matrix","text":"to_adjacency_matrix(g::GraphInterface) -> SparseMatrixCSC{W} where {W}\n\nConvert a graph to its adjacency matrix representation.\n\nFor directed graphs, the matrix is not required to be symmetric.\nFor undirected graphs, the matrix will be symmetric if the weights are.\nFor unweighted graphs, entries are 1 where edges exist.\nFor weighted graphs, entries are the edge weights (which are not necessarily symmetric even for undirected graphs).\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Conversions.to_graphs_jl-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.Conversions.to_graphs_jl","text":"to_graphs_jl(g::GraphInterface) -> Graphs.SimpleGraph or Graphs.SimpleDiGraph\n\nConvert a property graph to a Graphs.jl graph (losing properties and weights). Returns SimpleGraph for undirected graphs, SimpleDiGraph for directed graphs.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Conversions.to_weighted_graphs_jl-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W<:Number","page":"API Reference","title":"GraphCore.Conversions.to_weighted_graphs_jl","text":"to_weighted_graphs_jl(g::GraphInterface{V,E,W}) where {V,E,W} ->\n    SimpleWeightedGraphs.SimpleWeightedGraph or SimpleWeightedGraphs.SimpleWeightedDiGraph\n\nConvert a WeightedGraphInterface graph to a weighted SimpleWeightedGraphs.jl graph (preserving weights, losing other properties). Requires SimpleWeightedGraphs.jl package.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lattices","page":"API Reference","title":"Lattices","text":"","category":"section"},{"location":"api/#GraphCore.Lattices.HypercubicLattice","page":"API Reference","title":"GraphCore.Lattices.HypercubicLattice","text":"HypercubicLattice{D,T} <: GraphInterface\n\nA D-dimensional hypercubic lattice graph with side length of type T.\n\nType Parameters\n\nD::Int: Dimension of the lattice (1D=line, 2D=grid, 3D=cube, etc.)\nT<:Integer: Type for lattice size/coordinates\n\nStorage\n\nUses mathematical coordinate mapping instead of explicit edge storage. Memory usage: O(1) regardless of lattice size!\n\nCoordinate System\n\nVertices are numbered 1 to prod(sizes)\nCoordinates are 0-indexed: (0,0,...,0) to (size₁-1, size₂-1, ..., sizeD-1)\nPeriodic boundary conditions optional\n\nExamples\n\n# 2D grid: 10×10\nlattice_2d = HypercubicLattice{2,Int}((10, 10))\n\n# 3D cube: 5×5×5\nlattice_3d = HypercubicLattice{3,Int}((5, 5, 5))\n\n# 1D chain: 100 vertices\nlattice_1d = HypercubicLattice{1,Int}((100,))\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.Lattices.Chain1D-Tuple{Integer}","page":"API Reference","title":"GraphCore.Lattices.Chain1D","text":"Chain1D(length; periodic=false) -> HypercubicLattice{1,Int}\n\nCreate a 1D chain lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.Grid2D-Tuple{Integer, Integer}","page":"API Reference","title":"GraphCore.Lattices.Grid2D","text":"Grid2D(width, height; periodic=(false, false)) -> HypercubicLattice{2,Int}\n\nCreate a 2D grid lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.Grid3D-Tuple{Integer, Integer, Integer}","page":"API Reference","title":"GraphCore.Lattices.Grid3D","text":"Grid3D(width, height, depth; periodic=(false, false, false)) -> HypercubicLattice{3,Int}\n\nCreate a 3D cubic lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.coord_to_vertex-Union{Tuple{T}, Tuple{D}, Tuple{HypercubicLattice{D, T}, NTuple{D, T}}} where {D, T}","page":"API Reference","title":"GraphCore.Lattices.coord_to_vertex","text":"coord_to_vertex(g::HypercubicLattice{D,T}, coord::NTuple{D,T}) -> Int32\n\nConvert coordinates to vertex index using optimized arithmetic. Specialized for common dimensions with loop unrolling.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.degree-Union{Tuple{T}, Tuple{D}, Tuple{HypercubicLattice{D, T}, Integer}} where {D, T}","page":"API Reference","title":"GraphCore.Lattices.degree","text":"degree(g::HypercubicLattice{D,T}, v::Integer) -> Int32\n\nCompute degree without allocating neighbor list.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.has_vertex-Tuple{HypercubicLattice, Integer}","page":"API Reference","title":"GraphCore.Lattices.has_vertex","text":"Check if vertex exists.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.is_periodic-Tuple{HypercubicLattice}","page":"API Reference","title":"GraphCore.Lattices.is_periodic","text":"Check if the lattice has periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.lattice_dimension-Union{Tuple{HypercubicLattice{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"API Reference","title":"GraphCore.Lattices.lattice_dimension","text":"Get the dimensions of the lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.lattice_distance-Union{Tuple{T}, Tuple{D}, Tuple{HypercubicLattice{D, T}, Integer, Integer}} where {D, T}","page":"API Reference","title":"GraphCore.Lattices.lattice_distance","text":"lattice_distance(g::HypercubicLattice, u::Integer, v::Integer) -> Float64\n\nCompute the Manhattan distance between two vertices on the lattice. Accounts for periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.lattice_neighbors-Tuple{HypercubicLattice, Integer}","page":"API Reference","title":"GraphCore.Lattices.lattice_neighbors","text":"lattice_neighbors(g::HypercubicLattice, v::Integer) -> Vector{Int32}\n\nAlias for neighbor_indices with better name for lattice context.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.lattice_size-Tuple{HypercubicLattice}","page":"API Reference","title":"GraphCore.Lattices.lattice_size","text":"Get the size tuple of the lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.neighbor-Union{Tuple{T}, Tuple{D}, Tuple{HypercubicLattice{D, T}, Integer, Integer}} where {D, T}","page":"API Reference","title":"GraphCore.Lattices.neighbor","text":"neighbor(g::HypercubicLattice{D,T}, v::Integer, k::Integer) -> Int32\n\nGet the k-th neighbor of vertex v without allocating the full neighbor list. Optimized for accessing specific neighbors in computational loops.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.num_directed_edges-Tuple{HypercubicLattice}","page":"API Reference","title":"GraphCore.Lattices.num_directed_edges","text":"Number of directed edges (same as undirected for lattices).\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.vertex_to_coord-Union{Tuple{T}, Tuple{D}, Tuple{HypercubicLattice{D, T}, Integer}} where {D, T}","page":"API Reference","title":"GraphCore.Lattices.vertex_to_coord","text":"vertex_to_coord(g::HypercubicLattice{D,T}, v::Integer) -> NTuple{D,T}\n\nConvert vertex index to coordinates using optimized integer arithmetic. Fully inlined and branch-free for maximum performance.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.has_edge-Union{Tuple{T}, Tuple{D}, Tuple{HypercubicLattice{D, T}, Integer, Integer}} where {D, T}","page":"API Reference","title":"GraphCore.has_edge","text":"Check if edge exists between two vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.is_directed_graph-Tuple{HypercubicLattice}","page":"API Reference","title":"GraphCore.is_directed_graph","text":"Lattices are always undirected.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.neighbor_indices-Union{Tuple{T}, Tuple{D}, Tuple{HypercubicLattice{D, T}, Integer}} where {D, T}","page":"API Reference","title":"GraphCore.neighbor_indices","text":"neighbor_indices(g::HypercubicLattice{D,T}, v::Integer) -> StaticVector{2D,Int32}\n\nCompute neighbors using optimized coordinate arithmetic. Returns a stack-allocated vector for maximum performance.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.num_edges-Tuple{HypercubicLattice}","page":"API Reference","title":"GraphCore.num_edges","text":"Number of edges in the lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.num_vertices-Tuple{HypercubicLattice}","page":"API Reference","title":"GraphCore.num_vertices","text":"Number of vertices in the lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.PowerOfTwoLattice","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.PowerOfTwoLattice","text":"PowerOfTwoLattice{D} <: GraphInterface\n\nUltra-fast D-dimensional hypercubic lattice where all sizes are powers of 2. Uses bit operations for coordinate conversion and neighbor lookup.\n\nRestrictions\n\nD ≤ 5 (keeps neighbor tuples reasonable)\nAll sizes must be powers of 2: 2, 4, 8, 16, 32, 64, 128, ...\nPeriodic boundary conditions (makes bit operations clean)\n\nType Parameters\n\nD::Int: Dimension (1 ≤ D ≤ 5)\n\nExamples\n\n# 2D: 16×32 grid (2^4 × 2^5)\ng2d = P2Grid2D(4, 5)  # log₂ sizes\n\n# 3D: 8×8×16 cube (2^3 × 2^3 × 2^4)\ng3d = P2Grid3D(3, 3, 4)\n\n# 1D: 64-element chain (2^6)\ng1d = P2Chain1D(6)\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.PowerOfTwoLattices.P2Chain1D-Tuple{Integer}","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.P2Chain1D","text":"1D chain: size = 2^log_size\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.P2Grid2D-Tuple{Integer, Integer}","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.P2Grid2D","text":"2D grid: sizes = 2^logwidth × 2^logheight\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.P2Grid3D-Tuple{Integer, Integer, Integer}","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.P2Grid3D","text":"3D cube: sizes = 2^logwidth × 2^logheight × 2^log_depth\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices._find_local_edge_index-Union{Tuple{D}, Tuple{PowerOfTwoLattice{D}, Any, Any}} where D","page":"API Reference","title":"GraphCore.PowerOfTwoLattices._find_local_edge_index","text":"Helper function to find which local edge connects two adjacent coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.coord_to_vertex-Union{Tuple{D}, Tuple{PowerOfTwoLattice{D}, NTuple{D, Int32}}} where D","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.coord_to_vertex","text":"Convert coordinates to vertex using bit operations.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.degree-Union{Tuple{D}, Tuple{PowerOfTwoLattice{D}, Integer}} where D","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.degree","text":"Degree is always 2*D for power-of-2 periodic lattices.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.directed_edge_index-Union{Tuple{D}, Tuple{PowerOfTwoLattice{D}, Integer, Integer}} where D","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.directed_edge_index","text":"directed_edge_index(g::PowerOfTwoLattice{D}, v::Integer, i::Integer) -> Int32\n\nGet the i-th directed edge index from vertex v. For undirected lattices, this is the same as edge_index.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.directed_edge_indices-Union{Tuple{D}, Tuple{PowerOfTwoLattice{D}, Integer}} where D","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.directed_edge_indices","text":"directed_edge_indices(g::PowerOfTwoLattice{D}, v::Integer) -> NTuple{2D,Int32}\n\nGet all directed edge indices from vertex v. For undirected lattices, this is the same as edge_indices.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.direction_to_local_edge-Tuple{Integer, Symbol, Integer}","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.direction_to_local_edge","text":"direction_to_local_edge(dim::Integer, direction::Symbol, D::Integer) -> Int32\n\nConvert dimension and direction to local edge index.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.edge_index-Union{Tuple{D}, Tuple{PowerOfTwoLattice{D}, Integer, Integer}} where D","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.edge_index","text":"edge_index(g::PowerOfTwoLattice{D}, v::Integer, i::Integer) -> Int32\n\nGet the i-th edge index from vertex v. For power-of-2 lattices, edges are ordered by dimension: dim1-, dim1+, dim2-, dim2+, ...\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.edge_indices-Union{Tuple{D}, Tuple{PowerOfTwoLattice{D}, Integer}} where D","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.edge_indices","text":"edge_indices(g::PowerOfTwoLattice{D}, v::Integer) -> NTuple{2D,Int32}\n\nGet all edge indices from vertex v as a tuple. Returns edges in order: dim1-, dim1+, dim2-, dim2+, dim3-, dim3+, ...\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.edge_to_vertices-Union{Tuple{D}, Tuple{PowerOfTwoLattice{D}, Integer}} where D","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.edge_to_vertices","text":"edge_to_vertices(g::PowerOfTwoLattice{D}, edge_idx::Integer) -> Tuple{Int32,Int32}\n\nConvert edge index back to the two vertices it connects. Returns (smallervertex, largervertex) for consistency.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.lattice_dimension-Union{Tuple{PowerOfTwoLattice{D}}, Tuple{D}} where D","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.lattice_dimension","text":"Get lattice dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.lattice_log_size-Tuple{PowerOfTwoLattice}","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.lattice_log_size","text":"Get log₂ sizes.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.lattice_size-Tuple{PowerOfTwoLattice}","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.lattice_size","text":"Get actual sizes.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.local_edge_to_direction-Tuple{Integer, Integer}","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.local_edge_to_direction","text":"local_edge_to_direction(local_edge::Integer, D::Integer) -> (dim, direction)\n\nConvert local edge index to dimension and direction. Returns (dimension, direction) where direction is :negative or :positive.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.neighbor-Union{Tuple{D}, Tuple{PowerOfTwoLattice{D}, Integer, Integer}} where D","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.neighbor","text":"Get k-th neighbor directly without computing all neighbors. Order: dim1-, dim1+, dim2-, dim2+, ...\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.vertex_to_coord-Union{Tuple{D}, Tuple{PowerOfTwoLattice{D}, Integer}} where D","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.vertex_to_coord","text":"Convert vertex to coordinates using bit operations.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.find_edge_index-Union{Tuple{D}, Tuple{PowerOfTwoLattice{D}, Integer, Integer}} where D","page":"API Reference","title":"GraphCore.find_edge_index","text":"find_edge_index(g::PowerOfTwoLattice{D}, u::Integer, v::Integer) -> Int32\n\nFind the edge index for edge (u,v). Uses the smaller vertex as the base and computes which local edge it is.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.neighbor_indices-Union{Tuple{D}, Tuple{PowerOfTwoLattice{D}, Integer}} where D","page":"API Reference","title":"GraphCore.neighbor_indices","text":"Return neighbors as a statically-sized tuple for maximum performance. Each dimension contributes exactly 2 neighbors (periodic boundaries).\n\n\n\n\n\n","category":"method"},{"location":"docindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"docindex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"#GraphCore.jl","page":"Home","title":"GraphCore.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A high-performance, type-safe graph library for Julia with a focus on efficiency, flexibility, and ease of use.","category":"page"},{"location":"#Design-Philosophy","page":"Home","title":"Design Philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphCore.jl is designed around three key principles:","category":"page"},{"location":"#**Performance-Oriented-Design**","page":"Home","title":"Performance-Oriented Design","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CSR Storage: Compressed Sparse Row format for cache-efficient traversal\nType Specialization: Parametric types enable compiler optimizations and zero-cost abstractions\nEfficient Indexing: Direct O(1) access patterns with Int32 indexing for memory efficiency\nMinimal Overhead: Compact memory layouts optimized for common graph operations","category":"page"},{"location":"#**Flexible-Storage-Options**","page":"Home","title":"Flexible Storage Options","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multiple Representations: CSR format (CoreGraph) for static analysis, adjacency lists (AdjGraph) for dynamic operations\nUnified Interface: All graph types implement the same GraphInterface for consistent usage\nProperty Integration: Built-in support for type-safe vertex and edge properties\nExternal Array Support: Stable indexing schemes for user-managed data arrays","category":"page"},{"location":"#**Type-Safety-and-Reliability**","page":"Home","title":"Type Safety and Reliability","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Compile-Time Checking: Parametric types catch common errors during compilation\nClear Data Ownership: Explicit separation between graph structure, weights, and properties  \nStable Indexing: Consistent edge/vertex indices for reliable external array management\nComprehensive Validation: Input checking and well-defined method contracts","category":"page"},{"location":"#Architecture-Overview","page":"Home","title":"Architecture Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphCore.jl\n├── GraphInterface      # Abstract interface definition\n├── CoreGraph           # CSR-based graphs (static, high-performance)\n├── AdjGraph            # Adjacency list graphs (dynamic, mutable)\n└── GraphConstruction   # Builder patterns for graph construction","category":"page"},{"location":"#Core-Types-and-Submodules","page":"Home","title":"Core Types and Submodules","text":"","category":"section"},{"location":"#**Main-Module:-GraphCore**","page":"Home","title":"Main Module: GraphCore","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using GraphCore\n\n# Core functionality (always available)\nedge_list = [(1,2), (2,3), (3,1)]\nweights = [0.5, 1.1, 0.2]\nvertex_props = [\"A\", \"B\", \"C\"]\nedge_props = [1,2,3]\ng = build_core_graph(edge_list; directed=true)\nwg = build_weighted_graph(edge_list, weights; directed=false)\npg = build_property_graph(edge_list, vertex_props, edge_props; directed=true)","category":"page"},{"location":"#**Available-Submodules**","page":"Home","title":"Available Submodules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using GraphCore.Conversions        # ✅ Type conversions and Graphs.jl interop\nusing GraphCore.GraphConstruction  # ✅ Advanced construction patterns  \nusing GraphCore.Lattices           # ✅ Special graph structures\nusing GraphCore.PowerOfTwoLattices # ✅ Optimized power-of-two lattices\n\n# Conversion utilities (e.g.- to and from Graphs.jl types)\ngraphs_g = from_graphs_jl(simple_graph)\nour_graph = to_graphs_jl(core_graph)\n\n# Graph construction helpers  \nbuilder = WeightedGraphBuilder(Float64; directed=false)\nadd_edge!(builder, 1, 2, weight=0.9)\ngraph = build_graph(builder)\n\n# Special graph structures\nlattice_3d = HypercubicLattice{3,Int}((5, 5, 5))\nlattice_2d = PowerOfTwoLattice(4,5) # size 2^4 x 2^5 = 16 x 32","category":"page"},{"location":"#Core-Graph-Types","page":"Home","title":"Core Graph Types","text":"","category":"section"},{"location":"#**CoreGraph{D}**-High-Performance-Static-Graphs","page":"Home","title":"CoreGraph{D} - High-Performance Static Graphs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# CSR (Compressed Sparse Row) storage with efficient mutations\ng = build_graph(CoreGraph, edge_list; directed=true)\nadd_edge!(g, u, v)          # ✅ Efficient in-place mutations\nremove_vertex!(g, v)        # ✅ Dynamic modifications  \n# ✅ O(1) neighbor access\n# ✅ Cache-efficient iteration  \n# ✅ Minimal memory overhead\n# ✅ Supports efficient mutations","category":"page"},{"location":"#**WeightedGraph{W,D}**-Weighted-Static-Graphs","page":"Home","title":"WeightedGraph{W,D} - Weighted Static Graphs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# CSR with parallel weight arrays, with mutation support\ng = build_graph(WeightedGraph{Float64}, edge_list; weights=weights, directed=true)\nadd_edge!(g, u, v, weight)  # ✅ Add weighted edges efficiently\n# ✅ Type-safe weights (W can be any numeric type)\n# ✅ Directional weights even for undirected graphs\n# ✅ Same performance as CoreGraph\n# ✅ Supports efficient mutations","category":"page"},{"location":"#**PropertyGraph{G,V,E}**-Graphs-with-Properties","page":"Home","title":"PropertyGraph{G,V,E} - Graphs with Properties","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Wrapper around any base graph type\ng = PropertyGraph(core_graph, vertex_props, edge_props)\n# ✅ Type-safe properties\n# ✅ Zero overhead delegation\n# ✅ Works with any underlying graph type\n# ⚠️  Mutation performance depends on underlying type","category":"page"},{"location":"#**AdjGraph{D}**-Dynamic-Mutable-Graphs","page":"Home","title":"AdjGraph{D} - Dynamic Mutable Graphs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Vector{Vector{Int32}} storage\ng = build_adj_graph(edge_list; directed=true)\nadd_edge!(g, u, v)      # ✅ O(1) mutations\nremove_vertex!(g, v)    # ✅ Dynamic modification\n# ✅ Efficient for construction and modification\n# ❌ Higher memory overhead than CSR","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"#**Safety-First-Performance**","page":"Home","title":"Safety-First Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphCore implements Julia-idiomatic bounds checking for all vertex and edge access:","category":"page"},{"location":"","page":"Home","title":"Home","text":"g = build_core_graph([(1,2), (2,3), (1,3)]; directed=false)\n\n# Safe by default - throws BoundsError for invalid vertices\nneighbor_indices(g, 10)      # BoundsError: vertex 10 out of bounds [1,3]\nhas_edge(g, 1, 10)          # BoundsError: vertex 10 out of bounds [1,3]\nfind_directed_edge_index(g, 10, 1)  # BoundsError: vertex 10 out of bounds [1,3]\n\n# Optimizable for performance-critical code\nfunction hot_path_algorithm(g, vertices)\n    for v in vertices\n        # @inbounds disables bounds checking when you know access is safe\n        neighbors = @inbounds neighbor_indices(g, v)\n        edge_idx = @inbounds find_directed_edge_index(g, v, first(neighbors))\n        # ... fast inner loop operations\n    end\nend\n\n# Global bounds checking control\n# --check-bounds=no    # Disable all bounds checking (unsafe but maximum speed)\n# --check-bounds=yes   # Enable all bounds checking (safe, default)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Safety guarantees:","category":"page"},{"location":"","page":"Home","title":"Home","text":"✅ All vertex/edge access is bounds-checked by default\n✅ Invalid access throws descriptive BoundsError exceptions\n✅ @inbounds provides escape hatch for performance-critical sections\n✅ No performance penalty when bounds checking is disabled globally","category":"page"},{"location":"#**Dual-Indexing-System**","page":"Home","title":"Dual Indexing System","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphCore provides two complementary indexing schemes for maximum flexibility:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Undirected edge indices (1:num_edges)\nedge_capacities = Vector{Float64}(undef, num_edges(g))\nedge_idx = find_edge_index(g, u, v)  # Same result for (u,v) and (v,u)\n\n# Directed edge indices (1:num_directed_edges)  \nedge_flows = Vector{Float64}(undef, num_directed_edges(g))\nflow_uv = edge_flows[find_directed_edge_index(g, u, v)]\nflow_vu = edge_flows[find_directed_edge_index(g, v, u)]  # Different index","category":"page"},{"location":"#**Informative-Edge-Iteration**","page":"Home","title":"Informative Edge Iteration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphCore provides helpful display for edge iterators to make debugging easier:","category":"page"},{"location":"","page":"Home","title":"Home","text":"g = build_graph(CoreGraph, [(1,2), (2,3), (1,3)]; directed=false)\n\n# Edge iterators show helpful information\nprintln(edges(g))\n# Output: \"EdgeIterator over 3 edges from CoreGraph (undirected): (1, 2), (1, 3), (2, 3)\"\n\nprintln(all_directed_edges(g))  \n# Output: \"EdgeIterator over 6 directed edges from CoreGraph (undirected): (1, 2), (1, 3), (2, 1), ...\"\n\n# Empty graphs show clearly\nempty_g = build_graph(CoreGraph, Tuple{Int,Int}[]; n=3, directed=false) \nprintln(edges(empty_g))\n# Output: \"EdgeIterator over 0 edges from CoreGraph (undirected)\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"The display shows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Edge count: Total number of edges the iterator will yield\nGraph type: Whether it's CoreGraph, WeightedGraph, AdjGraph, etc.\nDirectedness: Whether the underlying graph is directed or undirected  \nPreview: First few edges to give you a sense of the data\nIterator type: Clear distinction between edges() and all_directed_edges()","category":"page"},{"location":"#**Seamless-Conversions**","page":"Home","title":"Seamless Conversions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Idiomatic Julia constructors for easy conversion\ncore_g = CoreGraph(adj_graph)           # Any graph → CSR format\nweighted_g = WeightedGraph(core_g)      # Add weight support  \nadj_g = AdjGraph(weighted_g)            # Convert to adjacency lists\n\n# Type-safe conversions with directedness enforcement\ndirected_g = CoreGraph{true}(undirected_g)   # Throws error - prevents mistakes\nundirected_g = CoreGraph{false}(directed_g)  # Throws error - type safety\n\n# Construction workflow\nusing GraphCore.GraphConstruction\nbuilder = WeightedGraphBuilder(Float64; directed=false)\n# ... build graph incrementally ...\nanalysis_graph = build_graph(builder, CoreGraph)    # → CSR for analysis\nmutable_graph = build_graph(builder, AdjGraph)      # → Adj lists for mutations\n\n# Graphs.jl interop\nusing GraphCore.Conversions\nour_graph = from_graphs_jl(simple_graph)\ngraphs_jl_g = to_graphs_jl(core_graph)","category":"page"},{"location":"#Usage-Examples","page":"Home","title":"Usage Examples","text":"","category":"section"},{"location":"#Basic-Graph-Construction","page":"Home","title":"Basic Graph Construction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using GraphCore\n\n# Simple unweighted graph - unified interface\nedge_list = [(1,2), (2,3), (1,3)]\ng = build_graph(CoreGraph, edge_list; directed=false)\n\n# Weighted graph - type-safe construction\nweights = [1.0, 2.0, 1.5]\nwg = build_graph(WeightedGraph{Float64}, edge_list; weights=weights, directed=false)\n\n# Property graph\nvertex_names = [\"Alice\", \"Bob\", \"Charlie\"]  \nedge_types = [\"friend\", \"colleague\", \"family\"]\npg = build_graph(PropertyGraph{CoreGraph,String,String}, edge_list; \n                 vertex_properties=vertex_names, edge_properties=edge_types, directed=false)\n\n# Easy conversions between types\nadj_g = AdjGraph(g)          # Convert to adjacency list\ncore_g = CoreGraph(adj_g)    # Convert back to CSR","category":"page"},{"location":"#Incremental-Construction","page":"Home","title":"Incremental Construction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Using GraphBuilder for dynamic construction\nusing GraphCore.GraphConstruction\n\nbuilder = WeightedGraphBuilder(Float64; directed=true)\n\nadd_vertex!(builder)  # Returns vertex index\nadd_edge!(builder, 1, 2; weight=1.5)\nadd_edge!(builder, 2, 3; weight=2.0)\n\n# Convert to optimized storage when done\ngraph = build_graph(builder)","category":"page"},{"location":"#Efficient-Algorithms","page":"Home","title":"Efficient Algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# O(1) neighbor and weight access\nfunction dijkstra_step(g, distances, v)\n    for (neighbor, weight) in neighbor_weights(g, v)\n        new_dist = distances[v] + weight\n        if new_dist < distances[neighbor]\n            distances[neighbor] = new_dist\n        end\n    end\nend\n\n# O(1) index access during neighbor iteration\nfor (i, neighbor) in enumerate(neighbor_indices(g, v))\n    edge_idx = edge_index(g, v, i)           # O(1) - no search!\n    weight = edge_weights(g, v)[i]           # O(1) - direct access\nend\n\n# External property arrays with stable indexing\nedge_flows = zeros(num_directed_edges(g))\nfor (u, v) in edges(g)\n    flow_idx = find_directed_edge_index(g, u, v)\n    edge_flows[flow_idx] = compute_flow(u, v)\nend","category":"page"},{"location":"#Mutable-Graph-Operations","page":"Home","title":"Mutable Graph Operations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# All graph types support efficient mutations\ng = build_graph(CoreGraph, initial_edges; directed=false)\nwg = build_graph(WeightedGraph{Float64}, initial_edges; weights=weights, directed=false)\n\n# Efficient mutations on all types\nnew_vertex = add_vertex!(g)               # O(1) vertex addition\nedge_added = add_edge!(g, 1, new_vertex)  # Efficient edge addition\nadd_edge!(wg, 1, 2, 3.5)                 # Add weighted edge\n\n# Inspect your changes with informative edge iterators\nprintln(edges(g))  # Shows: \"EdgeIterator over 4 edges from CoreGraph (undirected): (1,2), (1,3), ...\"\n\n# For property graphs - choose the right base type\npg_core = build_graph(PropertyGraph{CoreGraph,String,String}, edges; \n                      vertex_properties=vprops, edge_properties=eprops)\nadd_edge!(pg_core, u, v, \"new_edge\")     # Efficient with CoreGraph base\n\n# Convert if you need different mutation characteristics  \npg_adj = PropertyGraph(AdjGraph(pg_core.graph), pg_core.vertex_properties, pg_core.edge_properties)","category":"page"},{"location":"#Performance-Best-Practices","page":"Home","title":"Performance Best Practices","text":"","category":"section"},{"location":"#**When-to-Use-@inbounds**","page":"Home","title":"When to Use @inbounds","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Use @inbounds in performance-critical inner loops where you can guarantee safety:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# ✅ SAFE: After explicit validation\nfunction safe_fast_algorithm(g, valid_vertices)\n    # Pre-validate all vertices are in bounds\n    @assert all(has_vertex(g, v) for v in valid_vertices)\n    \n    for v in valid_vertices\n        # Safe to use @inbounds - we validated vertices above\n        neighbors = @inbounds neighbor_indices(g, v)\n        for (i, neighbor) in enumerate(neighbors)\n            edge_idx = @inbounds directed_edge_index(g, v, i)\n            # Fast operations...\n        end\n    end\nend\n\n# ✅ SAFE: With explicit bounds checking\nfunction process_edge_if_exists(g, u, v)\n    @boundscheck begin\n        has_vertex(g, u) || return nothing\n        has_vertex(g, v) || return nothing\n    end\n    # Safe to use @inbounds after validation\n    return @inbounds find_directed_edge_index(g, u, v)\nend\n\n# ❌ UNSAFE: Don't use @inbounds on user input\nfunction unsafe_example(g, user_vertex)\n    # DON'T DO THIS - user_vertex might be out of bounds!\n    neighbors = @inbounds neighbor_indices(g, user_vertex)  # Potential crash\nend","category":"page"},{"location":"#**Bounds-Checking-Control**","page":"Home","title":"Bounds Checking Control","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# For maximum performance in production (after thorough testing):\n# julia --check-bounds=no script.jl\n\n# For development and debugging (default):\n# julia --check-bounds=yes script.jl\n\n# Selective optimization in functions:\nfunction hot_path(g, vertices)\n    # Bounds checking here for user input\n    for v in vertices\n        has_vertex(g, v) || continue\n        \n        # @inbounds in inner loop for speed\n        neighbors = @inbounds neighbor_indices(g, v)\n        process_neighbors(neighbors)\n    end\nend","category":"page"},{"location":"#**Memory-and-Cache-Optimization**","page":"Home","title":"Memory and Cache Optimization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# ✅ GOOD: Use CoreGraph for analysis workloads\nanalysis_graph = build_core_graph(edges; directed=false)\n\n# ✅ GOOD: Batch operations for cache efficiency\nfunction efficient_traversal(g)\n    for v in vertices(g)\n        neighbors = neighbor_indices(g, v)  # O(1) view, cache-friendly\n        for neighbor in neighbors\n            # Process all neighbors together\n        end\n    end\nend\n\n# ❌ AVOID: Repeated edge lookups\nfunction inefficient_example(g, pairs)\n    for (u, v) in pairs\n        if has_edge(g, u, v)  # O(degree) lookup each time\n            # This is slow for large graphs\n        end\n    end\nend\n\n# ✅ BETTER: Pre-compute or batch process\nfunction efficient_edge_checking(g, pairs)\n    edge_set = Set{Tuple{Int,Int}}()\n    for (u, v) in edges(g)\n        push!(edge_set, (u, v))\n        push!(edge_set, (v, u))  # For undirected graphs\n    end\n    \n    for (u, v) in pairs\n        if (u, v) in edge_set  # O(1) lookup\n            # Fast processing\n        end\n    end\nend","category":"page"},{"location":"#Performance-Characteristics","page":"Home","title":"Performance Characteristics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Operation CoreGraph WeightedGraph AdjGraph PropertyGraph PropertyAdjGraph\nNeighbor Access O(1), ~2ns O(1), ~2ns O(1), ~2ns O(1), ~2ns O(1), ~2ns\nEdge Lookup O(degree), ~3ns O(degree), ~3ns O(degree), ~3ns O(degree), ~3ns O(degree), ~3ns\nBounds Checking ✅ @boundscheck ✅ @boundscheck ✅ @boundscheck ✅ @boundscheck ✅ @boundscheck\n@inbounds Safe ✅ Performance ✅ Performance ✅ Performance ✅ Performance ✅ Performance\nAdd Edge ✅ Efficient ✅ Efficient O(1) ✅ Efficient* O(1)\nRemove Edge ✅ Efficient ✅ Efficient O(degree) ✅ Efficient* O(degree)\nAdd Vertex ✅ O(1) ✅ O(1) O(1) ✅ O(1)* O(1)\nRemove Vertex ✅ Efficient ✅ Efficient O(V+E) ✅ Efficient* O(V+E)\nInput Validation ✅ Comprehensive ✅ Comprehensive ✅ Basic ✅ Comprehensive ✅ Basic\nMemory Overhead Minimal +weights +pointers +properties +properties+pointers\nCache Efficiency Excellent Excellent Good Excellent** Good**","category":"page"},{"location":"","page":"Home","title":"Home","text":"*PropertyGraph inherits mutation performance from its underlying graph type. **PropertyGraph inherits the performance characteristics of its underlying graph type.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Performance notes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Timings are median benchmarks on typical graphs (Petersen graph: 10 vertices, 15 edges)\nAll operations benefit from @inbounds optimizations in performance-critical loops\nBounds checking can be disabled globally with --check-bounds=no for maximum speed\nEdge lookup time depends on vertex degree but benefits from cache-efficient CSR layout","category":"page"},{"location":"#Graphs.jl-Compatibility","page":"Home","title":"Graphs.jl Compatibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphCore implements the AbstractGraph interface for seamless integration:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Graphs\nusing GraphCore\nusing GraphCore.Conversions\n\ng = build_core_graph(edge_list; directed=false)\n\n# Standard Graphs.jl functions work\nnv(g)                    # Number of vertices  \nne(g)                    # Number of edges\noutneighbors(g, v)       # Neighbor list\nis_directed(g)           # Check directedness\n\n# Algorithm compatibility\nshortest_paths = dijkstra_shortest_paths(g, source)\n\n# Convert to/from Graphs.jl types\nsimple_g = to_graphs_jl(g)\nour_g = from_graphs_jl(simple_g)","category":"page"},{"location":"#Design-Decisions-and-Trade-offs","page":"Home","title":"Design Decisions & Trade-offs","text":"","category":"section"},{"location":"#Why-Julia-Idiomatic-Bounds-Checking?","page":"Home","title":"Why Julia-Idiomatic Bounds Checking?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Safety First: All vertex/edge access is safe by default with clear error messages\nPerformance When Needed: @inbounds provides zero-cost optimization for validated access\nFamiliar Pattern: Follows Julia's array indexing conventions that users already know\nTrade-off: Small overhead in tight loops, but eliminates silent corruption bugs","category":"page"},{"location":"#Why-CSR-for-CoreGraph?","page":"Home","title":"Why CSR for CoreGraph?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Cache Efficiency: Neighbors stored contiguously in memory\nSpace Efficiency: No pointer overhead compared to adjacency lists  \nIndex Stability: External arrays remain valid during graph analysis\nEfficient Mutations: Direct array manipulation preserves CSR benefits\nTrade-off: More complex mutation algorithms, but maintains performance characteristics","category":"page"},{"location":"#Why-Dual-Indexing?","page":"Home","title":"Why Dual Indexing?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Flexibility: Support both shared and directional edge properties\nPerformance: O(1) access during iteration via edge_index(g, v, i)\nCorrectness: Clear separation between undirected and directed semantics\nTrade-off: Slightly more complex API, but with clear documentation","category":"page"},{"location":"#Why-Multiple-Graph-Types?","page":"Home","title":"Why Multiple Graph Types?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Specialization: Each type optimized for its use case\nComposability: PropertyGraph wraps any base type\nMigration Path: Easy conversion between representations\nTrade-off: More types to learn, but unified interface","category":"page"}]
}
