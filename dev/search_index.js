var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Core-Types-and-Functions","page":"API Reference","title":"Core Types and Functions","text":"","category":"section"},{"location":"api/#GraphCore.GraphCore","page":"API Reference","title":"GraphCore.GraphCore","text":"GraphCore\n\nA module for graph-based computations and algorithms.\n\n\n\n\n\n","category":"module"},{"location":"api/#GraphCore.AdjGraph","page":"API Reference","title":"GraphCore.AdjGraph","text":"AdjGraph{D} <: GraphInterface\n\nDynamic graph using adjacency lists (Vector{Vector{Int32}}) for neighbor storage. Optimized for structural mutations with reasonable query performance.\n\nType Parameters\n\nD::Bool: Directedness flag (true = directed, false = undirected)\n\nFields (Internal - Access via interface methods)\n\nneighbors::Vector{Vector{Int32}}: Per-vertex neighbor lists\nneighbor_to_edge::Vector{Vector{Int32}}: Maps neighbor positions to edge indices (undirected only)\nnum_edges::Int32: Number of (undirected) edges\n\nConstruction\n\nUse build_adj_graph() or build_graph(AdjGraph, ...) for safe construction:\n\n# Basic construction\nedges = [(1,2), (2,3), (1,3)]\ng = build_adj_graph(edges; directed=false)\n\n# Direct type construction with mutation\ng = build_graph(AdjGraph, edges; directed=false)\nadd_edge!(g, 4, 1)  # Efficient dynamic modification\n\nMemory Layout Example\n\nFor graph with edges [(1,2), (2,3), (1,3)], undirected:\n\nneighbors = [[2,3], [1,3], [1,2]]           # Vertex 1: neighbors 2,3; Vertex 2: neighbors 1,3, etc.\nneighbor_to_edge = [[1,3], [1,2], [3,2]]    # Maps: v1's neighbor 2→edge 1, v1's neighbor 3→edge 3, etc.\n\nPerformance Notes\n\nBest for: Dynamic graphs with frequent add/remove operations\nMutations: O(1) additions, O(degree) removals\nMemory: ~16-24 bytes per directed edge (vector overhead + pointers)\nCache: Good for sparse graphs, less optimal for dense graphs\n\nMutation Support\n\n# Efficient dynamic operations\nnew_vertex = add_vertex!(g)           # O(1) - just adds empty vectors\nedge_idx = add_edge!(g, u, v)         # O(1) amortized - vector push\nsuccess = remove_edge!(g, u, v)       # O(degree) - find and remove\nsuccess = remove_vertex!(g, v)        # O(V + incident edges) - updates all references\n\n# ⚠️ Warning: Removals may invalidate edge indices\n# External arrays indexed by edges will become inconsistent\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.AdjGraph-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.AdjGraph","text":"AdjGraph(g::GraphInterface) -> AdjGraph\nAdjGraph{D}(g::GraphInterface) -> AdjGraph{D}\n\nConstructor-based conversion from any GraphInterface to AdjGraph. The type-safe variant validates directedness matching.\n\nSee to_adj_graph for detailed documentation.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.CoreGraph","page":"API Reference","title":"GraphCore.CoreGraph","text":"CoreGraph{D} <: GraphInterface\n\nHigh-performance graph using Compressed Sparse Row (CSR) storage format.\n\nType Parameters\n\nD::Bool: Directedness flag (true = directed, false = undirected)\n\nFields (Internal - Access via interface methods)\n\nvertex_offsets::Vector{Int32}: CSR row pointers (length = nv + 1)\nneighbors::Vector{Int32}: Flattened neighbor lists\nneighbor_to_edge::Vector{Int32}: Maps neighbor positions to undirected edge indices (undirected only)\nnum_edges::Int32: Number of (undirected) edges\n\nConstruction\n\nUse build_core_graph() or build_graph(CoreGraph, ...) for safe construction:\n\n# Basic construction\nedges = [(1,2), (2,3), (1,3)]\ng = build_core_graph(edges; directed=false)\n\n# With validation disabled (faster, but unsafe)\ng = build_graph(CoreGraph, edges; directed=false, validate=false)\n\nMemory Layout Example\n\nFor graph with edges [(1,2), (2,3), (1,3)], undirected:\n\nvertex_offsets = [1, 3, 6, 8]       # Vertex 1: neighbors[1:2], Vertex 2: neighbors[3:5], etc.\nneighbors = [2, 3, 1, 3, 1, 2]      # Flattened: [neighbors(1), neighbors(2), neighbors(3)]\nneighbor_to_edge = [1, 3, 1, 2, 3, 2] # Maps each neighbor to its edge index\n\nPerformance Notes\n\nBest for: Static graphs with frequent neighbor access\nAvoid for: Graphs requiring frequent structural modifications\nMemory: ~12-16 bytes per directed edge (depending on architecture)\nCache: Excellent locality for neighbor iteration\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.CoreGraph-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.CoreGraph","text":"CoreGraph(g::GraphInterface) -> CoreGraph\nCoreGraph{D}(g::GraphInterface) -> CoreGraph{D}\n\nConstructor-based conversion from any GraphInterface to CoreGraph. The type-safe variant validates directedness matching.\n\nSee to_core_graph for detailed documentation.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.EdgeIterator","page":"API Reference","title":"GraphCore.EdgeIterator","text":"EdgeIterator{G<:GraphInterface,D}\nEdgeIterator(graph::G, D::Bool) -> EdgeIterator{G,D}\n\nUnified iterator over edges in a graph, yielding (source, target) tuples.\n\nType Parameters\n\nG<:GraphInterface: The graph type\nD::Bool: Direction mode\nD=false (undirected mode): For directed graphs yields each edge once as (u,v).                             For undirected graphs yields each edge once in canonical form (u,v) where u ≤ v.\nD=true (directed mode): For directed graphs yields each edge once as (u,v).                           For undirected graphs yields each edge twice as (u,v) and (v,u).\n\nSee also: edges, all_directed_edges\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.GraphInterface","page":"API Reference","title":"GraphCore.GraphInterface","text":"GraphInterface <: AbstractGraph{Int32}\n\nBase abstract type for all graphs in the GraphCore ecosystem. All vertices are indexed by Int32 integers 1, 2, ..., num_vertices(g).\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.PropertyGraph","page":"API Reference","title":"GraphCore.PropertyGraph","text":"PropertyGraph{G,V,E} <: PropertyGraphInterface{V,E}\n\nUniversal property graph that wraps any base graph type with typed vertex and edge properties.\n\nType Parameters\n\nG<:GraphInterface: Base graph type (CoreGraph, WeightedGraph, AdjGraph, etc.)\nV: Vertex property type\nE: Edge property type\n\nDesign Benefits\n\nUniversal wrapper: Works with any GraphInterface implementation\nZero-cost delegation: All structural operations forwarded to base graph\nType safety: Compile-time property type guarantees\nAutomatic mutations: Inherits mutation capabilities from base graph\nMemory efficiency: No overhead when properties are unused\n\nUsage Patterns\n\n# Static analysis with CoreGraph base\ncore_g = build_core_graph(edges; directed=false)\nvertex_labels = [\"Alice\", \"Bob\", \"Charlie\"]\nedge_types = [\"friend\", \"colleague\", \"family\"]\npg = PropertyGraph(core_g, vertex_labels, edge_types)\n\n# Access patterns\nname = pg[1]                           # Vertex property via indexing\nedge_type = edge_property(pg, 2)       # Edge property by index\npg[1] = \"Alice Updated\"                # Property modification\n\n# Dynamic graphs with AdjGraph base\nadj_g = build_adj_graph(edges; directed=false)\npg_mut = PropertyGraph(adj_g, vertex_labels, edge_types)\n\n# Efficient mutations (when base graph supports them)\nnew_vertex = add_vertex!(pg_mut, \"David\")           # O(1) addition\nedge_idx = add_edge!(pg_mut, 1, new_vertex, \"buddy\")  # O(1) addition\n\n# Combined with weights\nweighted_g = build_weighted_graph(edges, weights; directed=false)\npg = PropertyGraph(weighted_g, vertex_labels, edge_types)\n# Now has both weights and properties available\n\nMutation Behavior\n\n# Mutations work when base graph supports them\nadj_pg = PropertyGraph(build_adj_graph(edges), v_props, e_props)\nadd_edge!(adj_pg, u, v, edge_prop)  # ✅ Works - AdjGraph supports mutations\n\n# Mutations fail gracefully when base graph doesn't support them\ncore_pg = PropertyGraph(build_core_graph(edges), v_props, e_props)\nadd_edge!(core_pg, u, v, edge_prop)  # ❌ MethodError - CoreGraph is immutable\n\n# Property arrays are automatically maintained during mutations\noriginal_count = length(adj_pg.edge_properties)\nedge_idx = add_edge!(adj_pg, u, v, edge_prop)\n@assert length(adj_pg.edge_properties) == original_count + 1\n\nPerformance Notes\n\nDelegation overhead: Typically optimized away by compiler\nMutation performance: Same as underlying graph type\nProperty management: Automatic with minimal overhead\nMemory: Base graph memory + property arrays + small wrapper overhead\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.PropertyGraphInterface","page":"API Reference","title":"GraphCore.PropertyGraphInterface","text":"PropertyGraphInterface{V,E,W} <: GraphInterface\nAbstract interface for property graphs, which support vertex and edge properties.\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.WeightedAdjGraph","page":"API Reference","title":"GraphCore.WeightedAdjGraph","text":"WeightedAdjGraph{W,D} <: WeightedGraphInterface{W}\n\nWeighted dynamic graph extending AdjGraph with parallel weight storage. Combines the mutation efficiency of adjacency lists with type-safe weights.\n\nType Parameters\n\nW<:Number: Weight type (Float64, Int32, etc.)\nD::Bool: Directedness flag\n\nKey Features\n\nSame mutation performance as AdjGraph for structural operations\nType-safe weights with compile-time guarantees\nDirectional weights even for undirected graphs\nParallel storage maintaining weight-neighbor correspondence\n\nWeight Semantics\n\nImportant: Weights are always directional, even for undirected graphs. This allows asymmetric edge properties while maintaining undirected connectivity.\n\n# For undirected edge with different directional costs:\ng = build_weighted_adj_graph([(1,2)], [1.5]; directed=false)\n# Internally stores: neighbors[1]=[2], weights[1]=[1.5]\n#                   neighbors[2]=[1], weights[2]=[1.5]\n# But weights can be modified independently if needed\n\n# Access via directional indexing:\nidx_12 = find_directed_edge_index(g, 1, 2)  # Different from (2,1)\nidx_21 = find_directed_edge_index(g, 2, 1)\nweight_12 = edge_weight(g, idx_12)  # Initial: 1.5\nweight_21 = edge_weight(g, idx_21)  # Initial: 1.5 (same value, different storage)\n\nMutation Examples\n\nedges = [(1,2), (2,3)]\nweights = [1.0, 2.0]\ng = build_weighted_adj_graph(edges, weights; directed=false)\n\n# Add weighted edge\nedge_idx = add_edge!(g, 3, 1, 1.5)  # O(1) amortized\n\n# Efficient weight access during iteration\nfor (neighbor, weight) in neighbor_weights(g, v)\n    process_weighted_neighbor(neighbor, weight)\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.WeightedAdjGraph-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W","page":"API Reference","title":"GraphCore.WeightedAdjGraph","text":"WeightedAdjGraph(g::WeightedGraphInterface{W}) -> WeightedAdjGraph{W}\nWeightedAdjGraph{W}(g::WeightedGraphInterface{W}) -> WeightedAdjGraph{W}\nWeightedAdjGraph{W,D}(g::WeightedGraphInterface{W}) -> WeightedAdjGraph{W,D}\n\nConstructor-based conversion from any WeightedGraphInterface to WeightedAdjGraph. Supports multiple forms with different levels of type specification. The type-safe variant validates directedness matching.\n\nSee to_weighted_adj_graph for detailed documentation.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.WeightedGraph","page":"API Reference","title":"GraphCore.WeightedGraph","text":"WeightedGraph{W,D} <: WeightedGraphInterface{W}\n\nWeighted graph extending CoreGraph with parallel weight storage.\n\nType Parameters\n\nW<:Number: Weight type (Float64, Int32, etc.)\nD::Bool: Directedness flag\n\nKey Features\n\nSame performance as CoreGraph for structural operations\nType-safe weights with compile-time guarantees\nDirectional weights even for undirected graphs\nParallel storage for cache-efficient weight access\n\nWeight Semantics\n\nImportant: Weights are always directional, even for undirected graphs. This allows asymmetric edge properties (e.g., different costs per direction).\n\n# For undirected edge (1,2) with weight 1.5:\nedge_weight(g, find_directed_edge_index(g, 1, 2)) # → 1.5\nedge_weight(g, find_directed_edge_index(g, 2, 1)) # → 1.5 (same value, different index)\n\n# But can be set differently if needed:\nweights = [1.5, 2.0]  # Different costs for each direction\ng = build_weighted_graph([(1,2), (2,1)], weights; directed=true)\n\nConstruction Examples\n\n# Undirected weighted graph\nedges = [(1,2), (2,3)]\nweights = [1.5, 2.0]\ng = build_weighted_graph(edges, weights; directed=false)\n\n# Type-specific construction\ng = build_graph(WeightedGraph{Float32}, edges; weights=weights, directed=false)\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.WeightedGraph-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W","page":"API Reference","title":"GraphCore.WeightedGraph","text":"WeightedGraph(g::WeightedGraphInterface{W}) -> WeightedGraph{W}\nWeightedGraph{W}(g::WeightedGraphInterface{W}) -> WeightedGraph{W}\nWeightedGraph{W,D}(g::WeightedGraphInterface{W}) -> WeightedGraph{W,D}\n\nConstructor-based conversion from any WeightedGraphInterface to WeightedGraph. Supports multiple forms with different levels of type specification. The type-safe variant validates directedness matching.\n\nSee to_weighted_graph for detailed documentation.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.WeightedGraphInterface","page":"API Reference","title":"GraphCore.WeightedGraphInterface","text":"WeightedGraphInterface <: GraphInterface\n\nInterface for weighted graphs, extending the core graph interface. W is the type of edge weights, typically a numeric type.\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.add_edge!","page":"API Reference","title":"GraphCore.add_edge!","text":"add_edge!(g::GraphInterface, u::Integer, v::Integer, [weight], [edge_property]) -> Int32\n\nAdd an edge from vertex u to vertex v with optional weight and/or edge property.\n\nReturns\n\nEdge index (Int32) of the newly added edge\n0 if the edge already exists (no modification performed)\n\nBehavior\n\nDirected graphs: Adds only u→v edge\nUndirected graphs: Adds both u→v and v→u internally (same edge index)  \nIndex assignment: New edges get the next available edge index\nDuplicate detection: Checks if edge exists before adding\nIndex stability: Existing edge/vertex indices remain valid after addition\n\nType-Specific Performance\n\nCoreGraph: O(degree) - extends CSR arrays, efficient for static analysis\nAdjGraph: O(1) amortized - vector push operations, efficient for dynamic graphs\nWeightedGraph: Same as base type + weight storage\nPropertyGraph: Same as base type + property storage\n\nError Conditions\n\nThrows BoundsError if either vertex doesn't exist\nFor weighted graphs, weight type must match graph's weight type\nFor property graphs, property type must match graph's edge property type\n\nExamples\n\n# Basic edge addition\ng = build_graph(CoreGraph, [(1,2)]; directed=false)\nedge_idx = add_edge!(g, 1, 3)  # Returns edge index\n\n# Weighted edge\nwg = build_graph(WeightedGraph, [(1,2,1.0)]; directed=true)  \nedge_idx = add_edge!(wg, 2, 3, 2.5)  # Add weighted edge\n\n# Property edge\npg = build_graph(PropertyGraph{AdjGraph,Nothing,String}, [(1,2)]; \n                 directed=false, edge_properties=[\"friendship\"])\nedge_idx = add_edge!(pg, 1, 3, \"colleague\")  # Add edge with property\n\nAvailability\n\nOnly available for mutable graph types (AdjGraph, WeightedAdjGraph, PropertyGraph with mutable base).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.add_vertex!","page":"API Reference","title":"GraphCore.add_vertex!","text":"add_vertex!(g::GraphInterface, [vertex_property]) -> Int32\n\nAdd a new isolated vertex to the graph with optional vertex property.\n\nReturns\n\nIndex (Int32) of the newly added vertex\n\nBehavior\n\nNew vertex: Has no neighbors initially (degree 0)\nIndex assignment: Gets the next available vertex index (typically num_vertices(g) + 1)\nIndex stability: All existing vertex/edge indices remain valid\nConnections: Use add_edge! to connect the new vertex to others\n\nType-Specific Performance\n\nCoreGraph: O(1) - extends vertex arrays\nAdjGraph: O(1) - pushes to vertex arrays  \nWeightedGraph: O(1) - same as base type\nPropertyGraph: O(1) - same as base type + property storage\n\nProperty Handling\n\nNo properties: add_vertex!(g) - adds vertex without properties\nWith properties: add_vertex!(g, prop) - property type must match graph's vertex property type\n\nExamples\n\n# Add vertex without properties\ng = build_graph(AdjGraph, [(1,2)]; directed=false)\nnew_v = add_vertex!(g)  # Returns 3\nadd_edge!(g, 1, new_v)  # Connect to existing vertex\n\n# Add vertex with property\npg = build_graph(PropertyGraph{AdjGraph,String,Nothing}, [(1,2)]; \n                 directed=false, vertex_properties=[\"Alice\", \"Bob\"])\nnew_v = add_vertex!(pg, \"Charlie\")  # Returns 3 with property\n\nAvailability\n\nOnly available for mutable graph types (AdjGraph, WeightedAdjGraph, PropertyGraph with mutable base).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.all_directed_edges-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.all_directed_edges","text":"all_directed_edges(g::GraphInterface) -> Iterator\n\nReturn an iterator over all directed edges in the graph.\n\nFor directed graphs: yields (source, target) pairs for each directed edge\nFor undirected graphs: yields (u, v) and (v, u) pairs for each undirected edge\n\nExamples\n\nfor (u, v) in all_directed_edges(g)\n    println(\"Directed edge from \", u, \" to \", v)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.all_edges-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.all_edges","text":"all_edges(g::GraphInterface) -> Iterator\n\nAlias for edges(g). Provided for disambiguation when using multiple graph libraries.\n\nSee also: edges\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_adj_graph-Tuple{Any}","page":"API Reference","title":"GraphCore.build_adj_graph","text":"Build adjacency list graph with same interface as CoreGraph.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_core_graph-Tuple{Any}","page":"API Reference","title":"GraphCore.build_core_graph","text":"Build unweighted core graph (most common case)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_graph-Union{Tuple{W}, Tuple{E}, Tuple{V}, Tuple{G}, Tuple{Type{PropertyGraph{G, V, E}}, Any}} where {G<:GraphInterface, V, E, W<:Number}","page":"API Reference","title":"GraphCore.build_graph","text":"build_graph(::Type{PropertyGraph{G,V,E}}, edges; kwargs...) where {G,V,E}\n\nBuild a property graph with vertex and edge properties. The underlying graph type G determines performance characteristics (CoreGraph for CSR, AdjGraph for adjacency list).\n\nArguments\n\nedges: Vector of (u,v) tuples/pairs representing graph edges\ndirected=true: Whether the graph is directed\nvertex_properties=[]: Properties for each vertex (type V)\nedge_properties=[]: Properties for each edge (type E)\nweights=[]: Edge weights (optional)\nvalidate=true: Whether to validate inputs\n\nExamples\n\n# Property graph with CoreGraph backend\ng = build_graph(PropertyGraph{CoreGraph,String,String}, [(1,2), (2,3)];\n                vertex_properties=[\"A\", \"B\", \"C\"], edge_properties=[\"e1\", \"e2\"])\n\n# Property graph with AdjGraph backend for dynamic use\ng = build_graph(PropertyGraph{AdjGraph,Int,Symbol}, [(1,2), (2,3)];\n                vertex_properties=[1, 2, 3], edge_properties=[:a, :b])\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_graph-Union{Tuple{W}, Tuple{G}, Tuple{Type{G}, Any}} where {G<:Union{AdjGraph, WeightedAdjGraph}, W<:Number}","page":"API Reference","title":"GraphCore.build_graph","text":"build_graph(::Type{G}, edges; kwargs...) where {G<:AdjGraphTypes}\n\nBuild adjacency list graph optimized for dynamic modifications and mutations.\n\nArguments\n\nedges: Vector of (u,v) tuples/pairs representing graph edges\ndirected=true: Whether to build a directed graph\nweights=[]: Edge weights (for WeightedAdjGraph types)\nvalidate=true: Enable input validation\n\nPerformance Characteristics\n\nDynamic-friendly: Efficient vertex/edge additions and removals\nMemory flexible: Grows naturally, higher overhead than CSR\nMutation-optimized: O(1) edge additions, efficient vertex operations\n\nUse AdjGraph types when frequent graph modifications are expected. For static graphs with performance-critical traversals, prefer CoreGraph types.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_graph-Union{Tuple{W}, Tuple{G}, Tuple{Type{G}, Any}} where {G<:Union{CoreGraph, WeightedGraph}, W<:Number}","page":"API Reference","title":"GraphCore.build_graph","text":"build_graph(::Type{G}, edges; kwargs...) -> G\n\nBuild a graph from an edge list with comprehensive validation and flexible options.\n\nArguments\n\nedges: Vector of (u,v) tuples/pairs representing graph edges\ndirected=true: Whether to build a directed graph\nn=0: Number of vertices (0 = auto-detect from edges)\nweights=[]: Edge weights (for WeightedGraph types)\nvalidate=true: Enable input validation (recommended for safety)\n\nExamples\n\n# Basic graphs\ng = build_graph(CoreGraph, [(1,2), (2,3)]; directed=false)\nwg = build_graph(WeightedGraph{Float64}, [(1,2), (2,3)]; weights=[1.5, 2.0], directed=false)\n\n# Graph with isolated vertices\ng = build_graph(CoreGraph, [(1,2)]; n=5, directed=false)  # Creates isolated vertices 3,4,5\n\n# High-performance mode (skip validation)\ng = build_graph(CoreGraph, trusted_edges; directed=false, validate=false)\n\nOptimized for CSR representation with efficient construction and memory usage. For dynamic graphs requiring frequent mutations, consider AdjGraph types.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_property_adj_graph-Union{Tuple{E}, Tuple{V}, Tuple{Any, AbstractVector{V}, AbstractVector{E}}} where {V, E}","page":"API Reference","title":"GraphCore.build_property_adj_graph","text":"build_property_adj_graph(edges, vertex_properties, edge_properties; directed=true, kwargs...)\n\nBuild a PropertyGraph with AdjGraph backend (supports efficient mutations).\n\nArguments\n\nedges: Vector of (u,v) tuples representing graph edges\nvertex_properties: Vector of vertex properties\nedge_properties: Vector of edge properties\ndirected=true: Whether to build a directed graph\nkwargs...: Additional arguments passed to underlying graph construction\n\nExample\n\nedges = [(1,2), (2,3)]\nvertex_props = [1, 2, 3]\nedge_props = [:a, :b]\npg = build_property_adj_graph(edges, vertex_props, edge_props; directed=false)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_property_graph-Union{Tuple{E}, Tuple{V}, Tuple{Any, AbstractVector{V}, AbstractVector{E}}} where {V, E}","page":"API Reference","title":"GraphCore.build_property_graph","text":"build_property_graph(edges, vertex_properties, edge_properties; directed=true, kwargs...)\n\nBuild a PropertyGraph with CoreGraph backend.\n\nArguments\n\nedges: Vector of (u,v) tuples representing graph edges\nvertex_properties: Vector of vertex properties\nedge_properties: Vector of edge properties\ndirected=true: Whether to build a directed graph\nkwargs...: Additional arguments passed to underlying graph construction\n\nExample\n\nedges = [(1,2), (2,3), (1,3)]\nvertex_props = [\"Alice\", \"Bob\", \"Charlie\"]\nedge_props = [\"friend\", \"colleague\", \"family\"]\npg = build_property_graph(edges, vertex_props, edge_props; directed=false)\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_weighted_graph-Union{Tuple{W}, Tuple{Any, AbstractVector{W}}} where W","page":"API Reference","title":"GraphCore.build_weighted_graph","text":"Build weighted graph\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.canonicalize_edges-Tuple{Any}","page":"API Reference","title":"GraphCore.canonicalize_edges","text":"canonicalize_edges(edges) -> Vector{Tuple{Int,Int}}\n\nConvert symmetric edge format to canonical format for undirected graphs.\n\nArguments\n\nedges: Vector of (u,v) tuples representing edges\n\nReturns\n\nVector of canonical edges where u ≤ v for each edge\n\nFormat Conversion\n\nInput: [(1,2), (2,1), (2,3), (3,2)] (both directions)\nOutput: [(1,2), (2,3)] (canonical: u ≤ v)\n\nUse when your input has both directions listed for undirected edges. This removes duplicates and ensures a consistent canonical representation.\n\nExample\n\nedges = [(1,2), (2,1), (2,3), (3,2), (1,3), (3,1)]\ncanonical = GraphCore.canonicalize_edges(edges)\n# Result: [(1,2), (1,3), (2,3)]\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.canonicalize_edges-Union{Tuple{W}, Tuple{Any, AbstractVector{W}}} where W","page":"API Reference","title":"GraphCore.canonicalize_edges","text":"canonicalize_edges(edges, weights::AbstractVector{W}) -> (canonical_edges, canonical_weights)\n\nConvert symmetric format to canonical, keeping weights for canonical edges only.\n\nArguments\n\nedges: Vector of (u,v) tuples representing edges\nweights: Vector of weights corresponding to edges\n\nReturns\n\nTuple of (canonicaledges, canonicalweights)\n\nBehavior\n\nWhen multiple weights exist for the same undirected edge, keeps the first encountered weight. This is useful when processing datasets that list both directions with potentially different weights.\n\nExample\n\nedges = [(1,2), (2,1), (2,3), (3,2)]\nweights = [1.5, 1.5, 2.0, 2.1]  # Note: slight difference in last weight\ncanonical_edges, canonical_weights = GraphCore.canonicalize_edges(edges, weights)\n# Result: edges = [(1,2), (2,3)], weights = [1.5, 2.0]\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.degree-Tuple{GraphInterface, Integer}","page":"API Reference","title":"GraphCore.degree","text":"degree(g::GraphInterface, v::Integer) -> Int32\n\nReturn the degree of vertex v (number of neighbors).\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.directed_edge_index","page":"API Reference","title":"GraphCore.directed_edge_index","text":"directed_edge_index(g::GraphInterface, v::Integer, i::Integer) -> Int32\n\nGet the directed edge index for the i-th neighbor of vertex v.\n\nSimilar to edge_index but for directional properties. Always provides directional indexing even for undirected graphs.\n\nKey difference: For undirected graphs:\n\nedge_index(g, u, i) == edge_index(g, v, j) if neighbors are the same edge\ndirected_edge_index(g, u, i) ≠ directed_edge_index(g, v, j) (always directional)\n\nThis enables asymmetric properties on undirected graphs (e.g., different costs for traversing an edge in each direction).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.directed_edge_indices","page":"API Reference","title":"GraphCore.directed_edge_indices","text":"directed_edge_indices(g::GraphInterface, v::Integer) -> view or iterator\n\nReturn an iterator over the directed edge indices for edges from vertex v. The i-th edge index corresponds to the i-th neighbor in neighbor_indices(g, v). For directed graphs this is the same asdirectededgeindices(g, v)`.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.directed_edge_indices-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.directed_edge_indices","text":"directed_edge_indices(g::GraphInterface) -> UnitRange{Int}\n\nReturn a range over all directed edge indices. Suitable for sizing and indexing external directed edge property arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.edge_index","page":"API Reference","title":"GraphCore.edge_index","text":"edge_index(g::GraphInterface, v::Integer, i::Integer) -> Int32\n\nGet the undirected edge index for the i-th neighbor of vertex v.\n\nThis provides O(1) conversion from neighbor position to edge index, enabling efficient indexing into external edge property arrays.\n\nRelationship: edge_index(g, v, i) == find_edge_index(g, v, neighbor_indices(g, v)[i])\n\nUse case: Processing neighbors with associated edge data\n\nedge_weights = Vector{Float64}(undef, num_edges(g))\nfor (i, neighbor) in enumerate(neighbor_indices(g, v))\n    edge_idx = edge_index(g, v, i)           # O(1) - no search needed!\n    weight = edge_weights[edge_idx]          # Direct array access\n    process_neighbor_with_weight(neighbor, weight)\nend\n\nIndex stability: Edge indices remain stable during graph analysis, but may be invalidated by structural modifications (add/remove operations).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.edge_indices","page":"API Reference","title":"GraphCore.edge_indices","text":"edge_indices(g::GraphInterface, v::Integer) -> view or iterator\n\nReturn an iterator over the undirected edge indices for edges from vertex v. The i-th edge index corresponds to the i-th neighbor in neighbor_indices(g, v).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.edge_indices-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.edge_indices","text":"edge_indices(g::GraphInterface) -> UnitRange{Int}\n\nReturn a range over all undirected edge indices. Suitable for sizing and indexing external edge property arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.edge_properties","page":"API Reference","title":"GraphCore.edge_properties","text":"edge_properties(g::PropertyGraphInterface) -> iterator\n\nReturn an iterator over all edge properties in edge index order.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.edge_property","page":"API Reference","title":"GraphCore.edge_property","text":"edge_property(g::PropertyGraphInterface, edge_idx::Integer) -> E\n\nGet the property associated with edge at the given edge index. Uses undirected edge indexing (1:num_edges).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.edge_property-Tuple{GraphInterface, Integer, Integer}","page":"API Reference","title":"GraphCore.edge_property","text":"edge_property(g::GraphInterface, u::Integer, v::Integer) -> E\n\nGet the property of the edge between u and v. Uses undirected edge indexing - for undirected graphs, this returns the same property regardless of direction.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.edge_weight","page":"API Reference","title":"GraphCore.edge_weight","text":"edge_weight(g::WeightedGraphInterface, directed_edge_idx::Integer) -> W\nedge_weight(g::WeightedGraphInterface, edge::Pair{<:Integer,<:Integer}) -> W\n\nGet the weight of the directed edge at the given directed edge index. Uses the directional indexing system for O(1) weight lookups. The second form allows querying by vertex pair, equivalent to edge_weight(g, find_edge_index(g, u, v)).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.edge_weights","page":"API Reference","title":"GraphCore.edge_weights","text":"edge_weights(g::WeightedGraphInterface, v::Integer) -> view or iterator\nedge_weights(g::WeightedGraphInterface) -> view or iterator\n\nReturn weights for edges from vertex v, or all edge weights.\n\nImportant: Weights are always directional, even for undirected graphs. This design allows asymmetric weights (e.g., different traversal costs in each direction).\n\nOrdering: The i-th weight corresponds to the i-th neighbor in neighbor_indices(g, v).\n\nExamples\n\n# Process neighbors with weights\nfor (neighbor, weight) in zip(neighbor_indices(g, v), edge_weights(g, v))\n    process_weighted_edge(v, neighbor, weight)\nend\n\n# More convenient combined iteration\nfor (neighbor, weight) in neighbor_weights(g, v)\n    process_weighted_edge(v, neighbor, weight)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.edges-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.edges","text":"edges(g::GraphInterface) -> Iterator\n\nReturn an iterator over all edges in the graph.\n\nFor directed graphs: yields (source, target) pairs for each directed edge\nFor undirected graphs: yields (u, v) pairs where u ≤ v (each edge once)\n\nExamples\n\nfor (u, v) in edges(g)\n    println(\"Edge from \", u, \" to \", v)\nend\n\n# Collect all edges\nedge_list = collect(edges(g))\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.find_directed_edge_index","page":"API Reference","title":"GraphCore.find_directed_edge_index","text":"find_directed_edge_index(g::GraphInterface, u::Integer, v::Integer) -> Int32\n\nFind the directed edge index for the directed edge from vertices u to v of the graph g. Returns 0 if no such edge exists.\n\nAlways directional: find_directed_edge_index(g, u, v) ≠ find_directed_edge_index(g, v, u)\n\nThis index is used for directed edge weight access and other directional properties, and for indexing external arrays of size num_directed_edges(g).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.find_edge_index","page":"API Reference","title":"GraphCore.find_edge_index","text":"find_edge_index(g::GraphInterface, u::Integer, v::Integer) -> Int32\n\nFind the undirected edge index for the edge between vertices u and v of the graph g. Returns 0 if no such edge exists.\n\nFor undirected graphs: find_edge_index(g, u, v) == find_edge_index(g, v, u) For directed graphs: only finds the edge in the specified direction (u -> v).\n\nThis index is used for edge property access (shared properties) and for indexing external arrays of size num_edges(g). For directed graphs this is the same as find_directed_edge_index(g, u, v).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.has_edge","page":"API Reference","title":"GraphCore.has_edge","text":"has_edge(g::GraphInterface, u::Integer, v::Integer) -> Bool\n\nTest whether there is a directed edge from vertex u to vertex v. For undirected graphs, has_edge(g, u, v) == has_edge(g, v, u).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.has_vertex","page":"API Reference","title":"GraphCore.has_vertex","text":"has_vertex(g::GraphInterface, v::Integer) -> Bool\n\nTest whether vertex v exists in the graph. Vertices are always integers in range 1:num_vertices(g).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.interface_summary-Tuple{}","page":"API Reference","title":"GraphCore.interface_summary","text":"interface_summary()\n\nPrint a summary of the interface requirements.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.is_directed_graph","page":"API Reference","title":"GraphCore.is_directed_graph","text":"is_directed_graph(g::GraphInterface) -> Bool\n\nReturn true if the graph is directed, false if undirected. This affects the interpretation of edges and neighbor relationships.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.neighbor","page":"API Reference","title":"GraphCore.neighbor","text":"neighbor(g::GraphInterface, v::Integer, i::Integer) -> Int32\n\nReturn the i-th neighbor of vertex v in the graph g.\n\nDefault implementation provided - concrete types may override for efficiency.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.neighbor_indices","page":"API Reference","title":"GraphCore.neighbor_indices","text":"neighbor_indices(g::GraphInterface, v::Integer) -> view or iterator\n\nReturn an iterator over the neighbor indices of vertex v.\n\nFor directed graphs: Returns out-neighbors only For undirected graphs: Returns all neighbors\n\nPerformance guarantee: The returned iterator must support:\n\nFast iteration: for neighbor in neighbor_indices(g, v)\nLength query: length(neighbor_indices(g, v))\nIndex access: neighbor_indices(g, v)[i] (implementation dependent)\n\nMemory efficiency: Implementations should return views when possible to avoid allocation during neighbor traversal.\n\nExamples\n\n# Basic iteration\nfor neighbor in neighbor_indices(g, v)\n    process_neighbor(neighbor)\nend\n\n# Combined with indexing for edge properties\nfor (i, neighbor) in enumerate(neighbor_indices(g, v))\n    edge_idx = edge_index(g, v, i)        # O(1) edge index lookup\n    process_edge(neighbor, edge_idx)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.neighbor_weights","page":"API Reference","title":"GraphCore.neighbor_weights","text":"neighbor_weights(g::WeightedGraphInterface, v::Integer) -> iterator\n\nReturn an iterator over (neighbor_index, weight) pairs for vertex v. More efficient than separate iteration over neighbor_indices(g, v) and edge_weights(g, v).\n\nUsage:\n\n    for (neighbor, weight) in neighbor_weights(g, v)\n        # process neighbor and weight together\n    end\n\nSee also: neighbor_indices, edge_weights\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.num_directed_edges","page":"API Reference","title":"GraphCore.num_directed_edges","text":"num_directed_edges(g::GraphInterface) -> Int32\n\nReturn the total number of directed edges in the graph.\n\nFor undirected graphs: 2 * num_edges(g)\nFor directed graphs: actual count of directed edges\n\nThis count determines the size needed for directed edge property arrays.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.num_edges","page":"API Reference","title":"GraphCore.num_edges","text":"num_edges(g::GraphInterface) -> Int32\n\nReturn the number of edges in the graph. For undirected graphs, this counts each edge once. For directed graphs, this counts directed edges.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.num_vertices","page":"API Reference","title":"GraphCore.num_vertices","text":"num_vertices(g::GraphInterface) -> Int32\n\nReturn the number of vertices in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.remove_edge!","page":"API Reference","title":"GraphCore.remove_edge!","text":"remove_edge!(g::GraphInterface, u::Integer, v::Integer) -> Bool\n\nRemove the edge from vertex u to vertex v.\n\nReturns\n\ntrue if edge was successfully removed\nfalse if edge doesn't exist (no modification performed)\n\nBehavior\n\nDirected graphs: Removes only the u→v edge\nUndirected graphs: Removes both u→v and v→u edges (same operation)\nEdge properties: Automatically removed for property graphs\nIndex stability: Vertex indices remain unchanged, edge indices may be affected\n\nType-Specific Performance\n\nCoreGraph: O(degree) - updates CSR arrays and shifts subsequent edges\nAdjGraph: O(degree) - searches neighbor list and removes entry\nWeightedGraph: Same as base type + weight removal\nPropertyGraph: Same as base type + property removal\n\nEdge Index Effects\n\nCoreGraph/WeightedGraph: Edge indices may change for edges after the removed edge\nAdjGraph/WeightedAdjGraph: Edge indices remain stable\nPropertyGraph: Inherits behavior from base graph type\n\nError Conditions\n\nNo error for non-existent edges (returns false)\nThrows BoundsError if either vertex doesn't exist\n\nExamples\n\n# Basic edge removal\ng = build_graph(AdjGraph, [(1,2), (2,3), (1,3)]; directed=false)\nsuccess = remove_edge!(g, 1, 2)  # Returns true\n@assert !has_edge(g, 1, 2) && !has_edge(g, 2, 1)  # Both directions removed\n\n# Directed graph edge removal\ndg = build_graph(AdjGraph, [(1,2), (2,1)]; directed=true)\nremove_edge!(dg, 1, 2)  # Removes only 1→2\n@assert !has_edge(dg, 1, 2) && has_edge(dg, 2, 1)  # 2→1 still exists\n\n# Property graph edge removal\npg = build_graph(PropertyGraph{AdjGraph,Nothing,String}, [(1,2), (2,3)]; \n                 directed=false, edge_properties=[\"friend\", \"colleague\"])\nremove_edge!(pg, 1, 2)  # Removes edge and \"friend\" property\n\nAvailability\n\nOnly available for mutable graph types (AdjGraph, WeightedAdjGraph, PropertyGraph with mutable base).\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.remove_vertex!","page":"API Reference","title":"GraphCore.remove_vertex!","text":"remove_vertex!(g::GraphInterface, v::Integer) -> Bool\n\nRemove vertex v and all its incident edges from the graph.\n\nReturns\n\ntrue if vertex was successfully removed\nfalse if vertex doesn't exist (no modification performed)\n\nBehavior\n\nEdge removal: All edges incident to vertex v are automatically removed\nIndex compaction: Vertices with indices > v are renumbered to fill the gap\nProperty handling: Vertex and edge properties are automatically maintained\nIndex invalidation: Vertex indices > v become invalid after removal\n\nType-Specific Performance\n\nCoreGraph: O(V+E) - rebuilds CSR arrays with compacted indices\nAdjGraph: O(V+E) - updates all vertex references and compacts arrays\nWeightedGraph: Same as base type + weight array maintenance\nPropertyGraph: Same as base type + property array maintenance\n\nIndex Management\n\nAfter removing vertex v, all vertices with indices > v get decremented by 1:\n\nVertex v+1 becomes vertex v\nVertex v+2 becomes vertex v+1, etc.\nExternal arrays indexed by vertex must be updated accordingly\n\nError Conditions\n\nNo error for non-existent vertices (returns false)\nFor property graphs, properties are removed automatically\n\nExamples\n\n# Basic vertex removal\ng = build_graph(AdjGraph, [(1,2), (2,3), (1,3)]; directed=false)\nsuccess = remove_vertex!(g, 2)  # Remove vertex 2, returns true\n# Vertex 3 is now vertex 2, edges (1,3) becomes (1,2)\n\n# Property graph vertex removal\npg = build_graph(PropertyGraph{AdjGraph,String,Nothing}, [(1,2), (2,3)]; \n                 directed=false, vertex_properties=[\"Alice\", \"Bob\", \"Charlie\"])\nremove_vertex!(pg, 2)  # Removes \"Bob\", \"Charlie\" becomes vertex 2\n\nAvailability\n\nOnly available for mutable graph types (AdjGraph, WeightedAdjGraph, PropertyGraph with mutable base).\n\n⚠️ Important\n\nThis operation invalidates vertex indices > v. Update any external data structures accordingly.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.set_edge_property!","page":"API Reference","title":"GraphCore.set_edge_property!","text":"set_edge_property!(g::PropertyGraphInterface{V,E,W}, edge_idx::Integer, prop::E) -> prop\n\nSet the property of edge at edge_idx to prop. Only available for mutable graph types.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.set_edge_weight!","page":"API Reference","title":"GraphCore.set_edge_weight!","text":"set_edge_weight!(g::PropertyGraphInterface{V,E,W}, directed_edge_idx::Integer, weight::W) -> Nothing\n\nSet the weight of the directed edge at directededgeidx to weight. Only available for mutable graph types.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.set_vertex_property!","page":"API Reference","title":"GraphCore.set_vertex_property!","text":"set_vertex_property!(g::PropertyGraphInterface{V,E,W}, v::Integer, prop::V) -> prop\n\nSet the property of vertex v to prop. Only available for mutable graph types.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.symmetrize_edges-Tuple{Any}","page":"API Reference","title":"GraphCore.symmetrize_edges","text":"symmetrize_edges(edges) -> Vector{Tuple{Int,Int}}\n\nConvert canonical format to symmetric format (both directions).\n\nArguments\n\nedges: Vector of (u,v) tuples in canonical format\n\nReturns\n\nVector of edges with both directions included\n\nFormat Conversion\n\nInput: [(1,2), (2,3)] (canonical)\nOutput: [(1,2), (2,1), (2,3), (3,2)] (both directions)\n\nUse when you need to create a directed graph from undirected edges, or when working with algorithms that expect symmetric adjacency representations.\n\nExample\n\ncanonical = [(1,2), (2,3), (1,3)]\nsymmetric = GraphCore.symmetrize_edges(canonical)\n# Result: [(1,2), (2,1), (2,3), (3,2), (1,3), (3,1)]\n\nNote\n\nSelf-loops (u,u) are not duplicated to avoid redundancy.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.symmetrize_edges-Union{Tuple{W}, Tuple{Any, AbstractVector{W}}} where W","page":"API Reference","title":"GraphCore.symmetrize_edges","text":"symmetrize_edges(edges, weights::AbstractVector{W}) -> (symmetric_edges, symmetric_weights)\n\nConvert canonical format to symmetric, duplicating weights for both directions.\n\nArguments\n\nedges: Vector of (u,v) tuples in canonical format\nweights: Vector of weights corresponding to edges\n\nReturns\n\nTuple of (symmetricedges, symmetricweights)\n\nBehavior\n\nEach weight is duplicated for both directions of the edge. This creates a symmetric weight matrix suitable for undirected graph algorithms.\n\nExample\n\nedges = [(1,2), (2,3)]\nweights = [1.5, 2.0]\nsymmetric_edges, symmetric_weights = GraphCore.symmetrize_edges(edges, weights)\n# Result:\n# edges = [(1,2), (2,1), (2,3), (3,2)]\n# weights = [1.5, 1.5, 2.0, 2.0]\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.to_adj_graph-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.to_adj_graph","text":"to_adj_graph(g::GraphInterface) -> AdjGraph\n\nConvert any GraphInterface graph to an AdjGraph. Preserves the directedness of the original graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.to_core_graph-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.to_core_graph","text":"to_core_graph(g::GraphInterface) -> CoreGraph\n\nConvert any GraphInterface implementation to a CoreGraph. Preserves the directedness of the original graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.to_property_graph-Union{Tuple{E}, Tuple{V}, Tuple{GraphInterface, Vector{V}, Vector{E}}} where {V, E}","page":"API Reference","title":"GraphCore.to_property_graph","text":"to_property_graph(g::GraphInterface, vertex_props::Vector{V}, edge_props::Vector{E}) -> PropertyGraph{typeof(g),V,E}\n\nConvert any GraphInterface to a PropertyGraph with the given properties.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.to_property_graph-Union{Tuple{E}, Tuple{V}, Tuple{PropertyGraphInterface{V, E}, Type{AdjGraph}}} where {V, E}","page":"API Reference","title":"GraphCore.to_property_graph","text":"to_property_graph(g::PropertyGraphInterface{V,E}, ::Type{AdjGraph}) -> PropertyGraph{AdjGraph,V,E}\n\nConvert any PropertyGraphInterface to a PropertyGraph backed by AdjGraph. Preserves directedness and all properties.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.to_property_graph-Union{Tuple{PropertyGraphInterface{V, E}}, Tuple{E}, Tuple{V}} where {V, E}","page":"API Reference","title":"GraphCore.to_property_graph","text":"to_property_graph(g::PropertyGraphInterface{V,E}) -> PropertyGraph{CoreGraph,V,E}\n\nConvert any PropertyGraphInterface to a PropertyGraph wrapping a CoreGraph. Preserves directedness, vertex properties, and edge properties.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.to_weighted_adj_graph-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W","page":"API Reference","title":"GraphCore.to_weighted_adj_graph","text":"to_weighted_adj_graph(g::WeightedGraphInterface{W}) -> WeightedAdjGraph{W}\n\nConvert any WeightedGraphInterface to a WeightedAdjGraph. Preserves directedness and all weights.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.to_weighted_graph-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W","page":"API Reference","title":"GraphCore.to_weighted_graph","text":"to_weighted_graph(g::WeightedGraphInterface{W}) -> WeightedGraph{W}\n\nConvert any WeightedGraphInterface to a WeightedGraph. Preserves the directedness and all weights of the original graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.validate_interface-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.validate_interface","text":"validate_interface(g::GraphInterface)\n\nValidate that a graph type correctly implements the GraphInterface.\n\nPerforms comprehensive checks including:\n\nMethod availability for the graph type\nBasic functionality (if graph is non-empty)\nIndex range consistency\nDirected vs undirected edge count relationships\nIterator and view consistency\n\nUsage: Call during development to ensure interface compliance.\n\ng = build_core_graph(edges; directed=false)\nvalidate_interface(g)  # Throws descriptive errors if implementation is incorrect\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.vertex_properties","page":"API Reference","title":"GraphCore.vertex_properties","text":"vertex_properties(g::PropertyGraphInterface) -> iterator\n\nReturn an iterator over all vertex properties in order.\n\nExample\n\ng = build_property_graph(edges, [\"A\", \"B\", \"C\"], edge_props, 3)\nfor (i, prop) in enumerate(vertex_properties(g))\n    println(\"Vertex \", i, \" has property: \", prop)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.vertex_property","page":"API Reference","title":"GraphCore.vertex_property","text":"vertex_property(g::GraphInterface, v::Integer) -> V\n\nGet the property associated with vertex v.\n\n\n\n\n\n","category":"function"},{"location":"api/#GraphCore.vertices-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.vertices","text":"vertices(g::GraphInterface) -> UnitRange{Int}\n\nReturn a range over all vertex indices.\n\n\n\n\n\n","category":"method"},{"location":"api/#Graph-Construction","page":"API Reference","title":"Graph Construction","text":"","category":"section"},{"location":"api/#GraphCore.Builders","page":"API Reference","title":"GraphCore.Builders","text":"Graph Construction Builder\n\nEfficient builder for constructing graphs with incremental vertex/edge addition. Optimized for construction speed, not query performance.\n\n\n\n\n\n","category":"module"},{"location":"api/#GraphCore.Builders.GraphBuilder","page":"API Reference","title":"GraphCore.Builders.GraphBuilder","text":"GraphBuilder{V,E,W}\n\nBuilder for constructing graphs incrementally. Optimized for fast additions during construction phase.\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.Builders.build_from_function-Tuple{Function, Function, Int64}","page":"API Reference","title":"GraphCore.Builders.build_from_function","text":"build_from_function(vertex_fn::Function, edge_fn::Function, nv::Int; directed=true)\n\nBuild a graph by calling vertexfn(i) for each vertex and edgefn(u,v) for potential edges.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_graph-Union{Tuple{GraphBuilder{V, E, W}}, Tuple{W}, Tuple{E}, Tuple{V}} where {V, E, W}","page":"API Reference","title":"GraphCore.build_graph","text":"build_graph(builder::GraphBuilder{V,E,W}) -> GraphInterface\n\nConvert the builder to an optimized graph representation. Automatically chooses the most appropriate graph type among: CoreGraph, WeightedGraph{W}, PropertyGraph{G,V,E}.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.build_graph-Union{Tuple{G}, Tuple{GraphBuilder, Type{G}}} where G<:GraphInterface","page":"API Reference","title":"GraphCore.build_graph","text":"build_graph(builder::GraphBuilder, ::Type{G}) -> G\n\nConvert builder to a specific graph type G, where G can be one of: CoreGraph, WeightedGraph{W}, PropertyGraph, AdjGraph, WeightedAdjGraph{W}, PropertyAdjGraph. Note that the builder must be compatible with the target graph type. Also note that the order of the arguments, builder, graph type, is opposite to the usual order.\n\n\n\n\n\n","category":"method"},{"location":"api/#Conversions","page":"API Reference","title":"Conversions","text":"","category":"section"},{"location":"api/#GraphCore.Conversions.from_adjacency_matrix-Union{Tuple{W}, Tuple{G}, Tuple{Type{G}, AbstractMatrix{W}}} where {G<:GraphInterface, W<:Number}","page":"API Reference","title":"GraphCore.Conversions.from_adjacency_matrix","text":"from_adjacency_matrix(::Type{G}, adj_matrix::AbstractMatrix{W}) where {G<:GraphInterface,W} -> G\n\nConstruct a graph of appropriate type from an adjacency matrix.\n\nNon-zero entries in adj_matrix become edges with those weights\nIf directed is not specified, it is inferred from the symmetry of adj_matrix\n\nFor undirected graphs, adj_matrix should be symmetric.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Conversions.from_graphs_jl-Tuple{Graphs.AbstractGraph}","page":"API Reference","title":"GraphCore.Conversions.from_graphs_jl","text":"from_graphs_jl(g::Graphs.AbstractGraph; directed::Bool = Graphs.is_directed(g)) -> CoreGraph\n\nConvert a graph from the Graphs.jl ecosystem to a CoreGraph.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Conversions.from_weighted_graphs_jl-Union{Tuple{W}, Tuple{Graphs.AbstractGraph, AbstractVector{W}}} where W","page":"API Reference","title":"GraphCore.Conversions.from_weighted_graphs_jl","text":"from_weighted_graphs_jl(g::Graphs.AbstractGraph, weights::AbstractVector{W};\n                       directed::Bool = Graphs.is_directed(g)) -> WeightedGraph{W}\n\nConvert a weighted graph from the Graphs.jl ecosystem to a WeightedGraph.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Conversions.to_adjacency_matrix-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.Conversions.to_adjacency_matrix","text":"to_adjacency_matrix(g::GraphInterface) -> SparseMatrixCSC{W} where {W}\n\nConvert a graph to its adjacency matrix representation.\n\nFor directed graphs, the matrix is not required to be symmetric.\nFor undirected graphs, the matrix will be symmetric if the weights are.\nFor unweighted graphs, entries are 1 where edges exist.\nFor weighted graphs, entries are the edge weights (which are not necessarily symmetric even for undirected graphs).\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Conversions.to_graphs_jl-Tuple{GraphInterface}","page":"API Reference","title":"GraphCore.Conversions.to_graphs_jl","text":"to_graphs_jl(g::GraphInterface) -> Graphs.SimpleGraph or Graphs.SimpleDiGraph\n\nConvert a property graph to a Graphs.jl graph (losing properties and weights). Returns SimpleGraph for undirected graphs, SimpleDiGraph for directed graphs.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Conversions.to_weighted_graphs_jl-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W<:Number","page":"API Reference","title":"GraphCore.Conversions.to_weighted_graphs_jl","text":"to_weighted_graphs_jl(g::GraphInterface{V,E,W}) where {V,E,W} ->\n    SimpleWeightedGraphs.SimpleWeightedGraph or SimpleWeightedGraphs.SimpleWeightedDiGraph\n\nConvert a WeightedGraphInterface graph to a weighted SimpleWeightedGraphs.jl graph (preserving weights, losing other properties). Requires SimpleWeightedGraphs.jl package.\n\n\n\n\n\n","category":"method"},{"location":"api/#Lattices","page":"API Reference","title":"Lattices","text":"","category":"section"},{"location":"api/#GraphCore.Lattices","page":"API Reference","title":"GraphCore.Lattices","text":"Lattice Graph Structures\n\nSpecialized graph implementations for regular lattice structures. Optimized for spatial/grid-based computations with mathematical neighbor lookup.\n\n\n\n\n\n","category":"module"},{"location":"api/#GraphCore.Lattices.HypercubicLattice","page":"API Reference","title":"GraphCore.Lattices.HypercubicLattice","text":"HypercubicLattice{D,T} <: GraphInterface\n\nA D-dimensional hypercubic lattice graph with side length of type T.\n\nType Parameters\n\nD::Int: Dimension of the lattice (1D=line, 2D=grid, 3D=cube, etc.)\nT<:Integer: Type for lattice size/coordinates\n\nStorage\n\nUses mathematical coordinate mapping instead of explicit edge storage. Memory usage: O(1) regardless of lattice size!\n\nCoordinate System\n\nVertices are numbered 1 to prod(sizes)\nCoordinates are 0-indexed: (0,0,...,0) to (size₁-1, size₂-1, ..., sizeD-1)\nPeriodic boundary conditions optional\n\nExamples\n\n# 2D grid: 10×10\nlattice_2d = HypercubicLattice{2,Int}((10, 10))\n\n# 3D cube: 5×5×5\nlattice_3d = HypercubicLattice{3,Int}((5, 5, 5))\n\n# 1D chain: 100 vertices\nlattice_1d = HypercubicLattice{1,Int}((100,))\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.Lattices.coord_to_vertex-Union{Tuple{T}, Tuple{D}, Tuple{GraphCore.Lattices.HypercubicLattice{D, T}, NTuple{D, T}}} where {D, T}","page":"API Reference","title":"GraphCore.Lattices.coord_to_vertex","text":"coord_to_vertex(g::HypercubicLattice{D,T}, coord::NTuple{D,T}) -> Int32\n\nConvert coordinates to vertex index using optimized arithmetic. Specialized for common dimensions with loop unrolling.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.is_periodic-Tuple{GraphCore.Lattices.HypercubicLattice}","page":"API Reference","title":"GraphCore.Lattices.is_periodic","text":"Check if the lattice has periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.lattice_dimension-Union{Tuple{GraphCore.Lattices.HypercubicLattice{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"API Reference","title":"GraphCore.Lattices.lattice_dimension","text":"Get the dimensions of the lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.lattice_distance-Union{Tuple{T}, Tuple{D}, Tuple{GraphCore.Lattices.HypercubicLattice{D, T}, Integer, Integer}} where {D, T}","page":"API Reference","title":"GraphCore.Lattices.lattice_distance","text":"lattice_distance(g::HypercubicLattice, u::Integer, v::Integer) -> Float64\n\nCompute the Manhattan distance between two vertices on the lattice. Accounts for periodic boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.lattice_neighbors-Tuple{GraphCore.Lattices.HypercubicLattice, Integer}","page":"API Reference","title":"GraphCore.Lattices.lattice_neighbors","text":"lattice_neighbors(g::HypercubicLattice, v::Integer) -> Vector{Int32}\n\nAlias for neighbor_indices with better name for lattice context.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.lattice_size-Tuple{GraphCore.Lattices.HypercubicLattice}","page":"API Reference","title":"GraphCore.Lattices.lattice_size","text":"Get the size tuple of the lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.Lattices.vertex_to_coord-Union{Tuple{T}, Tuple{D}, Tuple{GraphCore.Lattices.HypercubicLattice{D, T}, Integer}} where {D, T}","page":"API Reference","title":"GraphCore.Lattices.vertex_to_coord","text":"vertex_to_coord(g::HypercubicLattice{D,T}, v::Integer) -> NTuple{D,T}\n\nConvert vertex index to coordinates using optimized integer arithmetic. Fully inlined and branch-free for maximum performance.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices","page":"API Reference","title":"GraphCore.PowerOfTwoLattices","text":"Power-of-Two Hypercubic Lattices\n\nUltra-fast lattice implementation for dimensions that are powers of 2. Uses bit operations instead of division/modulo for maximum performance.\n\nRestrictions:\n\nAll dimensions must be powers of 2\nMaximum dimension D ≤ 5 (to keep neighbor tuples manageable)\nPeriodic boundary conditions only\n\n\n\n\n\n","category":"module"},{"location":"api/#GraphCore.PowerOfTwoLattices.PowerOfTwoLattice","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.PowerOfTwoLattice","text":"PowerOfTwoLattice{D} <: GraphInterface\n\nUltra-fast D-dimensional hypercubic lattice where all sizes are powers of 2. Uses bit operations for coordinate conversion and neighbor lookup.\n\nRestrictions\n\nD ≤ 5 (keeps neighbor tuples reasonable)\nAll sizes must be powers of 2: 2, 4, 8, 16, 32, 64, 128, ...\nPeriodic boundary conditions (makes bit operations clean)\n\nType Parameters\n\nD::Int: Dimension (1 ≤ D ≤ 5)\n\nExamples\n\n# 2D: 16×32 grid (2^4 × 2^5)\ng2d = P2Grid2D(4, 5)  # log₂ sizes\n\n# 3D: 8×8×16 cube (2^3 × 2^3 × 2^4)\ng3d = P2Grid3D(3, 3, 4)\n\n# 1D: 64-element chain (2^6)\ng1d = P2Chain1D(6)\n\n\n\n\n\n","category":"type"},{"location":"api/#GraphCore.PowerOfTwoLattices.P2Chain1D-Tuple{Integer}","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.P2Chain1D","text":"1D chain: size = 2^log_size\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.P2Grid2D-Tuple{Integer, Integer}","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.P2Grid2D","text":"2D grid: sizes = 2^logwidth × 2^logheight\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.P2Grid3D-Tuple{Integer, Integer, Integer}","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.P2Grid3D","text":"3D cube: sizes = 2^logwidth × 2^logheight × 2^log_depth\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.coord_to_vertex-Union{Tuple{D}, Tuple{GraphCore.PowerOfTwoLattices.PowerOfTwoLattice{D}, NTuple{D, Int32}}} where D","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.coord_to_vertex","text":"Convert coordinates to vertex using bit operations.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.lattice_dimension-Union{Tuple{GraphCore.PowerOfTwoLattices.PowerOfTwoLattice{D}}, Tuple{D}} where D","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.lattice_dimension","text":"Get lattice dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.lattice_size-Tuple{GraphCore.PowerOfTwoLattices.PowerOfTwoLattice}","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.lattice_size","text":"Get actual sizes.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphCore.PowerOfTwoLattices.vertex_to_coord-Union{Tuple{D}, Tuple{GraphCore.PowerOfTwoLattices.PowerOfTwoLattice{D}, Integer}} where D","page":"API Reference","title":"GraphCore.PowerOfTwoLattices.vertex_to_coord","text":"Convert vertex to coordinates using bit operations.\n\n\n\n\n\n","category":"method"},{"location":"design/#Design-Philosophy-and-Architecture","page":"Design Philosophy","title":"Design Philosophy & Architecture","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"This page covers the design principles, architecture, and performance characteristics of GraphCore.jl.","category":"page"},{"location":"design/#Design-Philosophy","page":"Design Philosophy","title":"Design Philosophy","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"GraphCore.jl is designed around three key principles:","category":"page"},{"location":"design/#**Performance-Oriented-Design**","page":"Design Philosophy","title":"Performance-Oriented Design","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"CSR Storage: Compressed Sparse Row format for cache-efficient traversal\nType Specialization: Parametric types enable compiler optimizations and zero-cost abstractions\nEfficient Indexing: Direct O(1) access patterns with Int32 indexing for memory efficiency\nMinimal Overhead: Compact memory layouts optimized for common graph operations","category":"page"},{"location":"design/#**Flexible-Storage-Options**","page":"Design Philosophy","title":"Flexible Storage Options","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Multiple Representations: CSR format (CoreGraph) for static analysis, adjacency lists (AdjGraph) for dynamic operations\nUnified Interface: All graph types implement the same GraphInterface for consistent usage\nProperty Integration: Built-in support for type-safe vertex and edge properties\nExternal Array Support: Stable indexing schemes for user-managed data arrays","category":"page"},{"location":"design/#**Type-Safety-and-Reliability**","page":"Design Philosophy","title":"Type Safety and Reliability","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Compile-Time Checking: Parametric types catch common errors during compilation\nClear Data Ownership: Explicit separation between graph structure, weights, and properties  \nStable Indexing: Consistent edge/vertex indices for reliable external array management\nComprehensive Validation: Input checking and well-defined method contracts","category":"page"},{"location":"design/#Architecture-Overview","page":"Design Philosophy","title":"Architecture Overview","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"GraphCore.jl\n├── GraphInterface      # Abstract interface definition\n├── CoreGraph           # CSR-based graphs (static, high-performance)\n├── AdjGraph            # Adjacency list graphs (dynamic, mutable)\n└── Builders            # Builder patterns for graph construction","category":"page"},{"location":"design/#Performance-Characteristics","page":"Design Philosophy","title":"Performance Characteristics","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Operation CoreGraph WeightedGraph AdjGraph PropertyGraph\nNeighbor Access O(1) view O(1) view O(1) direct O(1) + property*\nEdge Lookup O(degree) O(degree) O(degree) O(degree) + property*\nBounds Checking ✅ @boundscheck ✅ @boundscheck ✅ @boundscheck ✅ @boundscheck\n@inbounds Safe ✅ Full support ✅ Full support ✅ Full support ✅ Full support\nAdd Edge O(1) amortized O(1) amortized O(1) + has_edge check Inherits base type*\nRemove Edge O(degree) O(degree) O(degree) Inherits base type*\nAdd Vertex O(1) O(1) O(1) O(1) + property*\nRemove Vertex O(V+E) rebuild O(V+E) rebuild O(V+E) Inherits base type*\nInput Validation ✅ Comprehensive ✅ Comprehensive ✅ Basic ✅ Comprehensive\nMemory Layout CSR (cache-friendly) CSR + weights Adjacency lists Base + properties\nMemory Overhead Minimal +weights array +pointer arrays +property arrays","category":"page"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"*PropertyGraph wraps any base graph type and inherits its performance characteristics, plus minimal property access overhead.","category":"page"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Real-world performance notes:","category":"page"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Neighbor access: ~10-50ns per vertex depending on graph size and memory layout\nEdge operations: Times vary significantly with vertex degree and graph structure  \nAll operations benefit from @inbounds when bounds are pre-validated\nUse --check-bounds=no for maximum performance in production after testing\nCSR layout provides better cache efficiency for traversal-heavy algorithms\nProperty access adds minimal overhead when types are concrete","category":"page"},{"location":"design/#Design-Decisions-and-Trade-offs","page":"Design Philosophy","title":"Design Decisions & Trade-offs","text":"","category":"section"},{"location":"design/#Why-Julia-Idiomatic-Bounds-Checking?","page":"Design Philosophy","title":"Why Julia-Idiomatic Bounds Checking?","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Safety First: All vertex/edge access is safe by default with clear error messages\nPerformance When Needed: @inbounds provides zero-cost optimization for validated access\nFamiliar Pattern: Follows Julia's array indexing conventions that users already know\nTrade-off: Small overhead in tight loops, but eliminates silent corruption bugs","category":"page"},{"location":"design/#Why-CSR-for-CoreGraph?","page":"Design Philosophy","title":"Why CSR for CoreGraph?","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Cache Efficiency: Neighbors stored contiguously in memory\nSpace Efficiency: No pointer overhead compared to adjacency lists  \nIndex Stability: External arrays remain valid during graph analysis\nEfficient Mutations: Direct array manipulation preserves CSR benefits\nTrade-off: More complex mutation algorithms, but maintains performance characteristics","category":"page"},{"location":"design/#Why-Dual-Indexing?","page":"Design Philosophy","title":"Why Dual Indexing?","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Flexibility: Support both shared and directional edge properties\nPerformance: O(1) access during iteration via edge_index(g, v, i)\nCorrectness: Clear separation between undirected and directed semantics\nTrade-off: Slightly more complex API, but with clear documentation","category":"page"},{"location":"design/#Why-Multiple-Graph-Types?","page":"Design Philosophy","title":"Why Multiple Graph Types?","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Specialization: Each type optimized for its use case\nComposability: PropertyGraph wraps any base type\nMigration Path: Easy conversion between representations\nTrade-off: More types to learn, but unified interface","category":"page"},{"location":"design/#When-to-Use-Which-Graph-Type","page":"Design Philosophy","title":"When to Use Which Graph Type","text":"","category":"section"},{"location":"design/#**CoreGraph{D}**-Choose-When:","page":"Design Philosophy","title":"CoreGraph{D} - Choose When:","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"✅ You need maximum performance for queries and analysis\n✅ Graph structure is mostly static after initial construction  \n✅ Memory efficiency is important\n✅ You'll be doing many neighbor traversals","category":"page"},{"location":"design/#**WeightedGraph{W,D}**-Choose-When:","page":"Design Philosophy","title":"WeightedGraph{W,D} - Choose When:","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"✅ You need type-safe edge weights\n✅ Performance is critical (same as CoreGraph)\n✅ You want built-in weight management\n✅ You need directional weights in undirected graphs","category":"page"},{"location":"design/#**AdjGraph{D}**-Choose-When:","page":"Design Philosophy","title":"AdjGraph{D} - Choose When:","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"✅ You'll be frequently adding/removing edges\n✅ Graph construction is dynamic and unpredictable\n✅ Flexibility is more important than memory efficiency","category":"page"},{"location":"design/#**PropertyGraph{G,V,E}**-Choose-When:","page":"Design Philosophy","title":"PropertyGraph{G,V,E} - Choose When:","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"✅ You need to attach custom data to vertices/edges\n✅ Type safety for properties is important\n✅ You want to compose with any underlying graph type\n✅ Zero-overhead property access is required","category":"page"},{"location":"design/#Performance-Best-Practices","page":"Design Philosophy","title":"Performance Best Practices","text":"","category":"section"},{"location":"design/#**When-to-Use-@inbounds**","page":"Design Philosophy","title":"When to Use @inbounds","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"Use @inbounds in performance-critical inner loops where you can guarantee safety:","category":"page"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"# ✅ SAFE: After explicit validation\nfunction safe_fast_algorithm(g, valid_vertices)\n    # Pre-validate all vertices are in bounds\n    @assert all(has_vertex(g, v) for v in valid_vertices)\n    \n    for v in valid_vertices\n        # Safe to use @inbounds - we validated vertices above\n        neighbors = @inbounds neighbor_indices(g, v)\n        for (i, neighbor) in enumerate(neighbors)\n            edge_idx = @inbounds directed_edge_index(g, v, i)\n            # Fast operations...\n        end\n    end\nend\n\n# ❌ UNSAFE: Don't use @inbounds on user input\nfunction unsafe_example(g, user_vertex)\n    # DON'T DO THIS - user_vertex might be out of bounds!\n    neighbors = @inbounds neighbor_indices(g, user_vertex)  # Potential crash\nend","category":"page"},{"location":"design/#**Bounds-Checking-Control**","page":"Design Philosophy","title":"Bounds Checking Control","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"# For maximum performance in production (after thorough testing):\n# julia --check-bounds=no script.jl\n\n# For development and debugging (default):\n# julia --check-bounds=yes script.jl","category":"page"},{"location":"design/#**Memory-and-Cache-Optimization**","page":"Design Philosophy","title":"Memory and Cache Optimization","text":"","category":"section"},{"location":"design/","page":"Design Philosophy","title":"Design Philosophy","text":"# ✅ GOOD: Use CoreGraph for analysis workloads\nanalysis_graph = build_core_graph(edges; directed=false)\n\n# ✅ GOOD: Batch operations for cache efficiency\nfunction efficient_traversal(g)\n    for v in vertices(g)\n        neighbors = neighbor_indices(g, v)  # O(1) view, cache-friendly\n        for neighbor in neighbors\n            # Process all neighbors together\n        end\n    end\nend","category":"page"},{"location":"docindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"docindex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"#GraphCore.jl-User-Guide","page":"Home","title":"GraphCore.jl User Guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A high-performance, type-safe graph library for Julia with a focus on efficiency, flexibility, and ease of use.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GraphCore.jl provides multiple specialized graph data structures optimized for different use cases - from static analysis with CoreGraph's compressed storage to dynamic construction with AdjGraph's adjacency lists. All graph types support efficient mutations, type-safe properties, and seamless integration with the Graphs.jl ecosystem, allowing you to use existing algorithms while benefiting from GraphCore's performance optimizations.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using GraphCore\n\n# Create your first graph\nedges = [(1,2), (2,3), (1,3)]\ng = build_core_graph(edges; directed=false)\n\n# Query the graph\nprintln(\"Graph has $(num_vertices(g)) vertices and $(num_edges(g)) edges\")\nprintln(\"Neighbors of vertex 1: $(collect(neighbor_indices(g, 1)))\")","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"GraphCore\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For optional features:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# For benchmarking examples\nPkg.add(\"BenchmarkTools\")\n\n# For plotting examples  \nPkg.add([\"Plots\", \"GraphRecipes\"])","category":"page"},{"location":"#Graph-Types-Overview","page":"Home","title":"Graph Types Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphCore provides four main graph types, each optimized for different use cases:","category":"page"},{"location":"#**CoreGraph**-High-Performance-Static-Analysis","page":"Home","title":"CoreGraph - High-Performance Static Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Best for: Fast queries, analysis algorithms, memory efficiency\ng = build_core_graph([(1,2), (2,3), (1,3)]; directed=false)\n\n# Fast neighbor access\nfor neighbor in neighbor_indices(g, 1)\n    println(\"Neighbor: $neighbor\")\nend\n\n# Efficient mutations\nadd_edge!(g, 1, 4)\nadd_vertex!(g)","category":"page"},{"location":"#**WeightedGraph**-Graphs-with-Edge-Weights","page":"Home","title":"WeightedGraph - Graphs with Edge Weights","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Best for: Algorithms needing edge weights (shortest paths, MST, etc.)\nedges = [(1,2), (2,3), (1,3)]\nweights = [1.0, 2.5, 1.2]\nwg = build_weighted_graph(edges, weights; directed=false)\n\n# Access weights efficiently\nfor (neighbor, weight) in neighbor_weights(wg, 1)\n    println(\"Edge to $neighbor has weight $weight\")\nend\n\n# Add weighted edges\nadd_edge!(wg, 1, 4, 3.7)","category":"page"},{"location":"#**PropertyGraph**-Graphs-with-Custom-Data","page":"Home","title":"PropertyGraph - Graphs with Custom Data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Best for: Attaching custom data to vertices and edges\nvertices = [\"Alice\", \"Bob\", \"Charlie\"]\nedges = [(1,2), (2,3), (1,3)]\nedge_types = [\"friend\", \"colleague\", \"family\"]\n\npg = build_property_graph(edges, vertices, edge_types; directed=false)\n\n# Access properties\nprintln(\"Vertex 1 is: $(vertex_property(pg, 1))\")\nprintln(\"Edge (1,2) type: $(edge_property(pg, 1, 2))\")","category":"page"},{"location":"#**AdjGraph**-Dynamic-Modification","page":"Home","title":"AdjGraph - Dynamic Modification","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# Best for: Frequent edge additions/removals during construction\ng = build_adj_graph([(1,2)]; directed=false)\n\n# Very fast mutations\nadd_edge!(g, 2, 3)  # O(1)\nadd_edge!(g, 3, 4)  # O(1)\nremove_edge!(g, 1, 2)  # O(degree)","category":"page"},{"location":"#Common-Workflows","page":"Home","title":"Common Workflows","text":"","category":"section"},{"location":"#Building-Graphs","page":"Home","title":"Building Graphs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"From edge lists:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Simple unweighted graph\nedges = [(1,2), (2,3), (3,4), (4,1)]\ng = build_core_graph(edges; directed=true)\n\n# With weights\nweights = [1.0, 2.0, 1.5, 0.8]\nwg = build_weighted_graph(edges, weights; directed=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Incrementally with GraphBuilder:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GraphCore.Builders\n\nbuilder = WeightedGraphBuilder(Float64; directed=false)\nadd_edge!(builder, 1, 2; weight=1.5)\nadd_edge!(builder, 2, 3; weight=2.0)\nadd_edge!(builder, 1, 3; weight=1.0)\n\n# Convert to your preferred graph type\ncore_g = build_graph(builder, CoreGraph)      # For analysis\nadj_g = build_graph(builder, AdjGraph)        # For further modifications","category":"page"},{"location":"","page":"Home","title":"Home","text":"From other graph libraries:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GraphCore.Conversions\nusing Graphs\n\n# From Graphs.jl\nsimple_g = SimpleGraph(5)\nadd_edge!(simple_g, 1, 2)\nour_g = from_graphs_jl(simple_g)\n\n# To Graphs.jl  \ngraphs_g = to_graphs_jl(our_g)","category":"page"},{"location":"#Graph-Analysis","page":"Home","title":"Graph Analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Basic queries:","category":"page"},{"location":"","page":"Home","title":"Home","text":"g = build_core_graph([(1,2), (2,3), (1,3)]; directed=false)\n\n# Graph properties\nprintln(\"Vertices: $(num_vertices(g))\")\nprintln(\"Edges: $(num_edges(g))\")\nprintln(\"Directed: $(is_directed(g))\")\n\n# Vertex queries\nprintln(\"Degree of vertex 1: $(degree(g, 1))\")\nprintln(\"Neighbors: $(collect(neighbor_indices(g, 1)))\")\n\n# Edge queries  \nprintln(\"Has edge (1,2): $(has_edge(g, 1, 2))\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Iteration patterns:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Iterate over all vertices\nfor v in vertices(g)\n    println(\"Processing vertex $v\")\nend\n\n# Iterate over all edges\nfor (u, v) in edges(g)\n    println(\"Edge: $u → $v\")\nend\n\n# Iterate over neighbors efficiently\nfor v in vertices(g)\n    for neighbor in neighbor_indices(g, v)\n        println(\"$v is connected to $neighbor\")\n    end\nend","category":"page"},{"location":"#Graph-Modification","page":"Home","title":"Graph Modification","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Adding elements:","category":"page"},{"location":"","page":"Home","title":"Home","text":"g = build_core_graph([(1,2)]; directed=false)\n\n# Add vertices and edges\nnew_vertex = add_vertex!(g)  # Returns vertex index\nadd_edge!(g, 1, new_vertex)\nadd_edge!(g, 2, new_vertex)\n\n# For weighted graphs\nwg = build_weighted_graph([(1,2)], [1.0]; directed=false)\nadd_edge!(wg, 1, 3, 2.5)  # vertex 3, weight 2.5","category":"page"},{"location":"","page":"Home","title":"Home","text":"Removing elements:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Remove edges\nremove_edge!(g, 1, 2)\n\n# Remove vertices (removes all connected edges)\nremove_vertex!(g, 3)","category":"page"},{"location":"#Converting-Between-Types","page":"Home","title":"Converting Between Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Easy conversions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Start with one type\nadj_g = build_adj_graph([(1,2), (2,3)]; directed=false)\n\n# Convert as needed\ncore_g = CoreGraph(adj_g)           # For fast analysis\nweighted_g = WeightedGraph(core_g)  # Add weight support\nproperty_g = PropertyGraph(core_g, [\"A\", \"B\", \"C\"], [\"edge1\", \"edge2\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Type-safe conversions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"directed_g = build_core_graph([(1,2)]; directed=true)\n\n# This prevents mistakes:\n# undirected_g = CoreGraph{false}(directed_g)  # Would throw error!\n\n# Explicit conversion when you know what you're doing:\nundirected_g = CoreGraph{false}(edges(directed_g))  # OK","category":"page"},{"location":"#Working-with-Properties","page":"Home","title":"Working with Properties","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Vertex properties:","category":"page"},{"location":"","page":"Home","title":"Home","text":"names = [\"Alice\", \"Bob\", \"Charlie\"]\ng = build_property_graph([(1,2), (2,3)], names, String[]; directed=false)\n\n# Access properties\nprintln(vertex_property(g, 1))  # \"Alice\"\n# or equivalently\nprintln(g[1])\n\n# Modify properties\nset_vertex_property!(g, 1, \"Alice Smith\") # of g[1] = ...","category":"page"},{"location":"","page":"Home","title":"Home","text":"Edge properties:","category":"page"},{"location":"","page":"Home","title":"Home","text":"edges = [(1,2), (2,3)]\nedge_labels = [\"friend\", \"colleague\"]\ng = build_property_graph(edges, String[], edge_labels; directed=false)\n\n# Access edge properties\nprintln(edge_property(g, 1, 2))  # \"friend\"\n# or equivalently\nprintln(g[1 => 2])","category":"page"},{"location":"#Integration-with-Graphs.jl","page":"Home","title":"Integration with Graphs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphCore graphs work seamlessly with the Graphs.jl ecosystem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Graphs, GraphCore\n\ng = build_core_graph([(1,2), (2,3), (1,3)]; directed=false)\n\n# Standard Graphs.jl functions work\nprintln(\"Vertices: $(nv(g))\")\nprintln(\"Edges: $(ne(g))\")\nprintln(\"Neighbors of 1: $(outneighbors(g, 1))\")\n\n# Algorithms work too\nwg = build_weighted_graph([(1,2), (2,3)], [1.0, 2.0]; directed=false)\npaths = dijkstra_shortest_paths(wg, 1)","category":"page"},{"location":"#Safety-and-Performance","page":"Home","title":"Safety and Performance","text":"","category":"section"},{"location":"#Bounds-Checking","page":"Home","title":"Bounds Checking","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphCore provides safe access by default with optimizations available:","category":"page"},{"location":"","page":"Home","title":"Home","text":"g = build_core_graph([(1,2), (2,3)]; directed=false)\n\n# Safe by default\ntry\n    neighbor_indices(g, 10)  # BoundsError: vertex 10 out of bounds\ncatch e\n    println(\"Caught: $e\")\nend\n\n# Optimize when you know access is safe\nfunction fast_algorithm(g, valid_vertices)\n    for v in valid_vertices\n        # @inbounds skips bounds checking for speed\n        neighbors = @inbounds neighbor_indices(g, v)\n        # ... fast inner loop\n    end\nend","category":"page"},{"location":"#Edge-Iterator-Information","page":"Home","title":"Edge Iterator Information","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GraphCore provides helpful edge iterator displays:","category":"page"},{"location":"","page":"Home","title":"Home","text":"g = build_core_graph([(1,2), (2,3), (1,3)]; directed=false)\n\nprintln(edges(g))\n# Output: \"EdgeIterator over 3 edges from CoreGraph (undirected): (1, 2), (1, 3), (2, 3)\"\n\n# Shows: edge count, graph type, directedness, and preview","category":"page"},{"location":"#Next-Steps","page":"Home","title":"Next Steps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Design Philosophy - Architecture and performance details  \nAPI Reference - Complete function documentation\nExamples - Check the examples/ directory for:\nPerformance benchmarks\nAlgorithm implementations\nPlotting examples\nGraphs.jl integration","category":"page"},{"location":"#Need-Help?","page":"Home","title":"Need Help?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check the examples in the examples/ directory\nLook at the comprehensive test suite in test/\nSee the API reference for detailed function documentation","category":"page"}]
}
