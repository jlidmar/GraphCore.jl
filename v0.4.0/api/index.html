<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · GraphCore.jl</title><meta name="title" content="API Reference · GraphCore.jl"/><meta property="og:title" content="API Reference · GraphCore.jl"/><meta property="twitter:title" content="API Reference · GraphCore.jl"/><meta name="description" content="Documentation for GraphCore.jl."/><meta property="og:description" content="Documentation for GraphCore.jl."/><meta property="twitter:description" content="Documentation for GraphCore.jl."/><meta property="og:url" content="https://jlidmar.github.io/GraphCore.jl/api/"/><meta property="twitter:url" content="https://jlidmar.github.io/GraphCore.jl/api/"/><link rel="canonical" href="https://jlidmar.github.io/GraphCore.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GraphCore.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../design/">Design Philosophy</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Core-Types-and-Functions"><span>Core Types and Functions</span></a></li><li><a class="tocitem" href="#Graph-Construction"><span>Graph Construction</span></a></li><li><a class="tocitem" href="#Conversions"><span>Conversions</span></a></li><li><a class="tocitem" href="#Lattices"><span>Lattices</span></a></li></ul></li><li><a class="tocitem" href="../docindex/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jlidmar/GraphCore.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jlidmar/GraphCore.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Core-Types-and-Functions"><a class="docs-heading-anchor" href="#Core-Types-and-Functions">Core Types and Functions</a><a id="Core-Types-and-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Types-and-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.AdjGraph" href="#GraphCore.AdjGraph"><code>GraphCore.AdjGraph</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdjGraph{D} &lt;: GraphInterface</code></pre><p>Dynamic graph using adjacency lists (Vector{Vector{Int32}}) for neighbor storage. Optimized for structural mutations with reasonable query performance.</p><p><strong>Type Parameters</strong></p><ul><li><code>D::Bool</code>: Directedness flag (true = directed, false = undirected)</li></ul><p><strong>Fields (Internal - Access via interface methods)</strong></p><ul><li><code>neighbors::Vector{Vector{Int32}}</code>: Per-vertex neighbor lists</li><li><code>neighbor_to_edge::Vector{Vector{Int32}}</code>: Maps neighbor positions to edge indices (undirected only)</li><li><code>num_edges::Int32</code>: Number of (undirected) edges</li></ul><p><strong>Construction</strong></p><p>Use <code>build_adj_graph()</code> or <code>build_graph(AdjGraph, ...)</code> for safe construction:</p><pre><code class="language-julia hljs"># Basic construction
edges = [(1,2), (2,3), (1,3)]
g = build_adj_graph(edges; directed=false)

# Direct type construction with mutation
g = build_graph(AdjGraph, edges; directed=false)
add_edge!(g, 4, 1)  # Efficient dynamic modification</code></pre><p><strong>Memory Layout Example</strong></p><p>For graph with edges [(1,2), (2,3), (1,3)], undirected:</p><pre><code class="nohighlight hljs">neighbors = [[2,3], [1,3], [1,2]]           # Vertex 1: neighbors 2,3; Vertex 2: neighbors 1,3, etc.
neighbor_to_edge = [[1,3], [1,2], [3,2]]    # Maps: v1&#39;s neighbor 2→edge 1, v1&#39;s neighbor 3→edge 3, etc.</code></pre><p><strong>Performance Notes</strong></p><ul><li><strong>Best for</strong>: Dynamic graphs with frequent add/remove operations</li><li><strong>Mutations</strong>: O(1) additions, O(degree) removals</li><li><strong>Memory</strong>: ~16-24 bytes per directed edge (vector overhead + pointers)</li><li><strong>Cache</strong>: Good for sparse graphs, less optimal for dense graphs</li></ul><p><strong>Mutation Support</strong></p><pre><code class="language-julia hljs"># Efficient dynamic operations
new_vertex = add_vertex!(g)           # O(1) - just adds empty vectors
edge_idx = add_edge!(g, u, v)         # O(1) amortized - vector push
success = remove_edge!(g, u, v)       # O(degree) - find and remove
success = remove_vertex!(g, v)        # O(V + incident edges) - updates all references

# ⚠️ Warning: Removals may invalidate edge indices
# External arrays indexed by edges will become inconsistent</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/AdjGraph.jl#L65-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.AdjGraph-Tuple{GraphInterface}" href="#GraphCore.AdjGraph-Tuple{GraphInterface}"><code>GraphCore.AdjGraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdjGraph(g::GraphInterface) -&gt; AdjGraph</code></pre><p>Convert any GraphInterface implementation to an AdjGraph using constructor syntax. This is an idiomatic Julia alternative to <code>to_adj_graph(g)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Constructor style (idiomatic)
adj_g = AdjGraph(core_graph)

# Equivalent to conversion function
adj_g = to_adj_graph(core_graph)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/AdjGraph.jl#L500-L514">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.AdjGraph-Union{Tuple{GraphInterface}, Tuple{D}} where D" href="#GraphCore.AdjGraph-Union{Tuple{GraphInterface}, Tuple{D}} where D"><code>GraphCore.AdjGraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdjGraph{D}(g::GraphInterface) -&gt; AdjGraph{D}</code></pre><p>Convert any GraphInterface to an AdjGraph with explicit directedness type parameter. The source graph must have the same directedness as specified by the type parameter.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Type-safe conversions (will succeed)
directed_adj = AdjGraph{true}(directed_core_graph)
undirected_adj = AdjGraph{false}(undirected_core_graph)

# Type mismatch (will throw AssertionError)
# AdjGraph{true}(undirected_graph)  # ERROR!</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/AdjGraph.jl#L517-L532">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.CoreGraph" href="#GraphCore.CoreGraph"><code>GraphCore.CoreGraph</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoreGraph{D} &lt;: GraphInterface</code></pre><p>High-performance graph using Compressed Sparse Row (CSR) storage format.</p><p><strong>Type Parameters</strong></p><ul><li><code>D::Bool</code>: Directedness flag (true = directed, false = undirected)</li></ul><p><strong>Fields (Internal - Access via interface methods)</strong></p><ul><li><code>vertex_offsets::Vector{Int32}</code>: CSR row pointers (length = nv + 1)</li><li><code>neighbors::Vector{Int32}</code>: Flattened neighbor lists</li><li><code>neighbor_to_edge::Vector{Int32}</code>: Maps neighbor positions to undirected edge indices (undirected only)</li><li><code>num_edges::Int32</code>: Number of (undirected) edges</li></ul><p><strong>Construction</strong></p><p>Use <code>build_core_graph()</code> or <code>build_graph(CoreGraph, ...)</code> for safe construction:</p><pre><code class="language-julia hljs"># Basic construction
edges = [(1,2), (2,3), (1,3)]
g = build_core_graph(edges; directed=false)

# With validation disabled (faster, but unsafe)
g = build_graph(CoreGraph, edges; directed=false, validate=false)</code></pre><p><strong>Memory Layout Example</strong></p><p>For graph with edges [(1,2), (2,3), (1,3)], undirected:</p><pre><code class="nohighlight hljs">vertex_offsets = [1, 3, 6, 8]       # Vertex 1: neighbors[1:2], Vertex 2: neighbors[3:5], etc.
neighbors = [2, 3, 1, 3, 1, 2]      # Flattened: [neighbors(1), neighbors(2), neighbors(3)]
neighbor_to_edge = [1, 3, 1, 2, 3, 2] # Maps each neighbor to its edge index</code></pre><p><strong>Performance Notes</strong></p><ul><li><strong>Best for</strong>: Static graphs with frequent neighbor access</li><li><strong>Avoid for</strong>: Graphs requiring frequent structural modifications</li><li><strong>Memory</strong>: ~12-16 bytes per directed edge (depending on architecture)</li><li><strong>Cache</strong>: Excellent locality for neighbor iteration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/CoreGraph.jl#L64-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.CoreGraph-Tuple{GraphInterface}" href="#GraphCore.CoreGraph-Tuple{GraphInterface}"><code>GraphCore.CoreGraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoreGraph(g::GraphInterface) -&gt; CoreGraph</code></pre><p>Convert any GraphInterface implementation to a CoreGraph using constructor syntax. This is an idiomatic Julia alternative to <code>to_core_graph(g)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Constructor style (idiomatic)
core_g = CoreGraph(adj_graph)

# Equivalent to conversion function
core_g = to_core_graph(adj_graph)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/CoreGraph.jl#L478-L492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.CoreGraph-Union{Tuple{GraphInterface}, Tuple{D}} where D" href="#GraphCore.CoreGraph-Union{Tuple{GraphInterface}, Tuple{D}} where D"><code>GraphCore.CoreGraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CoreGraph{D}(g::GraphInterface) -&gt; CoreGraph{D}</code></pre><p>Convert any GraphInterface to a CoreGraph with explicit directedness type parameter. The source graph must have the same directedness as specified by the type parameter.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Type-safe conversions (will succeed)
directed_core = CoreGraph{true}(directed_adj_graph)
undirected_core = CoreGraph{false}(undirected_adj_graph)

# Type mismatch (will throw TypeError)
# CoreGraph{true}(undirected_graph)  # ERROR!</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/CoreGraph.jl#L495-L510">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.GraphInterface" href="#GraphCore.GraphInterface"><code>GraphCore.GraphInterface</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GraphInterface &lt;: AbstractGraph{Int32}</code></pre><p>Base abstract type for all graphs in the GraphCore ecosystem. All vertices are indexed by Int32 integers 1, 2, ..., num_vertices(g).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.PropertyGraph" href="#GraphCore.PropertyGraph"><code>GraphCore.PropertyGraph</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PropertyGraph{G,V,E} &lt;: PropertyGraphInterface{V,E}</code></pre><p>Universal property graph that wraps any base graph type with typed vertex and edge properties.</p><p><strong>Type Parameters</strong></p><ul><li><code>G&lt;:GraphInterface</code>: Base graph type (CoreGraph, WeightedGraph, AdjGraph, etc.)</li><li><code>V</code>: Vertex property type</li><li><code>E</code>: Edge property type</li></ul><p><strong>Design Benefits</strong></p><ul><li><strong>Universal wrapper</strong>: Works with any GraphInterface implementation</li><li><strong>Zero-cost delegation</strong>: All structural operations forwarded to base graph</li><li><strong>Type safety</strong>: Compile-time property type guarantees</li><li><strong>Automatic mutations</strong>: Inherits mutation capabilities from base graph</li><li><strong>Memory efficiency</strong>: No overhead when properties are unused</li></ul><p><strong>Usage Patterns</strong></p><pre><code class="language-julia hljs"># Static analysis with CoreGraph base
core_g = build_core_graph(edges; directed=false)
vertex_labels = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;]
edge_types = [&quot;friend&quot;, &quot;colleague&quot;, &quot;family&quot;]
pg = PropertyGraph(core_g, vertex_labels, edge_types)

# Access patterns
name = pg[1]                           # Vertex property via indexing
edge_type = edge_property(pg, 2)       # Edge property by index
pg[1] = &quot;Alice Updated&quot;                # Property modification

# Dynamic graphs with AdjGraph base
adj_g = build_adj_graph(edges; directed=false)
pg_mut = PropertyGraph(adj_g, vertex_labels, edge_types)

# Efficient mutations (when base graph supports them)
new_vertex = add_vertex!(pg_mut, &quot;David&quot;)           # O(1) addition
edge_idx = add_edge!(pg_mut, 1, new_vertex, &quot;buddy&quot;)  # O(1) addition

# Combined with weights
weighted_g = build_weighted_graph(edges, weights; directed=false)
pg = PropertyGraph(weighted_g, vertex_labels, edge_types)
# Now has both weights and properties available</code></pre><p><strong>Mutation Behavior</strong></p><pre><code class="language-julia hljs"># Mutations work when base graph supports them
adj_pg = PropertyGraph(build_adj_graph(edges), v_props, e_props)
add_edge!(adj_pg, u, v, edge_prop)  # ✅ Works - AdjGraph supports mutations

# Mutations fail gracefully when base graph doesn&#39;t support them
core_pg = PropertyGraph(build_core_graph(edges), v_props, e_props)
add_edge!(core_pg, u, v, edge_prop)  # ❌ MethodError - CoreGraph is immutable

# Property arrays are automatically maintained during mutations
original_count = length(adj_pg.edge_properties)
edge_idx = add_edge!(adj_pg, u, v, edge_prop)
@assert length(adj_pg.edge_properties) == original_count + 1</code></pre><p><strong>Performance Notes</strong></p><ul><li><strong>Delegation overhead</strong>: Typically optimized away by compiler</li><li><strong>Mutation performance</strong>: Same as underlying graph type</li><li><strong>Property management</strong>: Automatic with minimal overhead</li><li><strong>Memory</strong>: Base graph memory + property arrays + small wrapper overhead</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/PropertyGraph.jl#L24-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.PropertyGraphInterface" href="#GraphCore.PropertyGraphInterface"><code>GraphCore.PropertyGraphInterface</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PropertyGraphInterface{V,E,W} &lt;: GraphInterface
Abstract interface for property graphs, which support vertex and edge properties.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L73-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.WeightedAdjGraph" href="#GraphCore.WeightedAdjGraph"><code>GraphCore.WeightedAdjGraph</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WeightedAdjGraph{W,D} &lt;: WeightedGraphInterface{W}</code></pre><p>Weighted dynamic graph extending AdjGraph with parallel weight storage. Combines the mutation efficiency of adjacency lists with type-safe weights.</p><p><strong>Type Parameters</strong></p><ul><li><code>W&lt;:Number</code>: Weight type (Float64, Int32, etc.)</li><li><code>D::Bool</code>: Directedness flag</li></ul><p><strong>Key Features</strong></p><ul><li><strong>Same mutation performance as AdjGraph</strong> for structural operations</li><li><strong>Type-safe weights</strong> with compile-time guarantees</li><li><strong>Directional weights</strong> even for undirected graphs</li><li><strong>Parallel storage</strong> maintaining weight-neighbor correspondence</li></ul><p><strong>Weight Semantics</strong></p><p><strong>Important</strong>: Weights are always directional, even for undirected graphs. This allows asymmetric edge properties while maintaining undirected connectivity.</p><pre><code class="language-julia hljs"># For undirected edge with different directional costs:
g = build_weighted_adj_graph([(1,2)], [1.5]; directed=false)
# Internally stores: neighbors[1]=[2], weights[1]=[1.5]
#                   neighbors[2]=[1], weights[2]=[1.5]
# But weights can be modified independently if needed

# Access via directional indexing:
idx_12 = find_directed_edge_index(g, 1, 2)  # Different from (2,1)
idx_21 = find_directed_edge_index(g, 2, 1)
weight_12 = edge_weight(g, idx_12)  # Initial: 1.5
weight_21 = edge_weight(g, idx_21)  # Initial: 1.5 (same value, different storage)</code></pre><p><strong>Mutation Examples</strong></p><pre><code class="language-julia hljs">edges = [(1,2), (2,3)]
weights = [1.0, 2.0]
g = build_weighted_adj_graph(edges, weights; directed=false)

# Add weighted edge
edge_idx = add_edge!(g, 3, 1, 1.5)  # O(1) amortized

# Efficient weight access during iteration
for (neighbor, weight) in neighbor_weights(g, v)
    process_weighted_neighbor(neighbor, weight)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/AdjGraph.jl#L241-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.WeightedAdjGraph-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W" href="#GraphCore.WeightedAdjGraph-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W"><code>GraphCore.WeightedAdjGraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WeightedAdjGraph(g::WeightedGraphInterface{W}) -&gt; WeightedAdjGraph{W}
WeightedAdjGraph{W}(g::WeightedGraphInterface{W}) -&gt; WeightedAdjGraph{W}
WeightedAdjGraph{W,D}(g::WeightedGraphInterface{W}) -&gt; WeightedAdjGraph{W,D}</code></pre><p>Convert any WeightedGraphInterface to a WeightedAdjGraph using constructor syntax. Supports multiple forms with different levels of type specification.</p><p><strong>Constructor Forms</strong></p><ul><li><code>WeightedAdjGraph(g)</code>: Auto-infer weight type and directedness</li><li><code>WeightedAdjGraph{W}(g)</code>: Explicit weight type parameter</li><li><code>WeightedAdjGraph{W,D}(g)</code>: Explicit weight type and directedness parameters</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic constructor (auto-infer types)
weighted_adj = WeightedAdjGraph(weighted_core_graph)

# Explicit weight type
weighted_adj = WeightedAdjGraph{Float64}(core_graph)

# Full type specification
# Full type specification with directedness assertion
directed_weighted_adj = WeightedAdjGraph{Float64,true}(directed_weighted_graph)   # ✅ OK
undirected_weighted_adj = WeightedAdjGraph{Float64,false}(undirected_weighted_graph) # ✅ OK
# WeightedAdjGraph{Float64,true}(undirected_graph)  # ❌ ERROR: directedness mismatch

# Equivalent to conversion function
weighted_adj = to_weighted_adj_graph(weighted_core_graph)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/AdjGraph.jl#L538-L568">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.WeightedGraph" href="#GraphCore.WeightedGraph"><code>GraphCore.WeightedGraph</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WeightedGraph{W,D} &lt;: WeightedGraphInterface{W}</code></pre><p>Weighted graph extending CoreGraph with parallel weight storage.</p><p><strong>Type Parameters</strong></p><ul><li><code>W&lt;:Number</code>: Weight type (Float64, Int32, etc.)</li><li><code>D::Bool</code>: Directedness flag</li></ul><p><strong>Key Features</strong></p><ul><li><strong>Same performance as CoreGraph</strong> for structural operations</li><li><strong>Type-safe weights</strong> with compile-time guarantees</li><li><strong>Directional weights</strong> even for undirected graphs</li><li><strong>Parallel storage</strong> for cache-efficient weight access</li></ul><p><strong>Weight Semantics</strong></p><p><strong>Important</strong>: Weights are always directional, even for undirected graphs. This allows asymmetric edge properties (e.g., different costs per direction).</p><pre><code class="language-julia hljs"># For undirected edge (1,2) with weight 1.5:
edge_weight(g, find_directed_edge_index(g, 1, 2)) # → 1.5
edge_weight(g, find_directed_edge_index(g, 2, 1)) # → 1.5 (same value, different index)

# But can be set differently if needed:
weights = [1.5, 2.0]  # Different costs for each direction
g = build_weighted_graph([(1,2), (2,1)], weights; directed=true)</code></pre><p><strong>Construction Examples</strong></p><pre><code class="language-julia hljs"># Undirected weighted graph
edges = [(1,2), (2,3)]
weights = [1.5, 2.0]
g = build_weighted_graph(edges, weights; directed=false)

# Type-specific construction
g = build_graph(WeightedGraph{Float32}, edges; weights=weights, directed=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/CoreGraph.jl#L224-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.WeightedGraph-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W" href="#GraphCore.WeightedGraph-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W"><code>GraphCore.WeightedGraph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WeightedGraph(g::WeightedGraphInterface{W}) -&gt; WeightedGraph{W}
WeightedGraph{W}(g::WeightedGraphInterface{W}) -&gt; WeightedGraph{W}
WeightedGraph{W,D}(g::WeightedGraphInterface{W}) -&gt; WeightedGraph{W,D}</code></pre><p>Convert any WeightedGraphInterface to a WeightedGraph using constructor syntax. Supports multiple forms with different levels of type specification.</p><p><strong>Constructor Forms</strong></p><ul><li><code>WeightedGraph(g)</code>: Auto-infer weight type and directedness</li><li><code>WeightedGraph{W}(g)</code>: Explicit weight type parameter</li><li><code>WeightedGraph{W,D}(g)</code>: Explicit weight type and directedness parameters (with type assertion)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic constructor (auto-infer types)
weighted_g = WeightedGraph(weighted_adj_graph)

# Explicit weight type
weighted_g = WeightedGraph{Float64}(adj_graph)

# Full type specification with directedness assertion
directed_weighted = WeightedGraph{Float64,true}(directed_weighted_graph)   # ✅ OK
undirected_weighted = WeightedGraph{Float64,false}(undirected_weighted_graph) # ✅ OK
# WeightedGraph{Float64,true}(undirected_graph)  # ❌ ERROR: directedness mismatch

# Equivalent to conversion function
weighted_g = to_weighted_graph(weighted_adj_graph)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/CoreGraph.jl#L516-L545">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.WeightedGraphInterface" href="#GraphCore.WeightedGraphInterface"><code>GraphCore.WeightedGraphInterface</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WeightedGraphInterface &lt;: GraphInterface</code></pre><p>Interface for weighted graphs, extending the core graph interface. <code>W</code> is the type of edge weights, typically a numeric type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.add_edge!" href="#GraphCore.add_edge!"><code>GraphCore.add_edge!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_edge!(g::GraphInterface, u::Integer, v::Integer, ...) -&gt; Int32</code></pre><p>Add an edge from u to v with the optinal properties. Returns the edge index of the newly added edge, or 0 if edge already exists. For undirected graphs, this adds the edge in both directions internally. Only available for mutable graph types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L448-L455">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.add_edge!-Tuple{AdjGraph, Integer, Integer}" href="#GraphCore.add_edge!-Tuple{AdjGraph, Integer, Integer}"><code>GraphCore.add_edge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_edge!(g::AdjGraph, u::Integer, v::Integer) -&gt; Int32</code></pre><p>Add an edge from u to v and return the edge index (or 0 if already exists).</p><p><strong>Performance</strong></p><ul><li><strong>Time Complexity</strong>: O(1) amortized (vector push operations)</li><li><strong>Space Complexity</strong>: O(1) per direction</li><li><strong>Index Stability</strong>: All existing indices remain valid, new edge gets max+1</li></ul><p><strong>Behavior Details</strong></p><ul><li><strong>Directed graphs</strong>: Adds only u→v edge</li><li><strong>Undirected graphs</strong>: Adds both u→v and v→u internally with same edge index</li><li><strong>Duplicate detection</strong>: Returns 0 if edge already exists (no modification)</li><li><strong>Index assignment</strong>: New edges get next available index</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">g = build_adj_graph([(1,2)]; directed=false)
@assert num_edges(g) == 1

# Add new edge
edge_idx = add_edge!(g, 2, 3)
@assert edge_idx == 2  # Next available index
@assert num_edges(g) == 2
@assert has_edge(g, 2, 3) &amp;&amp; has_edge(g, 3, 2)  # Both directions for undirected

# Try duplicate
duplicate_idx = add_edge!(g, 1, 2)
@assert duplicate_idx == 0  # Already exists
@assert num_edges(g) == 2    # No change</code></pre><p><strong>Error Conditions</strong></p><p>Throws <code>BoundsError</code> if vertices u or v don&#39;t exist in the graph. Use <code>add_vertex!</code> first if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/AdjGraph.jl#L798-L834">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.add_edge!-Union{Tuple{D}, Tuple{CoreGraph{D}, Integer, Integer}} where D" href="#GraphCore.add_edge!-Union{Tuple{D}, Tuple{CoreGraph{D}, Integer, Integer}} where D"><code>GraphCore.add_edge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_edge!(g::CoreGraph, u::Integer, v::Integer) -&gt; Int32</code></pre><p>Add an edge from u to v and return the edge index (or 0 if edge already exists).</p><p><strong>Efficient Implementation</strong>: O(degree) operation that extends the CSR arrays and updates offsets.</p><p>For undirected graphs, this adds the edge in both directions internally.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">g = build_core_graph([(1,2)]; directed=false)
edge_idx = add_edge!(g, 1, 3)  # Returns edge index
@assert has_edge(g, 1, 3) &amp;&amp; has_edge(g, 3, 1)  # Both directions for undirected</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/CoreGraph.jl#L756-L771">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.add_edge!-Union{Tuple{D}, Tuple{W}, Tuple{WeightedGraph{W, D}, Integer, Integer, W}} where {W, D}" href="#GraphCore.add_edge!-Union{Tuple{D}, Tuple{W}, Tuple{WeightedGraph{W, D}, Integer, Integer, W}} where {W, D}"><code>GraphCore.add_edge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_edge!(g::WeightedGraph{W}, u::Integer, v::Integer, weight::W) -&gt; Int32</code></pre><p>Add a weighted edge from u to v and return the edge index (or 0 if edge already exists).</p><p><strong>Efficient Implementation</strong>: O(degree) operation that extends the CSR arrays and updates offsets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/CoreGraph.jl#L1054-L1060">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.add_edge!-Union{Tuple{E}, Tuple{V}, Tuple{G}, Tuple{PropertyGraph{G, V, E}, Integer, Integer, E}} where {G, V, E}" href="#GraphCore.add_edge!-Union{Tuple{E}, Tuple{V}, Tuple{G}, Tuple{PropertyGraph{G, V, E}, Integer, Integer, E}} where {G, V, E}"><code>GraphCore.add_edge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_edge!(g::PropertyGraph{G,V,E}, u::Integer, v::Integer, edge_prop::E) -&gt; Int32</code></pre><p>Add an edge from u to v with the specified edge property. Returns the edge index of the newly added edge, or 0 if edge already exists.</p><p>Only available when the base graph type supports <code>add_edge!</code>. Property arrays are automatically maintained.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/PropertyGraph.jl#L241-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.add_edge!-Union{Tuple{E}, Tuple{V}, Tuple{W}, Tuple{PropertyGraph{&lt;:WeightedGraphInterface{W}, V, E}, Integer, Integer, W, E}} where {W, V, E}" href="#GraphCore.add_edge!-Union{Tuple{E}, Tuple{V}, Tuple{W}, Tuple{PropertyGraph{&lt;:WeightedGraphInterface{W}, V, E}, Integer, Integer, W, E}} where {W, V, E}"><code>GraphCore.add_edge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_edge!(g::PropertyGraph{&lt;:WeightedGraphInterface,V,E}, u::Integer, v::Integer,
          weight::W, edge_prop::E) -&gt; Int32</code></pre><p>Add a weighted edge from u to v with the specified weight and edge property. Returns the edge index of the newly added edge, or 0 if edge already exists.</p><p>Only available when the base graph type supports weighted <code>add_edge!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/PropertyGraph.jl#L258-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.add_edge!-Union{Tuple{W}, Tuple{WeightedAdjGraph{W}, Integer, Integer, W}} where W" href="#GraphCore.add_edge!-Union{Tuple{W}, Tuple{WeightedAdjGraph{W}, Integer, Integer, W}} where W"><code>GraphCore.add_edge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_edge!(g::WeightedAdjGraph{W}, u::Integer, v::Integer, weight::W) -&gt; Int32</code></pre><p>Add a weighted edge from u to v in the graph. Returns the edge index of the newly added edge, or 0 if edge already exists. For undirected graphs, both directions get the same weight.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/AdjGraph.jl#L866-L872">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.add_vertex!" href="#GraphCore.add_vertex!"><code>GraphCore.add_vertex!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_vertex!(g::GraphInterface, ...) -&gt; Int32</code></pre><p>Add a new vertex with optional properties. Returns the index of the newly added vertex. Only available for mutable graph types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L439-L445">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.add_vertex!-Tuple{AdjGraph}" href="#GraphCore.add_vertex!-Tuple{AdjGraph}"><code>GraphCore.add_vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_vertex!(g::AdjGraph) -&gt; Int32</code></pre><p>Add a new isolated vertex to the graph and return its index.</p><p><strong>Performance</strong></p><ul><li><strong>Time Complexity</strong>: O(1)</li><li><strong>Space Complexity</strong>: O(1) - just adds empty vectors</li><li><strong>Index Stability</strong>: All existing vertex/edge indices remain valid</li></ul><p><strong>Implementation Details</strong></p><p>Creates empty neighbor list and empty neighbor<em>to</em>edge mapping. New vertex has no neighbors initially and can be connected via <code>add_edge!</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">g = build_adj_graph([(1,2), (2,3)]; directed=false)
@assert num_vertices(g) == 3

new_v = add_vertex!(g)
@assert new_v == 4
@assert num_vertices(g) == 4
@assert degree(g, new_v) == 0  # Isolated vertex

# Connect new vertex
add_edge!(g, 1, new_v)
@assert degree(g, new_v) == 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/AdjGraph.jl#L736-L764">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.add_vertex!-Union{Tuple{CoreGraph{D}}, Tuple{D}} where D" href="#GraphCore.add_vertex!-Union{Tuple{CoreGraph{D}}, Tuple{D}} where D"><code>GraphCore.add_vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_vertex!(g::CoreGraph) -&gt; Int32</code></pre><p>Add a new isolated vertex to the graph and return its index.</p><p><strong>Efficient Implementation</strong>: O(1) operation that simply extends the vertex_offsets array.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">g = build_core_graph([(1,2), (2,3)]; directed=false)
new_vertex = add_vertex!(g)  # Returns 4
@assert num_vertices(g) == 4
@assert length(neighbor_indices(g, new_vertex)) == 0  # Isolated vertex</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/CoreGraph.jl#L732-L746">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.add_vertex!-Union{Tuple{E}, Tuple{V}, Tuple{G}, Tuple{PropertyGraph{G, V, E}, V}} where {G, V, E}" href="#GraphCore.add_vertex!-Union{Tuple{E}, Tuple{V}, Tuple{G}, Tuple{PropertyGraph{G, V, E}, V}} where {G, V, E}"><code>GraphCore.add_vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_vertex!(g::PropertyGraph{G,V,E}, vertex_prop::V) -&gt; Int32</code></pre><p>Add a new vertex to the property graph with the specified property. Returns the index of the new vertex.</p><p>Only available when the base graph type supports <code>add_vertex!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/PropertyGraph.jl#L227-L234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.add_vertex!-Union{Tuple{WeightedAdjGraph{W}}, Tuple{W}} where W" href="#GraphCore.add_vertex!-Union{Tuple{WeightedAdjGraph{W}}, Tuple{W}} where W"><code>GraphCore.add_vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_vertex!(g::WeightedAdjGraph{W}) -&gt; Int32 where W</code></pre><p>Add a new vertex to the weighted graph and return its index. The new vertex has no neighbors initially.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/AdjGraph.jl#L777-L782">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.add_vertex!-Union{Tuple{WeightedGraph{W, D}}, Tuple{D}, Tuple{W}} where {W, D}" href="#GraphCore.add_vertex!-Union{Tuple{WeightedGraph{W, D}}, Tuple{D}, Tuple{W}} where {W, D}"><code>GraphCore.add_vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_vertex!(g::WeightedGraph) -&gt; Int32</code></pre><p>Add a new isolated vertex to the weighted graph and return its index.</p><p><strong>Efficient Implementation</strong>: O(1) operation that simply extends the vertex_offsets array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/CoreGraph.jl#L1038-L1044">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.all_directed_edges-Tuple{GraphInterface}" href="#GraphCore.all_directed_edges-Tuple{GraphInterface}"><code>GraphCore.all_directed_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">all_directed_edges(g::GraphInterface) -&gt; Iterator</code></pre><p>Return an iterator over all directed edges in the graph.</p><ul><li>For directed graphs: yields (source, target) pairs for each directed edge</li><li>For undirected graphs: yields (u, v) and (v, u) pairs for each undirected edge</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">for (u, v) in all_directed_edges(g)
    println(&quot;Directed edge from &quot;, u, &quot; to &quot;, v)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L570-L583">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.all_edges-Tuple{GraphInterface}" href="#GraphCore.all_edges-Tuple{GraphInterface}"><code>GraphCore.all_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">all_edges(g::GraphInterface) -&gt; Iterator</code></pre><p>Alias for <code>edges(g)</code>. Provided for disambiguation when using multiple graph libraries.</p><p>See also: <a href="#GraphCore.edges-Tuple{GraphInterface}"><code>edges</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L561-L567">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.build_adj_graph-Tuple{Any}" href="#GraphCore.build_adj_graph-Tuple{Any}"><code>GraphCore.build_adj_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Build adjacency list graph with same interface as CoreGraph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/AdjGraph.jl#L709">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.build_core_graph-Tuple{Any}" href="#GraphCore.build_core_graph-Tuple{Any}"><code>GraphCore.build_core_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Build unweighted core graph (most common case)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/CoreGraph.jl#L720">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.build_graph-Union{Tuple{W}, Tuple{E}, Tuple{V}, Tuple{G}, Tuple{Type{PropertyGraph{G, V, E}}, Any}} where {G&lt;:GraphInterface, V, E, W&lt;:Number}" href="#GraphCore.build_graph-Union{Tuple{W}, Tuple{E}, Tuple{V}, Tuple{G}, Tuple{Type{PropertyGraph{G, V, E}}, Any}} where {G&lt;:GraphInterface, V, E, W&lt;:Number}"><code>GraphCore.build_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_graph(::Type{PropertyGraph{G,V,E}}, edges; kwargs...) where {G,V,E}</code></pre><p>Build a property graph with vertex and edge properties. The underlying graph type G determines performance characteristics (CoreGraph for CSR, AdjGraph for adjacency list).</p><p><strong>Arguments</strong></p><ul><li><code>edges</code>: Vector of (u,v) tuples/pairs representing graph edges</li><li><code>directed=true</code>: Whether the graph is directed</li><li><code>vertex_properties=[]</code>: Properties for each vertex (type V)</li><li><code>edge_properties=[]</code>: Properties for each edge (type E)</li><li><code>weights=[]</code>: Edge weights (optional)</li><li><code>validate=true</code>: Whether to validate inputs</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Property graph with CoreGraph backend
g = build_graph(PropertyGraph{CoreGraph,String,String}, [(1,2), (2,3)];
                vertex_properties=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], edge_properties=[&quot;e1&quot;, &quot;e2&quot;])

# Property graph with AdjGraph backend for dynamic use
g = build_graph(PropertyGraph{AdjGraph,Int,Symbol}, [(1,2), (2,3)];
                vertex_properties=[1, 2, 3], edge_properties=[:a, :b])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/PropertyGraph.jl#L107-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.build_graph-Union{Tuple{W}, Tuple{G}, Tuple{Type{G}, Any}} where {G&lt;:Union{AdjGraph, WeightedAdjGraph}, W&lt;:Number}" href="#GraphCore.build_graph-Union{Tuple{W}, Tuple{G}, Tuple{Type{G}, Any}} where {G&lt;:Union{AdjGraph, WeightedAdjGraph}, W&lt;:Number}"><code>GraphCore.build_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_graph(::Type{G}, edges; kwargs...) where {G&lt;:AdjGraphTypes}</code></pre><p>Build adjacency list graph optimized for dynamic modifications and mutations.</p><p><strong>Arguments</strong></p><ul><li><code>edges</code>: Vector of (u,v) tuples/pairs representing graph edges</li><li><code>directed=true</code>: Whether to build a directed graph</li><li><code>weights=[]</code>: Edge weights (for WeightedAdjGraph types)</li><li><code>validate=true</code>: Enable input validation</li></ul><p><strong>Performance Characteristics</strong></p><ul><li><strong>Dynamic-friendly</strong>: Efficient vertex/edge additions and removals</li><li><strong>Memory flexible</strong>: Grows naturally, higher overhead than CSR</li><li><strong>Mutation-optimized</strong>: O(1) edge additions, efficient vertex operations</li></ul><p>Use <code>AdjGraph</code> types when frequent graph modifications are expected. For static graphs with performance-critical traversals, prefer <code>CoreGraph</code> types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/AdjGraph.jl#L581-L599">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.build_graph-Union{Tuple{W}, Tuple{G}, Tuple{Type{G}, Any}} where {G&lt;:Union{CoreGraph, WeightedGraph}, W&lt;:Number}" href="#GraphCore.build_graph-Union{Tuple{W}, Tuple{G}, Tuple{Type{G}, Any}} where {G&lt;:Union{CoreGraph, WeightedGraph}, W&lt;:Number}"><code>GraphCore.build_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_graph(::Type{G}, edges; kwargs...) -&gt; G</code></pre><p>Build a graph from an edge list with comprehensive validation and flexible options.</p><p><strong>Arguments</strong></p><ul><li><code>edges</code>: Vector of (u,v) tuples/pairs representing graph edges</li><li><code>directed=true</code>: Whether to build a directed graph</li><li><code>n=0</code>: Number of vertices (0 = auto-detect from edges)</li><li><code>weights=[]</code>: Edge weights (for WeightedGraph types)</li><li><code>validate=true</code>: Enable input validation (recommended for safety)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic graphs
g = build_graph(CoreGraph, [(1,2), (2,3)]; directed=false)
wg = build_graph(WeightedGraph{Float64}, [(1,2), (2,3)]; weights=[1.5, 2.0], directed=false)

# Graph with isolated vertices
g = build_graph(CoreGraph, [(1,2)]; n=5, directed=false)  # Creates isolated vertices 3,4,5

# High-performance mode (skip validation)
g = build_graph(CoreGraph, trusted_edges; directed=false, validate=false)</code></pre><p>Optimized for CSR representation with efficient construction and memory usage. For dynamic graphs requiring frequent mutations, consider <code>AdjGraph</code> types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/CoreGraph.jl#L558-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.build_property_adj_graph-Union{Tuple{E}, Tuple{V}, Tuple{Any, AbstractVector{V}, AbstractVector{E}}} where {V, E}" href="#GraphCore.build_property_adj_graph-Union{Tuple{E}, Tuple{V}, Tuple{Any, AbstractVector{V}, AbstractVector{E}}} where {V, E}"><code>GraphCore.build_property_adj_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_property_adj_graph(edges, vertex_properties, edge_properties; directed=true, kwargs...)</code></pre><p>Build a PropertyGraph with AdjGraph backend (supports efficient mutations).</p><p><strong>Arguments</strong></p><ul><li><code>edges</code>: Vector of (u,v) tuples representing graph edges</li><li><code>vertex_properties</code>: Vector of vertex properties</li><li><code>edge_properties</code>: Vector of edge properties</li><li><code>directed=true</code>: Whether to build a directed graph</li><li><code>kwargs...</code>: Additional arguments passed to underlying graph construction</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">edges = [(1,2), (2,3)]
vertex_props = [1, 2, 3]
edge_props = [:a, :b]
pg = build_property_adj_graph(edges, vertex_props, edge_props; directed=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/PropertyGraph.jl#L431-L450">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.build_property_graph-Union{Tuple{E}, Tuple{V}, Tuple{Any, AbstractVector{V}, AbstractVector{E}}} where {V, E}" href="#GraphCore.build_property_graph-Union{Tuple{E}, Tuple{V}, Tuple{Any, AbstractVector{V}, AbstractVector{E}}} where {V, E}"><code>GraphCore.build_property_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_property_graph(edges, vertex_properties, edge_properties; directed=true, kwargs...)</code></pre><p>Build a PropertyGraph with CoreGraph backend.</p><p><strong>Arguments</strong></p><ul><li><code>edges</code>: Vector of (u,v) tuples representing graph edges</li><li><code>vertex_properties</code>: Vector of vertex properties</li><li><code>edge_properties</code>: Vector of edge properties</li><li><code>directed=true</code>: Whether to build a directed graph</li><li><code>kwargs...</code>: Additional arguments passed to underlying graph construction</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">edges = [(1,2), (2,3), (1,3)]
vertex_props = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;]
edge_props = [&quot;friend&quot;, &quot;colleague&quot;, &quot;family&quot;]
pg = build_property_graph(edges, vertex_props, edge_props; directed=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/PropertyGraph.jl#L401-L420">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.build_weighted_graph-Union{Tuple{W}, Tuple{Any, AbstractVector{W}}} where W" href="#GraphCore.build_weighted_graph-Union{Tuple{W}, Tuple{Any, AbstractVector{W}}} where W"><code>GraphCore.build_weighted_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Build weighted graph</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/CoreGraph.jl#L724">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.canonicalize_edges-Tuple{Any}" href="#GraphCore.canonicalize_edges-Tuple{Any}"><code>GraphCore.canonicalize_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">canonicalize_edges(edges) -&gt; Vector{Tuple{Int,Int}}</code></pre><p>Convert symmetric edge format to canonical format for undirected graphs.</p><p><strong>Arguments</strong></p><ul><li><code>edges</code>: Vector of (u,v) tuples representing edges</li></ul><p><strong>Returns</strong></p><ul><li>Vector of canonical edges where u ≤ v for each edge</li></ul><p><strong>Format Conversion</strong></p><ul><li><strong>Input</strong>: <code>[(1,2), (2,1), (2,3), (3,2)]</code> (both directions)</li><li><strong>Output</strong>: <code>[(1,2), (2,3)]</code> (canonical: u ≤ v)</li></ul><p>Use when your input has both directions listed for undirected edges. This removes duplicates and ensures a consistent canonical representation.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">edges = [(1,2), (2,1), (2,3), (3,2), (1,3), (3,1)]
canonical = GraphCore.canonicalize_edges(edges)
# Result: [(1,2), (1,3), (2,3)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/utils.jl#L42-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.canonicalize_edges-Union{Tuple{W}, Tuple{Any, AbstractVector{W}}} where W" href="#GraphCore.canonicalize_edges-Union{Tuple{W}, Tuple{Any, AbstractVector{W}}} where W"><code>GraphCore.canonicalize_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">canonicalize_edges(edges, weights::AbstractVector{W}) -&gt; (canonical_edges, canonical_weights)</code></pre><p>Convert symmetric format to canonical, keeping weights for canonical edges only.</p><p><strong>Arguments</strong></p><ul><li><code>edges</code>: Vector of (u,v) tuples representing edges</li><li><code>weights</code>: Vector of weights corresponding to edges</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of (canonical<em>edges, canonical</em>weights)</li></ul><p><strong>Behavior</strong></p><p>When multiple weights exist for the same undirected edge, keeps the first encountered weight. This is useful when processing datasets that list both directions with potentially different weights.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">edges = [(1,2), (2,1), (2,3), (3,2)]
weights = [1.5, 1.5, 2.0, 2.1]  # Note: slight difference in last weight
canonical_edges, canonical_weights = GraphCore.canonicalize_edges(edges, weights)
# Result: edges = [(1,2), (2,3)], weights = [1.5, 2.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/utils.jl#L82-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.degree-Tuple{GraphInterface, Integer}" href="#GraphCore.degree-Tuple{GraphInterface, Integer}"><code>GraphCore.degree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">degree(g::GraphInterface, v::Integer) -&gt; Int32</code></pre><p>Return the degree of vertex v (number of neighbors).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L489-L493">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.directed_edge_index" href="#GraphCore.directed_edge_index"><code>GraphCore.directed_edge_index</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">directed_edge_index(g::GraphInterface, v::Integer, i::Integer) -&gt; Int32</code></pre><p>Get the directed edge index for the i-th neighbor of vertex v.</p><p>Similar to <code>edge_index</code> but for directional properties. Always provides directional indexing even for undirected graphs.</p><p><strong>Key difference</strong>: For undirected graphs:</p><ul><li><code>edge_index(g, u, i) == edge_index(g, v, j)</code> if neighbors are the same edge</li><li><code>directed_edge_index(g, u, i) ≠ directed_edge_index(g, v, j)</code> (always directional)</li></ul><p>This enables asymmetric properties on undirected graphs (e.g., different costs for traversing an edge in each direction).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L230-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.directed_edge_indices" href="#GraphCore.directed_edge_indices"><code>GraphCore.directed_edge_indices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">directed_edge_indices(g::GraphInterface, v::Integer) -&gt; view or iterator</code></pre><p>Return an iterator over the directed edge indices for edges from vertex v. The i-th edge index corresponds to the i-th neighbor in <code>neighbor_indices(g, v)</code><code>. For directed graphs this is the same as</code>directed<em>edge</em>indices(g, v)`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L255-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.directed_edge_indices-Tuple{GraphInterface}" href="#GraphCore.directed_edge_indices-Tuple{GraphInterface}"><code>GraphCore.directed_edge_indices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">directed_edge_indices(g::GraphInterface) -&gt; UnitRange{Int}</code></pre><p>Return a range over all directed edge indices. Suitable for sizing and indexing external directed edge property arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L530-L535">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.edge_index" href="#GraphCore.edge_index"><code>GraphCore.edge_index</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">edge_index(g::GraphInterface, v::Integer, i::Integer) -&gt; Int32</code></pre><p>Get the undirected edge index for the i-th neighbor of vertex v.</p><p>This provides <strong>O(1) conversion</strong> from neighbor position to edge index, enabling efficient indexing into external edge property arrays.</p><p><strong>Relationship</strong>: <code>edge_index(g, v, i) == find_edge_index(g, v, neighbor_indices(g, v)[i])</code></p><p><strong>Use case</strong>: Processing neighbors with associated edge data</p><pre><code class="language-julia hljs">edge_weights = Vector{Float64}(undef, num_edges(g))
for (i, neighbor) in enumerate(neighbor_indices(g, v))
    edge_idx = edge_index(g, v, i)           # O(1) - no search needed!
    weight = edge_weights[edge_idx]          # Direct array access
    process_neighbor_with_weight(neighbor, weight)
end</code></pre><p><strong>Index stability</strong>: Edge indices remain stable during graph analysis, but may be invalidated by structural modifications (add/remove operations).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L205-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.edge_indices" href="#GraphCore.edge_indices"><code>GraphCore.edge_indices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">edge_indices(g::GraphInterface, v::Integer) -&gt; view or iterator</code></pre><p>Return an iterator over the undirected edge indices for edges from vertex v. The i-th edge index corresponds to the i-th neighbor in <code>neighbor_indices(g, v)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L247-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.edge_indices-Tuple{GraphInterface}" href="#GraphCore.edge_indices-Tuple{GraphInterface}"><code>GraphCore.edge_indices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">edge_indices(g::GraphInterface) -&gt; UnitRange{Int}</code></pre><p>Return a range over all undirected edge indices. Suitable for sizing and indexing external edge property arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L520-L525">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.edge_properties" href="#GraphCore.edge_properties"><code>GraphCore.edge_properties</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">edge_properties(g::PropertyGraphInterface) -&gt; iterator</code></pre><p>Return an iterator over all edge properties in edge index order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L420-L424">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.edge_property" href="#GraphCore.edge_property"><code>GraphCore.edge_property</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">edge_property(g::PropertyGraphInterface, edge_idx::Integer) -&gt; E</code></pre><p>Get the property associated with edge at the given edge index. Uses undirected edge indexing (1:num_edges).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L332-L337">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.edge_property-Tuple{GraphInterface, Integer, Integer}" href="#GraphCore.edge_property-Tuple{GraphInterface, Integer, Integer}"><code>GraphCore.edge_property</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">edge_property(g::GraphInterface, u::Integer, v::Integer) -&gt; E</code></pre><p>Get the property of the edge between u and v. Uses undirected edge indexing - for undirected graphs, this returns the same property regardless of direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L498-L504">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.edge_weight" href="#GraphCore.edge_weight"><code>GraphCore.edge_weight</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">edge_weight(g::WeightedGraphInterface, directed_edge_idx::Integer) -&gt; W
edge_weight(g::WeightedGraphInterface, edge::Pair{&lt;:Integer,&lt;:Integer}) -&gt; W</code></pre><p>Get the weight of the directed edge at the given directed edge index. Uses the directional indexing system for O(1) weight lookups. The second form allows querying by vertex pair, equivalent to <code>edge_weight(g, find_edge_index(g, u, v))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L294-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.edge_weights" href="#GraphCore.edge_weights"><code>GraphCore.edge_weights</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">edge_weights(g::WeightedGraphInterface, v::Integer) -&gt; view or iterator
edge_weights(g::WeightedGraphInterface) -&gt; view or iterator</code></pre><p>Return weights for edges from vertex v, or all edge weights.</p><p><strong>Important</strong>: Weights are <strong>always directional</strong>, even for undirected graphs. This design allows asymmetric weights (e.g., different traversal costs in each direction).</p><p><strong>Ordering</strong>: The i-th weight corresponds to the i-th neighbor in <code>neighbor_indices(g, v)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Process neighbors with weights
for (neighbor, weight) in zip(neighbor_indices(g, v), edge_weights(g, v))
    process_weighted_edge(v, neighbor, weight)
end

# More convenient combined iteration
for (neighbor, weight) in neighbor_weights(g, v)
    process_weighted_edge(v, neighbor, weight)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L268-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.edges-Tuple{GraphInterface}" href="#GraphCore.edges-Tuple{GraphInterface}"><code>GraphCore.edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">edges(g::GraphInterface) -&gt; Iterator</code></pre><p>Return an iterator over all edges in the graph.</p><ul><li>For directed graphs: yields (source, target) pairs for each directed edge</li><li>For undirected graphs: yields (u, v) pairs where u ≤ v (each edge once)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">for (u, v) in edges(g)
    println(&quot;Edge from &quot;, u, &quot; to &quot;, v)
end

# Collect all edges
edge_list = collect(edges(g))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L540-L556">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.find_directed_edge_index" href="#GraphCore.find_directed_edge_index"><code>GraphCore.find_directed_edge_index</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_directed_edge_index(g::GraphInterface, u::Integer, v::Integer) -&gt; Int32</code></pre><p>Find the directed edge index for the directed edge from vertices u to v of the graph g. Returns 0 if no such edge exists.</p><p>Always directional: <code>find_directed_edge_index(g, u, v) ≠ find_directed_edge_index(g, v, u)</code></p><p>This index is used for directed edge weight access and other directional properties, and for indexing external arrays of size <code>num_directed_edges(g)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L192-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.find_edge_index" href="#GraphCore.find_edge_index"><code>GraphCore.find_edge_index</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_edge_index(g::GraphInterface, u::Integer, v::Integer) -&gt; Int32</code></pre><p>Find the undirected edge index for the edge between vertices u and v of the graph g. Returns 0 if no such edge exists.</p><p>For undirected graphs: <code>find_edge_index(g, u, v) == find_edge_index(g, v, u)</code> For directed graphs: only finds the edge in the specified direction (u -&gt; v)</p><p>This index is used for edge property access (shared properties) and for indexing external arrays of size num<em>edges(g). For directed graphs this is the same as `find</em>directed<em>edge</em>index(g, u, v)`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L177-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.has_edge" href="#GraphCore.has_edge"><code>GraphCore.has_edge</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_edge(g::GraphInterface, u::Integer, v::Integer) -&gt; Bool</code></pre><p>Test whether there is a directed edge from vertex u to vertex v. For undirected graphs, <code>has_edge(g, u, v) == has_edge(g, v, u)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L116-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.has_vertex" href="#GraphCore.has_vertex"><code>GraphCore.has_vertex</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_vertex(g::GraphInterface, v::Integer) -&gt; Bool</code></pre><p>Test whether vertex v exists in the graph. Vertices are always integers in range 1:num_vertices(g).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.is_directed_graph" href="#GraphCore.is_directed_graph"><code>GraphCore.is_directed_graph</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_directed_graph(g::GraphInterface) -&gt; Bool</code></pre><p>Return true if the graph is directed, false if undirected. This affects the interpretation of edges and neighbor relationships.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L156-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.neighbor" href="#GraphCore.neighbor"><code>GraphCore.neighbor</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">neighbor(g::GraphInterface, v::Integer, i::Integer) -&gt; Int32</code></pre><p>Return the i-th neighbor of vertex v in the graph g.</p><p>Default implementation provided - concrete types may override for efficiency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L168-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.neighbor_indices" href="#GraphCore.neighbor_indices"><code>GraphCore.neighbor_indices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">neighbor_indices(g::GraphInterface, v::Integer) -&gt; view or iterator</code></pre><p>Return an iterator over the neighbor indices of vertex v.</p><p><strong>For directed graphs</strong>: Returns out-neighbors only <strong>For undirected graphs</strong>: Returns all neighbors</p><p><strong>Performance guarantee</strong>: The returned iterator must support:</p><ul><li>Fast iteration: <code>for neighbor in neighbor_indices(g, v)</code></li><li>Length query: <code>length(neighbor_indices(g, v))</code></li><li>Index access: <code>neighbor_indices(g, v)[i]</code> (implementation dependent)</li></ul><p><strong>Memory efficiency</strong>: Implementations should return views when possible to avoid allocation during neighbor traversal.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic iteration
for neighbor in neighbor_indices(g, v)
    process_neighbor(neighbor)
end

# Combined with indexing for edge properties
for (i, neighbor) in enumerate(neighbor_indices(g, v))
    edge_idx = edge_index(g, v, i)        # O(1) edge index lookup
    process_edge(neighbor, edge_idx)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L124-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.neighbor_weights" href="#GraphCore.neighbor_weights"><code>GraphCore.neighbor_weights</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">neighbor_weights(g::WeightedGraphInterface, v::Integer) -&gt; iterator</code></pre><p>Return an iterator over <code>(neighbor_index, weight)</code> pairs for vertex v. More efficient than separate iteration over <code>neighbor_indices(g, v)</code> and <code>edge_weights(g, v)</code>.</p><p>Usage:</p><pre><code class="language-julia hljs">    for (neighbor, weight) in neighbor_weights(g, v)
        # process neighbor and weight together
    end</code></pre><p>See also: <a href="#GraphCore.neighbor_indices"><code>neighbor_indices</code></a>, <a href="#GraphCore.edge_weights"><code>edge_weights</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L304-L317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.num_directed_edges" href="#GraphCore.num_directed_edges"><code>GraphCore.num_directed_edges</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_directed_edges(g::GraphInterface) -&gt; Int32</code></pre><p>Return the total number of directed edges in the graph.</p><ul><li>For undirected graphs: <code>2 * num_edges(g)</code></li><li>For directed graphs: actual count of directed edges</li></ul><p>This count determines the size needed for directed edge property arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L97-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.num_edges" href="#GraphCore.num_edges"><code>GraphCore.num_edges</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_edges(g::GraphInterface) -&gt; Int32</code></pre><p>Return the number of edges in the graph. For undirected graphs, this counts each edge once. For directed graphs, this counts directed edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L88-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.num_vertices" href="#GraphCore.num_vertices"><code>GraphCore.num_vertices</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">num_vertices(g::GraphInterface) -&gt; Int32</code></pre><p>Return the number of vertices in the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.remove_edge!" href="#GraphCore.remove_edge!"><code>GraphCore.remove_edge!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_edge!(g::GraphInterface, u::Integer, v::Integer) -&gt; Bool</code></pre><p>Remove the edge from u to v. Returns true if successful, false if edge doesn&#39;t exist. Only available for mutable graph types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L467-L473">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.remove_edge!-Tuple{AdjGraph, Integer, Integer}" href="#GraphCore.remove_edge!-Tuple{AdjGraph, Integer, Integer}"><code>GraphCore.remove_edge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_edge!(g::AdjGraph, u::Integer, v::Integer) -&gt; Bool</code></pre><p>Remove the edge from u to v from the graph. Returns true if successful, false if edge doesn&#39;t exist.</p><p><strong>Performance</strong></p><ul><li><strong>Time Complexity</strong>: O(degree(u)) + O(degree(v)) for undirected</li><li><strong>Space Complexity</strong>: O(1) - only removes data</li><li><strong>Index Stability</strong>: ⚠️ <strong>MAY BREAK STABILITY</strong> - edge indices may be invalidated</li></ul><p><strong>Implementation Details</strong></p><ul><li><strong>Directed graphs</strong>: Removes only u→v edge</li><li><strong>Undirected graphs</strong>: Removes both u→v and v→u internal representations</li><li><strong>Search cost</strong>: Linear search in neighbor vectors to find edge</li><li><strong>Array operations</strong>: Uses <code>deleteat!</code> which may shift subsequent elements</li></ul><p><strong>Edge Index Invalidation</strong></p><pre><code class="language-julia hljs">g = build_adj_graph([(1,2), (2,3), (1,3)]; directed=false)
# Edge indices: (1,2)→1, (2,3)→2, (1,3)→3

# External edge data
edge_weights = [1.0, 2.0, 1.5]  # Indexed by edge indices

remove_edge!(g, 2, 3)  # Remove edge with index 2
# Now: remaining edges (1,2)→1, (1,3)→?
# ⚠️ Edge index for (1,3) may have changed!
# edge_weights[2] might now refer to wrong edge</code></pre><p><strong>Safe Usage Patterns</strong></p><pre><code class="language-julia hljs"># ✅ SAFE: Use PropertyGraph for automatic edge property management
pg = PropertyGraph(g, vertex_props, edge_props)
remove_edge!(pg, u, v)  # Edge properties automatically maintained

# ✅ SAFE: Use edge-based operations instead of index-based
for (u, v) in edges(g)
    weight = compute_weight_from_vertices(u, v)  # No index dependency
end

# ❌ UNSAFE: Assume edge indices remain stable across removals
edge_data = Vector{Float64}(undef, num_edges(g))
remove_edge!(g, u, v)
# edge_data indices now potentially inconsistent!</code></pre><p><strong>Performance Considerations</strong></p><p>For graphs with frequent edge removals, consider:</p><ol><li><strong>Batch operations</strong>: Remove many edges at once, then rebuild external arrays</li><li><strong>Alternative storage</strong>: Use Dict{Tuple{Int,Int}, T} for edge properties</li><li><strong>Conversion workflow</strong>: AdjGraph for building → CoreGraph for analysis</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/AdjGraph.jl#L1080-L1133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.remove_edge!-Tuple{PropertyGraph, Integer, Integer}" href="#GraphCore.remove_edge!-Tuple{PropertyGraph, Integer, Integer}"><code>GraphCore.remove_edge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_edge!(g::PropertyGraph, u::Integer, v::Integer) -&gt; Bool</code></pre><p>Remove the edge from u to v from the property graph. Returns true if successful, false if edge doesn&#39;t exist.</p><p>Only available when the base graph type supports <code>remove_edge!</code>. Property arrays are automatically maintained.</p><p>⚠️  <strong>Index Invalidation Warning</strong>: Removing edges may invalidate edge indices and external arrays indexed by edge numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/PropertyGraph.jl#L307-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.remove_edge!-Tuple{WeightedAdjGraph, Integer, Integer}" href="#GraphCore.remove_edge!-Tuple{WeightedAdjGraph, Integer, Integer}"><code>GraphCore.remove_edge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_edge!(g::WeightedAdjGraph, u::Integer, v::Integer) -&gt; Bool</code></pre><p>Remove the weighted edge from u to v from the graph. Returns true if successful, false if edge doesn&#39;t exist.</p><p><strong>Performance</strong></p><ul><li><strong>Time Complexity</strong>: O(degree(u)) + O(degree(v)) for undirected</li><li><strong>Space Complexity</strong>: O(1) - only removes data</li><li><strong>Index Stability</strong>: ⚠️ <strong>MAY BREAK STABILITY</strong> - edge indices may be invalidated</li></ul><p><strong>Implementation Details</strong></p><ul><li><strong>Directed graphs</strong>: Removes only u→v edge</li><li><strong>Undirected graphs</strong>: Removes both u→v and v→u internal representations</li><li><strong>Search cost</strong>: Linear search in neighbor vectors to find edge</li><li><strong>Array operations</strong>: Uses <code>deleteat!</code> which may shift subsequent elements</li></ul><p><strong>Edge Index Invalidation</strong></p><pre><code class="language-julia hljs">g = build_weighted_adj_graph([(1,2), (2,3), (1,3)]; directed=false)
# Edge indices: (1,2)→1, (2,3)→2, (1,3)→3

# External edge data
edge_weights = [1.0, 2.0, 1.5]  # Indexed by edge indices

remove_edge!(g, 2, 3)  # Remove edge with index 2
# Now: remaining edges (1,2)→1, (1,3)→?
# ⚠️ Edge index for (1,3) may have changed!
# edge_weights[2] might now refer to wrong edge</code></pre><p><strong>Safe Usage Patterns</strong></p><pre><code class="language-julia hljs"># ✅ SAFE: Use PropertyGraph for automatic edge property management
pg = PropertyGraph(g, vertex_props, edge_props)
remove_edge!(pg, u, v)  # Edge properties automatically maintained

# ✅ SAFE: Use edge-based operations instead of index-based
for (u, v) in edges(g)
    weight = compute_weight_from_vertices(u, v)  # No index dependency
end

# ❌ UNSAFE: Assume edge indices remain stable across removals
edge_data = Vector{Float64}(undef, num_edges(g))
remove_edge!(g, u, v)
# edge_data indices now potentially inconsistent!</code></pre><p><strong>Performance Considerations</strong></p><p>For graphs with frequent edge removals, consider:</p><ol><li><strong>Batch operations</strong>: Remove many edges at once, then rebuild external arrays</li><li><strong>Alternative storage</strong>: Use Dict{Tuple{Int,Int}, T} for edge properties</li><li><strong>Conversion workflow</strong>: AdjGraph for building → CoreGraph for analysis</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/AdjGraph.jl#L1182-L1235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.remove_edge!-Union{Tuple{D}, Tuple{CoreGraph{D}, Integer, Integer}} where D" href="#GraphCore.remove_edge!-Union{Tuple{D}, Tuple{CoreGraph{D}, Integer, Integer}} where D"><code>GraphCore.remove_edge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_edge!(g::CoreGraph, u::Integer, v::Integer) -&gt; Bool</code></pre><p>Remove the edge from u to v from the graph. Returns true if successful, false if edge doesn&#39;t exist.</p><p><strong>Efficient Implementation</strong>: O(degree) operation that removes entries from CSR arrays and updates offsets.</p><p>For frequent mutations, consider using AdjGraph instead.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">g = build_core_graph([(1,2), (2,3), (1,3)]; directed=false)
success = remove_edge!(g, 1, 2)  # Returns true
@assert !has_edge(g, 1, 2) &amp;&amp; !has_edge(g, 2, 1)  # Both directions removed for undirected</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/CoreGraph.jl#L954-L970">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.remove_edge!-Union{Tuple{D}, Tuple{W}, Tuple{WeightedGraph{W, D}, Integer, Integer}} where {W, D}" href="#GraphCore.remove_edge!-Union{Tuple{D}, Tuple{W}, Tuple{WeightedGraph{W, D}, Integer, Integer}} where {W, D}"><code>GraphCore.remove_edge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_edge!(g::WeightedGraph, u::Integer, v::Integer) -&gt; Bool</code></pre><p>Remove the edge from u to v from the weighted graph. Returns true if successful, false if edge doesn&#39;t exist.</p><p><strong>Efficient Implementation</strong>: O(degree) operation that removes entries from CSR arrays and updates offsets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/CoreGraph.jl#L1244-L1251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.remove_vertex!" href="#GraphCore.remove_vertex!"><code>GraphCore.remove_vertex!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_vertex!(g::GraphInterface, v::Integer) -&gt; Bool</code></pre><p>Remove vertex v and all its incident edges. Returns true if successful, false if vertex doesn&#39;t exist. Only available for mutable graph types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L458-L464">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.remove_vertex!-Tuple{AdjGraph, Integer}" href="#GraphCore.remove_vertex!-Tuple{AdjGraph, Integer}"><code>GraphCore.remove_vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_vertex!(g::AdjGraph, v::Integer) -&gt; Bool</code></pre><p>Remove vertex v and all its incident edges from the graph. Returns true if successful, false if vertex doesn&#39;t exist.</p><p><strong>Performance</strong></p><ul><li><strong>Time Complexity</strong>: O(V + incident_edges) - must update all vertex references</li><li><strong>Space Complexity</strong>: O(1) - only removes data</li><li><strong>Index Stability</strong>: ⚠️ <strong>BREAKS STABILITY</strong> - vertex indices &gt; v are decremented</li></ul><p><strong>Implementation Details</strong></p><ol><li><strong>Edge Removal</strong>: All incident edges are removed first (affects edge count)</li><li><strong>Vertex Deletion</strong>: Vertex v is removed from adjacency structures</li><li><strong>Index Update</strong>: All references to vertices &gt; v are decremented by 1</li><li><strong>Property Cleanup</strong>: For PropertyGraph, properties are also removed</li></ol><p><strong>Index Invalidation Warning</strong></p><pre><code class="language-julia hljs">g = build_adj_graph([(1,2), (2,3), (3,4)]; directed=false)
# Before: vertices [1,2,3,4], vertex 3 has neighbors [2,4]

success = remove_vertex!(g, 2)  # Remove vertex 2
# After: vertices [1,2,3], old vertex 3→new vertex 2, old vertex 4→new vertex 3
# ⚠️ External arrays indexed by old vertex numbers are now INVALID!

# External vertex properties become inconsistent:
vertex_labels = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]  # Indexed by old vertex numbers
# After removal: vertex_labels[3] no longer corresponds to current vertex 3!</code></pre><p><strong>Safe Usage Patterns</strong></p><pre><code class="language-julia hljs"># ✅ SAFE: Use PropertyGraph for automatic property management
pg = PropertyGraph(g, vertex_labels, edge_labels)
remove_vertex!(pg, 2)  # Properties automatically updated

# ✅ SAFE: Rebuild external arrays after removal
external_data = rebuild_after_removal(external_data, removed_vertex)

# ❌ UNSAFE: Assume external arrays remain valid after removal
remove_vertex!(g, v)
old_label = vertex_labels[some_vertex]  # May be wrong!</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/AdjGraph.jl#L906-L950">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.remove_vertex!-Tuple{PropertyGraph, Integer}" href="#GraphCore.remove_vertex!-Tuple{PropertyGraph, Integer}"><code>GraphCore.remove_vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_vertex!(g::PropertyGraph, v::Integer) -&gt; Bool</code></pre><p>Remove vertex v and all its incident edges from the property graph. Returns true if successful, false if vertex doesn&#39;t exist.</p><p>Only available when the base graph type supports <code>remove_vertex!</code>. Property arrays are automatically maintained and indices updated.</p><p>⚠️  <strong>Index Invalidation Warning</strong>: Removing vertices renumbers remaining vertices and invalidates external arrays indexed by vertex numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/PropertyGraph.jl#L276-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.remove_vertex!-Tuple{WeightedAdjGraph, Integer}" href="#GraphCore.remove_vertex!-Tuple{WeightedAdjGraph, Integer}"><code>GraphCore.remove_vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_vertex!(g::WeightedAdjGraph, v::Integer) -&gt; Bool</code></pre><p>Remove vertex v and all its incident edges from the weighted graph. Returns true if successful, false if vertex doesn&#39;t exist.</p><p><strong>Performance</strong></p><ul><li><strong>Time Complexity</strong>: O(V + incident_edges) - must update all vertex references</li><li><strong>Space Complexity</strong>: O(1) - only removes data</li><li><strong>Index Stability</strong>: ⚠️ <strong>BREAKS STABILITY</strong> - vertex indices &gt; v are decremented</li></ul><p><strong>Implementation Details</strong></p><ol><li><strong>Edge Removal</strong>: All incident edges are removed first (affects edge count)</li><li><strong>Vertex Deletion</strong>: Vertex v is removed from adjacency structures</li><li><strong>Index Update</strong>: All references to vertices &gt; v are decremented by 1</li><li><strong>Property Cleanup</strong>: For PropertyGraph, properties are also removed</li></ol><p><strong>Index Invalidation Warning</strong></p><pre><code class="language-julia hljs">g = build_weighted_adj_graph([(1,2), (2,3), (3,4)]; directed=false)
# Before: vertices [1,2,3,4], vertex 3 has neighbors [2,4]

success = remove_vertex!(g, 2)  # Remove vertex 2
# After: vertices [1,2,3], old vertex 3→new vertex 2, old vertex 4→new vertex 3
# ⚠️ External arrays indexed by old vertex numbers are now INVALID!

# External vertex properties become inconsistent:
vertex_labels = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]  # Indexed by old vertex numbers
# After removal: vertex_labels[3] no longer corresponds to current vertex 3!</code></pre><p><strong>Safe Usage Patterns</strong></p><pre><code class="language-julia hljs"># ✅ SAFE: Use PropertyGraph for automatic property management
pg = PropertyGraph(g, vertex_labels, edge_labels)
remove_vertex!(pg, 2)  # Properties automatically updated

# ✅ SAFE: Rebuild external arrays after removal
external_data = rebuild_after_removal(external_data, removed_vertex)

# ❌ UNSAFE: Assume external arrays remain valid after removal
remove_vertex!(g, v)
old_label = vertex_labels[some_vertex]  # May be wrong!</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/AdjGraph.jl#L993-L1037">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.remove_vertex!-Union{Tuple{D}, Tuple{CoreGraph{D}, Integer}} where D" href="#GraphCore.remove_vertex!-Union{Tuple{D}, Tuple{CoreGraph{D}, Integer}} where D"><code>GraphCore.remove_vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_vertex!(g::CoreGraph, v::Integer) -&gt; Bool</code></pre><p>Remove vertex v and all its incident edges from the graph. Returns true if successful, false if vertex doesn&#39;t exist.</p><p>⚠️  <strong>Performance Note</strong>: O(V + E) operation due to vertex renumbering requirement. ⚠️  <strong>Index Invalidation</strong>: Removes vertex v and renumbers vertices v+1, v+2, ... to v, v+1, ... This invalidates any external arrays indexed by vertex numbers.</p><p><strong>Implementation</strong>: More efficient than full reconstruction but still requires renumbering.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">g = build_core_graph([(1,2), (2,3), (1,3)]; directed=false)
success = remove_vertex!(g, 2)  # Returns true
@assert num_vertices(g) == 2
@assert has_edge(g, 1, 2)  # What was vertex 3 is now vertex 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/CoreGraph.jl#L840-L859">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.remove_vertex!-Union{Tuple{D}, Tuple{W}, Tuple{WeightedGraph{W, D}, Integer}} where {W, D}" href="#GraphCore.remove_vertex!-Union{Tuple{D}, Tuple{W}, Tuple{WeightedGraph{W, D}, Integer}} where {W, D}"><code>GraphCore.remove_vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">remove_vertex!(g::WeightedGraph, v::Integer) -&gt; Bool</code></pre><p>Remove vertex v and all its incident edges from the weighted graph. Returns true if successful, false if vertex doesn&#39;t exist.</p><p>⚠️  <strong>Performance Note</strong>: O(V + E) operation due to vertex renumbering requirement. ⚠️  <strong>Index Invalidation</strong>: Removes vertex v and renumbers vertices v+1, v+2, ... to v, v+1, ... This invalidates any external arrays indexed by vertex numbers.</p><p><strong>Implementation</strong>: More efficient than full reconstruction but still requires renumbering.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">g = build_weighted_graph([(1,2,1.0), (2,3,2.0), (1,3,3.0)]; directed=false)
success = remove_vertex!(g, 2)  # Returns true
@assert num_vertices(g) == 2
@assert has_edge(g, 1, 2)  # What was vertex 3 is now vertex 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/CoreGraph.jl#L1127-L1146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.set_edge_property!" href="#GraphCore.set_edge_property!"><code>GraphCore.set_edge_property!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_edge_property!(g::PropertyGraphInterface{V,E,W}, edge_idx::Integer, prop::E) -&gt; prop</code></pre><p>Set the property of edge at edge_idx to prop. Only available for mutable graph types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L348-L353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.set_vertex_property!" href="#GraphCore.set_vertex_property!"><code>GraphCore.set_vertex_property!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_vertex_property!(g::PropertyGraphInterface{V,E,W}, v::Integer, prop::V) -&gt; prop</code></pre><p>Set the property of vertex v to prop. Only available for mutable graph types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L340-L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.symmetrize_edges-Tuple{Any}" href="#GraphCore.symmetrize_edges-Tuple{Any}"><code>GraphCore.symmetrize_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symmetrize_edges(edges) -&gt; Vector{Tuple{Int,Int}}</code></pre><p>Convert canonical format to symmetric format (both directions).</p><p><strong>Arguments</strong></p><ul><li><code>edges</code>: Vector of (u,v) tuples in canonical format</li></ul><p><strong>Returns</strong></p><ul><li>Vector of edges with both directions included</li></ul><p><strong>Format Conversion</strong></p><ul><li><strong>Input</strong>: <code>[(1,2), (2,3)]</code> (canonical)</li><li><strong>Output</strong>: <code>[(1,2), (2,1), (2,3), (3,2)]</code> (both directions)</li></ul><p>Use when you need to create a directed graph from undirected edges, or when working with algorithms that expect symmetric adjacency representations.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">canonical = [(1,2), (2,3), (1,3)]
symmetric = GraphCore.symmetrize_edges(canonical)
# Result: [(1,2), (2,1), (2,3), (3,2), (1,3), (3,1)]</code></pre><p><strong>Note</strong></p><p>Self-loops (u,u) are not duplicated to avoid redundancy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/utils.jl#L127-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.symmetrize_edges-Union{Tuple{W}, Tuple{Any, AbstractVector{W}}} where W" href="#GraphCore.symmetrize_edges-Union{Tuple{W}, Tuple{Any, AbstractVector{W}}} where W"><code>GraphCore.symmetrize_edges</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symmetrize_edges(edges, weights::AbstractVector{W}) -&gt; (symmetric_edges, symmetric_weights)</code></pre><p>Convert canonical format to symmetric, duplicating weights for both directions.</p><p><strong>Arguments</strong></p><ul><li><code>edges</code>: Vector of (u,v) tuples in canonical format</li><li><code>weights</code>: Vector of weights corresponding to edges</li></ul><p><strong>Returns</strong></p><ul><li>Tuple of (symmetric<em>edges, symmetric</em>weights)</li></ul><p><strong>Behavior</strong></p><p>Each weight is duplicated for both directions of the edge. This creates a symmetric weight matrix suitable for undirected graph algorithms.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">edges = [(1,2), (2,3)]
weights = [1.5, 2.0]
symmetric_edges, symmetric_weights = GraphCore.symmetrize_edges(edges, weights)
# Result:
# edges = [(1,2), (2,1), (2,3), (3,2)]
# weights = [1.5, 1.5, 2.0, 2.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/utils.jl#L168-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.to_adj_graph-Tuple{GraphInterface}" href="#GraphCore.to_adj_graph-Tuple{GraphInterface}"><code>GraphCore.to_adj_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_adj_graph(g::GraphInterface) -&gt; AdjGraph</code></pre><p>Convert any GraphInterface graph to an AdjGraph. Preserves the directedness of the original graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/AdjGraph.jl#L456-L461">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.to_core_graph-Tuple{GraphInterface}" href="#GraphCore.to_core_graph-Tuple{GraphInterface}"><code>GraphCore.to_core_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_core_graph(g::GraphInterface) -&gt; CoreGraph</code></pre><p>Convert any GraphInterface implementation to a CoreGraph. Preserves the directedness of the original graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/CoreGraph.jl#L435-L440">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.to_weighted_graph-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W" href="#GraphCore.to_weighted_graph-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W"><code>GraphCore.to_weighted_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_weighted_graph(g::WeightedGraphInterface{W}) -&gt; WeightedGraph{W}</code></pre><p>Convert any WeightedGraphInterface to a WeightedGraph. Preserves the directedness and all weights of the original graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/CoreGraph.jl#L452-L457">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.vertex_properties" href="#GraphCore.vertex_properties"><code>GraphCore.vertex_properties</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertex_properties(g::PropertyGraphInterface) -&gt; iterator</code></pre><p>Return an iterator over all vertex properties in order.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">g = build_property_graph(edges, [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], edge_props, 3)
for (i, prop) in enumerate(vertex_properties(g))
    println(&quot;Vertex &quot;, i, &quot; has property: &quot;, prop)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L405-L417">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.vertex_property" href="#GraphCore.vertex_property"><code>GraphCore.vertex_property</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertex_property(g::GraphInterface, v::Integer) -&gt; V</code></pre><p>Get the property associated with vertex v.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L325-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.vertices-Tuple{GraphInterface}" href="#GraphCore.vertices-Tuple{GraphInterface}"><code>GraphCore.vertices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertices(g::GraphInterface) -&gt; UnitRange{Int}</code></pre><p>Return a range over all vertex indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphInterface.jl#L511-L515">source</a></section></article><h2 id="Graph-Construction"><a class="docs-heading-anchor" href="#Graph-Construction">Graph Construction</a><a id="Graph-Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-Construction" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.Builders.GraphBuilder" href="#GraphCore.Builders.GraphBuilder"><code>GraphCore.Builders.GraphBuilder</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GraphBuilder{V,E,W}</code></pre><p>Builder for constructing graphs incrementally. Optimized for fast additions during construction phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphBuilder.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.Builders.build_from_function-Tuple{Function, Function, Int64}" href="#GraphCore.Builders.build_from_function-Tuple{Function, Function, Int64}"><code>GraphCore.Builders.build_from_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_from_function(vertex_fn::Function, edge_fn::Function, nv::Int; directed=true)</code></pre><p>Build a graph by calling vertex<em>fn(i) for each vertex and edge</em>fn(u,v) for potential edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphBuilder.jl#L221-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.add_edge!-Tuple{GraphBuilder{Nothing, Nothing, Nothing}, Integer, Integer}" href="#GraphCore.add_edge!-Tuple{GraphBuilder{Nothing, Nothing, Nothing}, Integer, Integer}"><code>GraphCore.add_edge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_edge!(builder::GraphBuilder{Nothing,Nothing,Nothing}, u::Integer, v::Integer) -&gt; Int32</code></pre><p>Convenience method for basic (unweighted, no properties) graph builders.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphBuilder.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.add_edge!-Union{Tuple{W}, Tuple{E}, Tuple{V}, Tuple{GraphBuilder{V, E, W}, Integer, Integer}} where {V, E, W}" href="#GraphCore.add_edge!-Union{Tuple{W}, Tuple{E}, Tuple{V}, Tuple{GraphBuilder{V, E, W}, Integer, Integer}} where {V, E, W}"><code>GraphCore.add_edge!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_edge!(builder::GraphBuilder, u::Integer, v::Integer;
          edge_property=nothing, weight=nothing) -&gt; Int32</code></pre><p>Add an edge with optional properties and weights using keyword arguments. Returns the edge index (1-based).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic edge
add_edge!(builder, 1, 2)

# Weighted edge
add_edge!(builder, 1, 2; weight=1.5)

# Edge with property
add_edge!(builder, 1, 2; edge_property=&quot;connection&quot;)

# Both weight and property
add_edge!(builder, 1, 2; edge_property=&quot;highway&quot;, weight=2.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphBuilder.jl#L64-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.add_vertex!-Union{Tuple{GraphBuilder{V, E, W}}, Tuple{W}, Tuple{E}, Tuple{V}} where {V, E, W}" href="#GraphCore.add_vertex!-Union{Tuple{GraphBuilder{V, E, W}}, Tuple{W}, Tuple{E}, Tuple{V}} where {V, E, W}"><code>GraphCore.add_vertex!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_vertex!(builder::GraphBuilder [, prop]) -&gt; Int32</code></pre><p>Add a vertex with optional property. Returns the vertex index. For non-property builders, prop should be omitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphBuilder.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.build_graph-Union{Tuple{GraphBuilder{V, E, W}}, Tuple{W}, Tuple{E}, Tuple{V}} where {V, E, W}" href="#GraphCore.build_graph-Union{Tuple{GraphBuilder{V, E, W}}, Tuple{W}, Tuple{E}, Tuple{V}} where {V, E, W}"><code>GraphCore.build_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_graph(builder::GraphBuilder{V,E,W}) -&gt; GraphInterface</code></pre><p>Convert the builder to an optimized graph representation. Automatically chooses the most appropriate graph type among: CoreGraph, WeightedGraph{W}, PropertyGraph{G,V,E}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphBuilder.jl#L143-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.build_graph-Union{Tuple{G}, Tuple{GraphBuilder, Type{G}}} where G&lt;:GraphInterface" href="#GraphCore.build_graph-Union{Tuple{G}, Tuple{GraphBuilder, Type{G}}} where G&lt;:GraphInterface"><code>GraphCore.build_graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_graph(builder::GraphBuilder, ::Type{G}) -&gt; G</code></pre><p>Convert builder to a specific graph type G, where G can be one of: CoreGraph, WeightedGraph{W}, PropertyGraph, AdjGraph, WeightedAdjGraph{W}, PropertyAdjGraph. Note that the builder must be compatible with the target graph type. Also note that the order of the arguments, builder, graph type, is opposite to the usual order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/GraphBuilder.jl#L188-L195">source</a></section></article><h2 id="Conversions"><a class="docs-heading-anchor" href="#Conversions">Conversions</a><a id="Conversions-1"></a><a class="docs-heading-anchor-permalink" href="#Conversions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.Conversions.from_adjacency_matrix-Union{Tuple{W}, Tuple{G}, Tuple{Type{G}, AbstractMatrix{W}}} where {G&lt;:GraphInterface, W&lt;:Number}" href="#GraphCore.Conversions.from_adjacency_matrix-Union{Tuple{W}, Tuple{G}, Tuple{Type{G}, AbstractMatrix{W}}} where {G&lt;:GraphInterface, W&lt;:Number}"><code>GraphCore.Conversions.from_adjacency_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">from_adjacency_matrix(::Type{G}, adj_matrix::AbstractMatrix{W}) where {G&lt;:GraphInterface,W} -&gt; G</code></pre><p>Construct a graph of appropriate type from an adjacency matrix.</p><ul><li>Non-zero entries in adj_matrix become edges with those weights</li><li>If <code>directed</code> is not specified, it is inferred from the symmetry of adj_matrix</li></ul><p>For undirected graphs, adj_matrix should be symmetric.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/Conversions.jl#L96-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.Conversions.from_graphs_jl-Tuple{Graphs.AbstractGraph}" href="#GraphCore.Conversions.from_graphs_jl-Tuple{Graphs.AbstractGraph}"><code>GraphCore.Conversions.from_graphs_jl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">from_graphs_jl(g::Graphs.AbstractGraph; directed::Bool = Graphs.is_directed(g)) -&gt; CoreGraph</code></pre><p>Convert a graph from the Graphs.jl ecosystem to a CoreGraph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/Conversions.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.Conversions.from_weighted_graphs_jl-Union{Tuple{W}, Tuple{Graphs.AbstractGraph, AbstractVector{W}}} where W" href="#GraphCore.Conversions.from_weighted_graphs_jl-Union{Tuple{W}, Tuple{Graphs.AbstractGraph, AbstractVector{W}}} where W"><code>GraphCore.Conversions.from_weighted_graphs_jl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">from_weighted_graphs_jl(g::Graphs.AbstractGraph, weights::AbstractVector{W};
                       directed::Bool = Graphs.is_directed(g)) -&gt; WeightedGraph{W}</code></pre><p>Convert a weighted graph from the Graphs.jl ecosystem to a WeightedGraph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/Conversions.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.Conversions.to_adjacency_matrix-Tuple{GraphInterface}" href="#GraphCore.Conversions.to_adjacency_matrix-Tuple{GraphInterface}"><code>GraphCore.Conversions.to_adjacency_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_adjacency_matrix(g::GraphInterface) -&gt; SparseMatrixCSC{W} where {W}</code></pre><p>Convert a graph to its adjacency matrix representation.</p><ul><li>For directed graphs, the matrix is not required to be symmetric.</li><li>For undirected graphs, the matrix will be symmetric if the weights are.</li><li>For unweighted graphs, entries are 1 where edges exist.</li><li>For weighted graphs, entries are the edge weights (which are not necessarily symmetric even for undirected graphs).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/Conversions.jl#L135-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.Conversions.to_graphs_jl-Tuple{GraphInterface}" href="#GraphCore.Conversions.to_graphs_jl-Tuple{GraphInterface}"><code>GraphCore.Conversions.to_graphs_jl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_graphs_jl(g::GraphInterface) -&gt; Graphs.SimpleGraph or Graphs.SimpleDiGraph</code></pre><p>Convert a property graph to a Graphs.jl graph (losing properties and weights). Returns SimpleGraph for undirected graphs, SimpleDiGraph for directed graphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/Conversions.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.Conversions.to_weighted_graphs_jl-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W&lt;:Number" href="#GraphCore.Conversions.to_weighted_graphs_jl-Union{Tuple{WeightedGraphInterface{W}}, Tuple{W}} where W&lt;:Number"><code>GraphCore.Conversions.to_weighted_graphs_jl</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_weighted_graphs_jl(g::GraphInterface{V,E,W}) where {V,E,W} -&gt;
    SimpleWeightedGraphs.SimpleWeightedGraph or SimpleWeightedGraphs.SimpleWeightedDiGraph</code></pre><p>Convert a WeightedGraphInterface graph to a weighted SimpleWeightedGraphs.jl graph (preserving weights, losing other properties). Requires SimpleWeightedGraphs.jl package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/Conversions.jl#L72-L78">source</a></section></article><h2 id="Lattices"><a class="docs-heading-anchor" href="#Lattices">Lattices</a><a id="Lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Lattices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.Lattices.HypercubicLattice" href="#GraphCore.Lattices.HypercubicLattice"><code>GraphCore.Lattices.HypercubicLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HypercubicLattice{D,T} &lt;: GraphInterface</code></pre><p>A D-dimensional hypercubic lattice graph with side length of type T.</p><p><strong>Type Parameters</strong></p><ul><li><code>D::Int</code>: Dimension of the lattice (1D=line, 2D=grid, 3D=cube, etc.)</li><li><code>T&lt;:Integer</code>: Type for lattice size/coordinates</li></ul><p><strong>Storage</strong></p><p>Uses mathematical coordinate mapping instead of explicit edge storage. Memory usage: O(1) regardless of lattice size!</p><p><strong>Coordinate System</strong></p><ul><li>Vertices are numbered 1 to prod(sizes)</li><li>Coordinates are 0-indexed: (0,0,...,0) to (size₁-1, size₂-1, ..., sizeD-1)</li><li>Periodic boundary conditions optional</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># 2D grid: 10×10
lattice_2d = HypercubicLattice{2,Int}((10, 10))

# 3D cube: 5×5×5
lattice_3d = HypercubicLattice{3,Int}((5, 5, 5))

# 1D chain: 100 vertices
lattice_1d = HypercubicLattice{1,Int}((100,))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/Lattices.jl#L23-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.Lattices.coord_to_vertex-Union{Tuple{T}, Tuple{D}, Tuple{HypercubicLattice{D, T}, NTuple{D, T}}} where {D, T}" href="#GraphCore.Lattices.coord_to_vertex-Union{Tuple{T}, Tuple{D}, Tuple{HypercubicLattice{D, T}, NTuple{D, T}}} where {D, T}"><code>GraphCore.Lattices.coord_to_vertex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coord_to_vertex(g::HypercubicLattice{D,T}, coord::NTuple{D,T}) -&gt; Int32</code></pre><p>Convert coordinates to vertex index using optimized arithmetic. Specialized for common dimensions with loop unrolling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/Lattices.jl#L407-L412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.Lattices.lattice_dimension-Union{Tuple{HypercubicLattice{D, T}}, Tuple{T}, Tuple{D}} where {D, T}" href="#GraphCore.Lattices.lattice_dimension-Union{Tuple{HypercubicLattice{D, T}}, Tuple{T}, Tuple{D}} where {D, T}"><code>GraphCore.Lattices.lattice_dimension</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get the dimensions of the lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/Lattices.jl#L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.Lattices.lattice_distance-Union{Tuple{T}, Tuple{D}, Tuple{HypercubicLattice{D, T}, Integer, Integer}} where {D, T}" href="#GraphCore.Lattices.lattice_distance-Union{Tuple{T}, Tuple{D}, Tuple{HypercubicLattice{D, T}, Integer, Integer}} where {D, T}"><code>GraphCore.Lattices.lattice_distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lattice_distance(g::HypercubicLattice, u::Integer, v::Integer) -&gt; Float64</code></pre><p>Compute the Manhattan distance between two vertices on the lattice. Accounts for periodic boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/Lattices.jl#L340-L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.Lattices.lattice_neighbors-Tuple{HypercubicLattice, Integer}" href="#GraphCore.Lattices.lattice_neighbors-Tuple{HypercubicLattice, Integer}"><code>GraphCore.Lattices.lattice_neighbors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lattice_neighbors(g::HypercubicLattice, v::Integer) -&gt; Vector{Int32}</code></pre><p>Alias for neighbor_indices with better name for lattice context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/Lattices.jl#L362-L366">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.Lattices.lattice_size-Tuple{HypercubicLattice}" href="#GraphCore.Lattices.lattice_size-Tuple{HypercubicLattice}"><code>GraphCore.Lattices.lattice_size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get the size tuple of the lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/Lattices.jl#L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.Lattices.vertex_to_coord-Union{Tuple{T}, Tuple{D}, Tuple{HypercubicLattice{D, T}, Integer}} where {D, T}" href="#GraphCore.Lattices.vertex_to_coord-Union{Tuple{T}, Tuple{D}, Tuple{HypercubicLattice{D, T}, Integer}} where {D, T}"><code>GraphCore.Lattices.vertex_to_coord</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vertex_to_coord(g::HypercubicLattice{D,T}, v::Integer) -&gt; NTuple{D,T}</code></pre><p>Convert vertex index to coordinates using optimized integer arithmetic. Fully inlined and branch-free for maximum performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/Lattices.jl#L373-L378">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.PowerOfTwoLattices.PowerOfTwoLattice" href="#GraphCore.PowerOfTwoLattices.PowerOfTwoLattice"><code>GraphCore.PowerOfTwoLattices.PowerOfTwoLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PowerOfTwoLattice{D} &lt;: GraphInterface</code></pre><p>Ultra-fast D-dimensional hypercubic lattice where all sizes are powers of 2. Uses bit operations for coordinate conversion and neighbor lookup.</p><p><strong>Restrictions</strong></p><ul><li>D ≤ 5 (keeps neighbor tuples reasonable)</li><li>All sizes must be powers of 2: 2, 4, 8, 16, 32, 64, 128, ...</li><li>Periodic boundary conditions (makes bit operations clean)</li></ul><p><strong>Type Parameters</strong></p><ul><li>D::Int: Dimension (1 ≤ D ≤ 5)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># 2D: 16×32 grid (2^4 × 2^5)
g2d = P2Grid2D(4, 5)  # log₂ sizes

# 3D: 8×8×16 cube (2^3 × 2^3 × 2^4)
g3d = P2Grid3D(3, 3, 4)

# 1D: 64-element chain (2^6)
g1d = P2Chain1D(6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/PowerOfTwoLattices.jl#L26-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.PowerOfTwoLattices.P2Chain1D-Tuple{Integer}" href="#GraphCore.PowerOfTwoLattices.P2Chain1D-Tuple{Integer}"><code>GraphCore.PowerOfTwoLattices.P2Chain1D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>1D chain: size = 2^log_size</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/PowerOfTwoLattices.jl#L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.PowerOfTwoLattices.P2Grid2D-Tuple{Integer, Integer}" href="#GraphCore.PowerOfTwoLattices.P2Grid2D-Tuple{Integer, Integer}"><code>GraphCore.PowerOfTwoLattices.P2Grid2D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>2D grid: sizes = 2^log<em>width × 2^log</em>height</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/PowerOfTwoLattices.jl#L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.PowerOfTwoLattices.P2Grid3D-Tuple{Integer, Integer, Integer}" href="#GraphCore.PowerOfTwoLattices.P2Grid3D-Tuple{Integer, Integer, Integer}"><code>GraphCore.PowerOfTwoLattices.P2Grid3D</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>3D cube: sizes = 2^log<em>width × 2^log</em>height × 2^log_depth</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/PowerOfTwoLattices.jl#L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.PowerOfTwoLattices.lattice_dimension-Union{Tuple{PowerOfTwoLattice{D}}, Tuple{D}} where D" href="#GraphCore.PowerOfTwoLattices.lattice_dimension-Union{Tuple{PowerOfTwoLattice{D}}, Tuple{D}} where D"><code>GraphCore.PowerOfTwoLattices.lattice_dimension</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get lattice dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/PowerOfTwoLattices.jl#L507">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GraphCore.PowerOfTwoLattices.lattice_size-Tuple{PowerOfTwoLattice}" href="#GraphCore.PowerOfTwoLattices.lattice_size-Tuple{PowerOfTwoLattice}"><code>GraphCore.PowerOfTwoLattices.lattice_size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Get actual sizes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jlidmar/GraphCore.jl/blob/68a2281fe32583d8860f8bb05a16ab4ee9e68621/src/PowerOfTwoLattices.jl#L510">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../design/">« Design Philosophy</a><a class="docs-footer-nextpage" href="../docindex/">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 6 September 2025 18:01">Saturday 6 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
